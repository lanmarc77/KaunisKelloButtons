   1               		.file	"irmp.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 101               	.global	irmp_init
 103               	irmp_init:
   1:irmp.c        **** /*-------------------------------------------------------------------------------------------------
   2:irmp.c        ****  * irmp.c - infrared multi-protocol decoder, supports several remote control protocols
   3:irmp.c        ****  *
   4:irmp.c        ****  * Copyright (c) 2009-2014 Frank Meyer - frank(at)fli4l.de
   5:irmp.c        ****  *
   6:irmp.c        ****  * $Id: irmp.c,v 1.166 2014/09/19 13:26:00 fm Exp $
   7:irmp.c        ****  *
   8:irmp.c        ****  * Supported AVR mikrocontrollers:
   9:irmp.c        ****  *
  10:irmp.c        ****  * ATtiny87,  ATtiny167
  11:irmp.c        ****  * ATtiny45,  ATtiny85
  12:irmp.c        ****  * ATtiny44,  ATtiny84
  13:irmp.c        ****  * ATmega8,   ATmega16,  ATmega32
  14:irmp.c        ****  * ATmega162
  15:irmp.c        ****  * ATmega164, ATmega324, ATmega644,  ATmega644P, ATmega1284, ATmega1284P
  16:irmp.c        ****  * ATmega88,  ATmega88P, ATmega168,  ATmega168P, ATmega328P
  17:irmp.c        ****  *
  18:irmp.c        ****  * This program is free software; you can redistribute it and/or modify
  19:irmp.c        ****  * it under the terms of the GNU General Public License as published by
  20:irmp.c        ****  * the Free Software Foundation; either version 2 of the License, or
  21:irmp.c        ****  * (at your option) any later version.
  22:irmp.c        ****  *-------------------------------------------------------------------------------------------------
  23:irmp.c        ****  */
  24:irmp.c        **** 
  25:irmp.c        **** #include "irmp.h"
  26:irmp.c        **** 
  27:irmp.c        **** #if IRMP_SUPPORT_GRUNDIG_PROTOCOL == 1 || IRMP_SUPPORT_NOKIA_PROTOCOL == 1 || IRMP_SUPPORT_IR60_PRO
  28:irmp.c        **** #  define IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL  1
  29:irmp.c        **** #else
  30:irmp.c        **** #  define IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL  0
  31:irmp.c        **** #endif
  32:irmp.c        **** 
  33:irmp.c        **** #if IRMP_SUPPORT_SIEMENS_PROTOCOL == 1 || IRMP_SUPPORT_RUWIDO_PROTOCOL == 1
  34:irmp.c        **** #  define IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL   1
  35:irmp.c        **** #else
  36:irmp.c        **** #  define IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL   0
  37:irmp.c        **** #endif
  38:irmp.c        **** 
  39:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 ||                   \
  40:irmp.c        ****     IRMP_SUPPORT_RC6_PROTOCOL == 1 ||                   \
  41:irmp.c        ****     IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1 ||    \
  42:irmp.c        ****     IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1 ||     \
  43:irmp.c        ****     IRMP_SUPPORT_IR60_PROTOCOL == 1 ||                  \
  44:irmp.c        ****     IRMP_SUPPORT_A1TVBOX_PROTOCOL == 1 ||               \
  45:irmp.c        ****     IRMP_SUPPORT_ORTEK_PROTOCOL == 1
  46:irmp.c        **** #  define IRMP_SUPPORT_MANCHESTER                   1
  47:irmp.c        **** #else
  48:irmp.c        **** #  define IRMP_SUPPORT_MANCHESTER                   0
  49:irmp.c        **** #endif
  50:irmp.c        **** 
  51:irmp.c        **** #if IRMP_SUPPORT_NETBOX_PROTOCOL == 1
  52:irmp.c        **** #  define IRMP_SUPPORT_SERIAL                       1
  53:irmp.c        **** #else
  54:irmp.c        **** #  define IRMP_SUPPORT_SERIAL                       0
  55:irmp.c        **** #endif
  56:irmp.c        **** 
  57:irmp.c        **** #define IRMP_KEY_REPETITION_LEN                 (uint16_t)(F_INTERRUPTS * 150.0e-3 + 0.5)          
  58:irmp.c        **** 
  59:irmp.c        **** #define MIN_TOLERANCE_00                        1.0                           // -0%
  60:irmp.c        **** #define MAX_TOLERANCE_00                        1.0                           // +0%
  61:irmp.c        **** 
  62:irmp.c        **** #define MIN_TOLERANCE_05                        0.95                          // -5%
  63:irmp.c        **** #define MAX_TOLERANCE_05                        1.05                          // +5%
  64:irmp.c        **** 
  65:irmp.c        **** #define MIN_TOLERANCE_10                        0.9                           // -10%
  66:irmp.c        **** #define MAX_TOLERANCE_10                        1.1                           // +10%
  67:irmp.c        **** 
  68:irmp.c        **** #define MIN_TOLERANCE_15                        0.85                          // -15%
  69:irmp.c        **** #define MAX_TOLERANCE_15                        1.15                          // +15%
  70:irmp.c        **** 
  71:irmp.c        **** #define MIN_TOLERANCE_20                        0.8                           // -20%
  72:irmp.c        **** #define MAX_TOLERANCE_20                        1.2                           // +20%
  73:irmp.c        **** 
  74:irmp.c        **** #define MIN_TOLERANCE_30                        0.7                           // -30%
  75:irmp.c        **** #define MAX_TOLERANCE_30                        1.3                           // +30%
  76:irmp.c        **** 
  77:irmp.c        **** #define MIN_TOLERANCE_40                        0.6                           // -40%
  78:irmp.c        **** #define MAX_TOLERANCE_40                        1.4                           // +40%
  79:irmp.c        **** 
  80:irmp.c        **** #define MIN_TOLERANCE_50                        0.5                           // -50%
  81:irmp.c        **** #define MAX_TOLERANCE_50                        1.5                           // +50%
  82:irmp.c        **** 
  83:irmp.c        **** #define MIN_TOLERANCE_60                        0.4                           // -60%
  84:irmp.c        **** #define MAX_TOLERANCE_60                        1.6                           // +60%
  85:irmp.c        **** 
  86:irmp.c        **** #define MIN_TOLERANCE_70                        0.3                           // -70%
  87:irmp.c        **** #define MAX_TOLERANCE_70                        1.7                           // +70%
  88:irmp.c        **** 
  89:irmp.c        **** #define SIRCS_START_BIT_PULSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PULSE_TIM
  90:irmp.c        **** #define SIRCS_START_BIT_PULSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PULSE_TIM
  91:irmp.c        **** #define SIRCS_START_BIT_PAUSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PAUSE_TIM
  92:irmp.c        **** #if IRMP_SUPPORT_NETBOX_PROTOCOL                // only 5% to avoid conflict with NETBOX:
  93:irmp.c        **** #  define SIRCS_START_BIT_PAUSE_LEN_MAX         ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PAUSE_TIM
  94:irmp.c        **** #else                                           // only 5% + 1 to avoid conflict with RC6:
  95:irmp.c        **** #  define SIRCS_START_BIT_PAUSE_LEN_MAX         ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PAUSE_TIM
  96:irmp.c        **** #endif
  97:irmp.c        **** #define SIRCS_1_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * SIRCS_1_PULSE_TIME * MIN_
  98:irmp.c        **** #define SIRCS_1_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * SIRCS_1_PULSE_TIME * MAX_
  99:irmp.c        **** #define SIRCS_0_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * SIRCS_0_PULSE_TIME * MIN_
 100:irmp.c        **** #define SIRCS_0_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * SIRCS_0_PULSE_TIME * MAX_
 101:irmp.c        **** #define SIRCS_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * SIRCS_PAUSE_TIME * MIN_TO
 102:irmp.c        **** #define SIRCS_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * SIRCS_PAUSE_TIME * MAX_TO
 103:irmp.c        **** 
 104:irmp.c        **** #define NEC_START_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * NEC_START_BIT_PULSE_TIME 
 105:irmp.c        **** #define NEC_START_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * NEC_START_BIT_PULSE_TIME 
 106:irmp.c        **** #define NEC_START_BIT_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * NEC_START_BIT_PAUSE_TIME 
 107:irmp.c        **** #define NEC_START_BIT_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * NEC_START_BIT_PAUSE_TIME 
 108:irmp.c        **** #define NEC_REPEAT_START_BIT_PAUSE_LEN_MIN      ((uint8_t)(F_INTERRUPTS * NEC_REPEAT_START_BIT_PAUS
 109:irmp.c        **** #define NEC_REPEAT_START_BIT_PAUSE_LEN_MAX      ((uint8_t)(F_INTERRUPTS * NEC_REPEAT_START_BIT_PAUS
 110:irmp.c        **** #define NEC_PULSE_LEN_MIN                       ((uint8_t)(F_INTERRUPTS * NEC_PULSE_TIME * MIN_TOLE
 111:irmp.c        **** #define NEC_PULSE_LEN_MAX                       ((uint8_t)(F_INTERRUPTS * NEC_PULSE_TIME * MAX_TOLE
 112:irmp.c        **** #define NEC_1_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * NEC_1_PAUSE_TIME * MIN_TO
 113:irmp.c        **** #define NEC_1_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * NEC_1_PAUSE_TIME * MAX_TO
 114:irmp.c        **** #define NEC_0_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * NEC_0_PAUSE_TIME * MIN_TO
 115:irmp.c        **** #define NEC_0_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * NEC_0_PAUSE_TIME * MAX_TO
 116:irmp.c        **** // autodetect nec repetition frame within 50 msec:
 117:irmp.c        **** // NEC seems to send the first repetition frame after 40ms, further repetition frames after 100 ms
 118:irmp.c        **** #if 0
 119:irmp.c        **** #define NEC_FRAME_REPEAT_PAUSE_LEN_MAX          (uint16_t)(F_INTERRUPTS * NEC_FRAME_REPEAT_PAUSE_TI
 120:irmp.c        **** #else
 121:irmp.c        **** #define NEC_FRAME_REPEAT_PAUSE_LEN_MAX          (uint16_t)(F_INTERRUPTS * 100.0e-3 * MAX_TOLERANCE_
 122:irmp.c        **** #endif
 123:irmp.c        **** 
 124:irmp.c        **** #define SAMSUNG_START_BIT_PULSE_LEN_MIN         ((uint8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PULSE_T
 125:irmp.c        **** #define SAMSUNG_START_BIT_PULSE_LEN_MAX         ((uint8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PULSE_T
 126:irmp.c        **** #define SAMSUNG_START_BIT_PAUSE_LEN_MIN         ((uint8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PAUSE_T
 127:irmp.c        **** #define SAMSUNG_START_BIT_PAUSE_LEN_MAX         ((uint8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PAUSE_T
 128:irmp.c        **** #define SAMSUNG_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * SAMSUNG_PULSE_TIME * MIN_
 129:irmp.c        **** #define SAMSUNG_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * SAMSUNG_PULSE_TIME * MAX_
 130:irmp.c        **** #define SAMSUNG_1_PAUSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * SAMSUNG_1_PAUSE_TIME * MI
 131:irmp.c        **** #define SAMSUNG_1_PAUSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * SAMSUNG_1_PAUSE_TIME * MA
 132:irmp.c        **** #define SAMSUNG_0_PAUSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * SAMSUNG_0_PAUSE_TIME * MI
 133:irmp.c        **** #define SAMSUNG_0_PAUSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * SAMSUNG_0_PAUSE_TIME * MA
 134:irmp.c        **** 
 135:irmp.c        **** #define MATSUSHITA_START_BIT_PULSE_LEN_MIN      ((uint8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT_PULS
 136:irmp.c        **** #define MATSUSHITA_START_BIT_PULSE_LEN_MAX      ((uint8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT_PULS
 137:irmp.c        **** #define MATSUSHITA_START_BIT_PAUSE_LEN_MIN      ((uint8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT_PAUS
 138:irmp.c        **** #define MATSUSHITA_START_BIT_PAUSE_LEN_MAX      ((uint8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT_PAUS
 139:irmp.c        **** #define MATSUSHITA_PULSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * MATSUSHITA_PULSE_TIME * M
 140:irmp.c        **** #define MATSUSHITA_PULSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * MATSUSHITA_PULSE_TIME * M
 141:irmp.c        **** #define MATSUSHITA_1_PAUSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * MATSUSHITA_1_PAUSE_TIME *
 142:irmp.c        **** #define MATSUSHITA_1_PAUSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * MATSUSHITA_1_PAUSE_TIME *
 143:irmp.c        **** #define MATSUSHITA_0_PAUSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * MATSUSHITA_0_PAUSE_TIME *
 144:irmp.c        **** #define MATSUSHITA_0_PAUSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * MATSUSHITA_0_PAUSE_TIME *
 145:irmp.c        **** 
 146:irmp.c        **** #define KASEIKYO_START_BIT_PULSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_PULSE_
 147:irmp.c        **** #define KASEIKYO_START_BIT_PULSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_PULSE_
 148:irmp.c        **** #define KASEIKYO_START_BIT_PAUSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_PAUSE_
 149:irmp.c        **** #define KASEIKYO_START_BIT_PAUSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_PAUSE_
 150:irmp.c        **** #define KASEIKYO_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * KASEIKYO_PULSE_TIME * MIN
 151:irmp.c        **** #define KASEIKYO_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * KASEIKYO_PULSE_TIME * MAX
 152:irmp.c        **** #define KASEIKYO_1_PAUSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KASEIKYO_1_PAUSE_TIME * M
 153:irmp.c        **** #define KASEIKYO_1_PAUSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KASEIKYO_1_PAUSE_TIME * M
 154:irmp.c        **** #define KASEIKYO_0_PAUSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KASEIKYO_0_PAUSE_TIME * M
 155:irmp.c        **** #define KASEIKYO_0_PAUSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KASEIKYO_0_PAUSE_TIME * M
 156:irmp.c        **** 
 157:irmp.c        **** #define RECS80_START_BIT_PULSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * RECS80_START_BIT_PULSE_TI
 158:irmp.c        **** #define RECS80_START_BIT_PULSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * RECS80_START_BIT_PULSE_TI
 159:irmp.c        **** #define RECS80_START_BIT_PAUSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * RECS80_START_BIT_PAUSE_TI
 160:irmp.c        **** #define RECS80_START_BIT_PAUSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * RECS80_START_BIT_PAUSE_TI
 161:irmp.c        **** #define RECS80_PULSE_LEN_MIN                    ((uint8_t)(F_INTERRUPTS * RECS80_PULSE_TIME * MIN_T
 162:irmp.c        **** #define RECS80_PULSE_LEN_MAX                    ((uint8_t)(F_INTERRUPTS * RECS80_PULSE_TIME * MAX_T
 163:irmp.c        **** #define RECS80_1_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * RECS80_1_PAUSE_TIME * MIN
 164:irmp.c        **** #define RECS80_1_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * RECS80_1_PAUSE_TIME * MAX
 165:irmp.c        **** #define RECS80_0_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * RECS80_0_PAUSE_TIME * MIN
 166:irmp.c        **** #define RECS80_0_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * RECS80_0_PAUSE_TIME * MAX
 167:irmp.c        **** 
 168:irmp.c        **** 
 169:irmp.c        **** #if IRMP_SUPPORT_BOSE_PROTOCOL == 1 // BOSE conflicts with RC5, so keep tolerance for RC5 minimal h
 170:irmp.c        **** #define RC5_START_BIT_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RC5_BIT_TIME * MIN_TOLERA
 171:irmp.c        **** #define RC5_START_BIT_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RC5_BIT_TIME * MAX_TOLERA
 172:irmp.c        **** #else
 173:irmp.c        **** #define RC5_START_BIT_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RC5_BIT_TIME * MIN_TOLERA
 174:irmp.c        **** #define RC5_START_BIT_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RC5_BIT_TIME * MAX_TOLERA
 175:irmp.c        **** #endif
 176:irmp.c        **** 
 177:irmp.c        **** #define RC5_BIT_LEN_MIN                         ((uint8_t)(F_INTERRUPTS * RC5_BIT_TIME * MIN_TOLERA
 178:irmp.c        **** #define RC5_BIT_LEN_MAX                         ((uint8_t)(F_INTERRUPTS * RC5_BIT_TIME * MAX_TOLERA
 179:irmp.c        **** 
 180:irmp.c        **** #define DENON_PULSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * DENON_PULSE_TIME * MIN_TO
 181:irmp.c        **** #define DENON_PULSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * DENON_PULSE_TIME * MAX_TO
 182:irmp.c        **** #define DENON_1_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * DENON_1_PAUSE_TIME * MIN_
 183:irmp.c        **** #define DENON_1_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * DENON_1_PAUSE_TIME * MAX_
 184:irmp.c        **** // RUWIDO (see t-home-mediareceiver-15kHz.txt) conflicts here with DENON
 185:irmp.c        **** #define DENON_0_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * DENON_0_PAUSE_TIME * MIN_
 186:irmp.c        **** #define DENON_0_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * DENON_0_PAUSE_TIME * MAX_
 187:irmp.c        **** #define DENON_AUTO_REPETITION_PAUSE_LEN         ((uint16_t)(F_INTERRUPTS * DENON_AUTO_REPETITION_PA
 188:irmp.c        **** 
 189:irmp.c        **** #define THOMSON_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * THOMSON_PULSE_TIME * MIN_
 190:irmp.c        **** #define THOMSON_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * THOMSON_PULSE_TIME * MAX_
 191:irmp.c        **** #define THOMSON_1_PAUSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * THOMSON_1_PAUSE_TIME * MI
 192:irmp.c        **** #define THOMSON_1_PAUSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * THOMSON_1_PAUSE_TIME * MA
 193:irmp.c        **** #define THOMSON_0_PAUSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * THOMSON_0_PAUSE_TIME * MI
 194:irmp.c        **** #define THOMSON_0_PAUSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * THOMSON_0_PAUSE_TIME * MA
 195:irmp.c        **** 
 196:irmp.c        **** #define RC6_START_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * RC6_START_BIT_PULSE_TIME 
 197:irmp.c        **** #define RC6_START_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * RC6_START_BIT_PULSE_TIME 
 198:irmp.c        **** #define RC6_START_BIT_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * RC6_START_BIT_PAUSE_TIME 
 199:irmp.c        **** #define RC6_START_BIT_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * RC6_START_BIT_PAUSE_TIME 
 200:irmp.c        **** #define RC6_TOGGLE_BIT_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * RC6_TOGGLE_BIT_TIME * MIN
 201:irmp.c        **** #define RC6_TOGGLE_BIT_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * RC6_TOGGLE_BIT_TIME * MAX
 202:irmp.c        **** #define RC6_BIT_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RC6_BIT_TIME * MIN_TOLERA
 203:irmp.c        **** #define RC6_BIT_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RC6_BIT_TIME * MAX_TOLERA
 204:irmp.c        **** #define RC6_BIT_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RC6_BIT_TIME * MIN_TOLERA
 205:irmp.c        **** #define RC6_BIT_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RC6_BIT_TIME * MAX_TOLERA
 206:irmp.c        **** 
 207:irmp.c        **** #define RECS80EXT_START_BIT_PULSE_LEN_MIN       ((uint8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_PULSE
 208:irmp.c        **** #define RECS80EXT_START_BIT_PULSE_LEN_MAX       ((uint8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_PULSE
 209:irmp.c        **** #define RECS80EXT_START_BIT_PAUSE_LEN_MIN       ((uint8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_PAUSE
 210:irmp.c        **** #define RECS80EXT_START_BIT_PAUSE_LEN_MAX       ((uint8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_PAUSE
 211:irmp.c        **** #define RECS80EXT_PULSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * RECS80EXT_PULSE_TIME * MI
 212:irmp.c        **** #define RECS80EXT_PULSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * RECS80EXT_PULSE_TIME * MA
 213:irmp.c        **** #define RECS80EXT_1_PAUSE_LEN_MIN               ((uint8_t)(F_INTERRUPTS * RECS80EXT_1_PAUSE_TIME * 
 214:irmp.c        **** #define RECS80EXT_1_PAUSE_LEN_MAX               ((uint8_t)(F_INTERRUPTS * RECS80EXT_1_PAUSE_TIME * 
 215:irmp.c        **** #define RECS80EXT_0_PAUSE_LEN_MIN               ((uint8_t)(F_INTERRUPTS * RECS80EXT_0_PAUSE_TIME * 
 216:irmp.c        **** #define RECS80EXT_0_PAUSE_LEN_MAX               ((uint8_t)(F_INTERRUPTS * RECS80EXT_0_PAUSE_TIME * 
 217:irmp.c        **** 
 218:irmp.c        **** #define NUBERT_START_BIT_PULSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * NUBERT_START_BIT_PULSE_TI
 219:irmp.c        **** #define NUBERT_START_BIT_PULSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * NUBERT_START_BIT_PULSE_TI
 220:irmp.c        **** #define NUBERT_START_BIT_PAUSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * NUBERT_START_BIT_PAUSE_TI
 221:irmp.c        **** #define NUBERT_START_BIT_PAUSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * NUBERT_START_BIT_PAUSE_TI
 222:irmp.c        **** #define NUBERT_1_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * NUBERT_1_PULSE_TIME * MIN
 223:irmp.c        **** #define NUBERT_1_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * NUBERT_1_PULSE_TIME * MAX
 224:irmp.c        **** #define NUBERT_1_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * NUBERT_1_PAUSE_TIME * MIN
 225:irmp.c        **** #define NUBERT_1_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * NUBERT_1_PAUSE_TIME * MAX
 226:irmp.c        **** #define NUBERT_0_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * NUBERT_0_PULSE_TIME * MIN
 227:irmp.c        **** #define NUBERT_0_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * NUBERT_0_PULSE_TIME * MAX
 228:irmp.c        **** #define NUBERT_0_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * NUBERT_0_PAUSE_TIME * MIN
 229:irmp.c        **** #define NUBERT_0_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * NUBERT_0_PAUSE_TIME * MAX
 230:irmp.c        **** 
 231:irmp.c        **** #define SPEAKER_START_BIT_PULSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * SPEAKER_START_BIT_PULSE_
 232:irmp.c        **** #define SPEAKER_START_BIT_PULSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * SPEAKER_START_BIT_PULSE_
 233:irmp.c        **** #define SPEAKER_START_BIT_PAUSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * SPEAKER_START_BIT_PAUSE_
 234:irmp.c        **** #define SPEAKER_START_BIT_PAUSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * SPEAKER_START_BIT_PAUSE_
 235:irmp.c        **** #define SPEAKER_1_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * SPEAKER_1_PULSE_TIME * M
 236:irmp.c        **** #define SPEAKER_1_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * SPEAKER_1_PULSE_TIME * M
 237:irmp.c        **** #define SPEAKER_1_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * SPEAKER_1_PAUSE_TIME * M
 238:irmp.c        **** #define SPEAKER_1_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * SPEAKER_1_PAUSE_TIME * M
 239:irmp.c        **** #define SPEAKER_0_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * SPEAKER_0_PULSE_TIME * M
 240:irmp.c        **** #define SPEAKER_0_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * SPEAKER_0_PULSE_TIME * M
 241:irmp.c        **** #define SPEAKER_0_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * SPEAKER_0_PAUSE_TIME * M
 242:irmp.c        **** #define SPEAKER_0_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * SPEAKER_0_PAUSE_TIME * M
 243:irmp.c        **** 
 244:irmp.c        **** #define BANG_OLUFSEN_START_BIT1_PULSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT1_P
 245:irmp.c        **** #define BANG_OLUFSEN_START_BIT1_PULSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT1_P
 246:irmp.c        **** #define BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT1_P
 247:irmp.c        **** #define BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT1_P
 248:irmp.c        **** #define BANG_OLUFSEN_START_BIT2_PULSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT2_P
 249:irmp.c        **** #define BANG_OLUFSEN_START_BIT2_PULSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT2_P
 250:irmp.c        **** #define BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT2_P
 251:irmp.c        **** #define BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT2_P
 252:irmp.c        **** #define BANG_OLUFSEN_START_BIT3_PULSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT3_P
 253:irmp.c        **** #define BANG_OLUFSEN_START_BIT3_PULSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT3_P
 254:irmp.c        **** #define BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT3_P
 255:irmp.c        **** #define BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MAX   ((PAUSE_LEN)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT3
 256:irmp.c        **** #define BANG_OLUFSEN_START_BIT4_PULSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT4_P
 257:irmp.c        **** #define BANG_OLUFSEN_START_BIT4_PULSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT4_P
 258:irmp.c        **** #define BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT4_P
 259:irmp.c        **** #define BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT4_P
 260:irmp.c        **** #define BANG_OLUFSEN_PULSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_PULSE_TIME *
 261:irmp.c        **** #define BANG_OLUFSEN_PULSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_PULSE_TIME *
 262:irmp.c        **** #define BANG_OLUFSEN_1_PAUSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_1_PAUSE_TIME
 263:irmp.c        **** #define BANG_OLUFSEN_1_PAUSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_1_PAUSE_TIME
 264:irmp.c        **** #define BANG_OLUFSEN_0_PAUSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_0_PAUSE_TIME
 265:irmp.c        **** #define BANG_OLUFSEN_0_PAUSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_0_PAUSE_TIME
 266:irmp.c        **** #define BANG_OLUFSEN_R_PAUSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_R_PAUSE_TIME
 267:irmp.c        **** #define BANG_OLUFSEN_R_PAUSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_R_PAUSE_TIME
 268:irmp.c        **** #define BANG_OLUFSEN_TRAILER_BIT_PAUSE_LEN_MIN  ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_TRAILER_BIT_
 269:irmp.c        **** #define BANG_OLUFSEN_TRAILER_BIT_PAUSE_LEN_MAX  ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_TRAILER_BIT_
 270:irmp.c        **** 
 271:irmp.c        **** #define IR60_TIMEOUT_LEN                        ((uint8_t)(F_INTERRUPTS * IR60_TIMEOUT_TIME * 0.5))
 272:irmp.c        **** #define GRUNDIG_NOKIA_IR60_START_BIT_LEN_MIN    ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_BIT_TI
 273:irmp.c        **** #define GRUNDIG_NOKIA_IR60_START_BIT_LEN_MAX    ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_BIT_TI
 274:irmp.c        **** #define GRUNDIG_NOKIA_IR60_BIT_LEN_MIN          ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_BIT_TI
 275:irmp.c        **** #define GRUNDIG_NOKIA_IR60_BIT_LEN_MAX          ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_BIT_TI
 276:irmp.c        **** #define GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MIN    ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_PRE_PA
 277:irmp.c        **** #define GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MAX    ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_PRE_PA
 278:irmp.c        **** 
 279:irmp.c        **** #define SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN       ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO
 280:irmp.c        **** #define SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX       ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO
 281:irmp.c        **** #define SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN       ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO
 282:irmp.c        **** #define SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX       ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO
 283:irmp.c        **** #define SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO
 284:irmp.c        **** #define SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO
 285:irmp.c        **** #define SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO
 286:irmp.c        **** #define SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO
 287:irmp.c        **** 
 288:irmp.c        **** #define FDC_START_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * FDC_START_BIT_PULSE_TIME 
 289:irmp.c        **** #define FDC_START_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * FDC_START_BIT_PULSE_TIME 
 290:irmp.c        **** #define FDC_START_BIT_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * FDC_START_BIT_PAUSE_TIME 
 291:irmp.c        **** #define FDC_START_BIT_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * FDC_START_BIT_PAUSE_TIME 
 292:irmp.c        **** #define FDC_PULSE_LEN_MIN                       ((uint8_t)(F_INTERRUPTS * FDC_PULSE_TIME * MIN_TOLE
 293:irmp.c        **** #define FDC_PULSE_LEN_MAX                       ((uint8_t)(F_INTERRUPTS * FDC_PULSE_TIME * MAX_TOLE
 294:irmp.c        **** #define FDC_1_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * FDC_1_PAUSE_TIME * MIN_TO
 295:irmp.c        **** #define FDC_1_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * FDC_1_PAUSE_TIME * MAX_TO
 296:irmp.c        **** #if 0
 297:irmp.c        **** #define FDC_0_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * FDC_0_PAUSE_TIME * MIN_TO
 298:irmp.c        **** #else
 299:irmp.c        **** #define FDC_0_PAUSE_LEN_MIN                     (1)                                                
 300:irmp.c        **** #endif
 301:irmp.c        **** #define FDC_0_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * FDC_0_PAUSE_TIME * MAX_TO
 302:irmp.c        **** 
 303:irmp.c        **** #define RCCAR_START_BIT_PULSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * RCCAR_START_BIT_PULSE_TIM
 304:irmp.c        **** #define RCCAR_START_BIT_PULSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * RCCAR_START_BIT_PULSE_TIM
 305:irmp.c        **** #define RCCAR_START_BIT_PAUSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * RCCAR_START_BIT_PAUSE_TIM
 306:irmp.c        **** #define RCCAR_START_BIT_PAUSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * RCCAR_START_BIT_PAUSE_TIM
 307:irmp.c        **** #define RCCAR_PULSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * RCCAR_PULSE_TIME * MIN_TO
 308:irmp.c        **** #define RCCAR_PULSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * RCCAR_PULSE_TIME * MAX_TO
 309:irmp.c        **** #define RCCAR_1_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RCCAR_1_PAUSE_TIME * MIN_
 310:irmp.c        **** #define RCCAR_1_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RCCAR_1_PAUSE_TIME * MAX_
 311:irmp.c        **** #define RCCAR_0_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RCCAR_0_PAUSE_TIME * MIN_
 312:irmp.c        **** #define RCCAR_0_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RCCAR_0_PAUSE_TIME * MAX_
 313:irmp.c        **** 
 314:irmp.c        **** #define JVC_START_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * JVC_START_BIT_PULSE_TIME 
 315:irmp.c        **** #define JVC_START_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * JVC_START_BIT_PULSE_TIME 
 316:irmp.c        **** #define JVC_REPEAT_START_BIT_PAUSE_LEN_MIN      ((uint8_t)(F_INTERRUPTS * (JVC_FRAME_REPEAT_PAUSE_T
 317:irmp.c        **** #define JVC_REPEAT_START_BIT_PAUSE_LEN_MAX      ((uint8_t)(F_INTERRUPTS * (JVC_FRAME_REPEAT_PAUSE_T
 318:irmp.c        **** #define JVC_PULSE_LEN_MIN                       ((uint8_t)(F_INTERRUPTS * JVC_PULSE_TIME * MIN_TOLE
 319:irmp.c        **** #define JVC_PULSE_LEN_MAX                       ((uint8_t)(F_INTERRUPTS * JVC_PULSE_TIME * MAX_TOLE
 320:irmp.c        **** #define JVC_1_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * JVC_1_PAUSE_TIME * MIN_TO
 321:irmp.c        **** #define JVC_1_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * JVC_1_PAUSE_TIME * MAX_TO
 322:irmp.c        **** #define JVC_0_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * JVC_0_PAUSE_TIME * MIN_TO
 323:irmp.c        **** #define JVC_0_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * JVC_0_PAUSE_TIME * MAX_TO
 324:irmp.c        **** // autodetect JVC repetition frame within 50 msec:
 325:irmp.c        **** #define JVC_FRAME_REPEAT_PAUSE_LEN_MAX          (uint16_t)(F_INTERRUPTS * JVC_FRAME_REPEAT_PAUSE_TI
 326:irmp.c        **** 
 327:irmp.c        **** #define NIKON_START_BIT_PULSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * NIKON_START_BIT_PULSE_TIM
 328:irmp.c        **** #define NIKON_START_BIT_PULSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * NIKON_START_BIT_PULSE_TIM
 329:irmp.c        **** #define NIKON_START_BIT_PAUSE_LEN_MIN           ((uint16_t)(F_INTERRUPTS * NIKON_START_BIT_PAUSE_TI
 330:irmp.c        **** #define NIKON_START_BIT_PAUSE_LEN_MAX           ((uint16_t)(F_INTERRUPTS * NIKON_START_BIT_PAUSE_TI
 331:irmp.c        **** #define NIKON_REPEAT_START_BIT_PAUSE_LEN_MIN    ((uint8_t)(F_INTERRUPTS * NIKON_REPEAT_START_BIT_PA
 332:irmp.c        **** #define NIKON_REPEAT_START_BIT_PAUSE_LEN_MAX    ((uint8_t)(F_INTERRUPTS * NIKON_REPEAT_START_BIT_PA
 333:irmp.c        **** #define NIKON_PULSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * NIKON_PULSE_TIME * MIN_TO
 334:irmp.c        **** #define NIKON_PULSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * NIKON_PULSE_TIME * MAX_TO
 335:irmp.c        **** #define NIKON_1_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * NIKON_1_PAUSE_TIME * MIN_
 336:irmp.c        **** #define NIKON_1_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * NIKON_1_PAUSE_TIME * MAX_
 337:irmp.c        **** #define NIKON_0_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * NIKON_0_PAUSE_TIME * MIN_
 338:irmp.c        **** #define NIKON_0_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * NIKON_0_PAUSE_TIME * MAX_
 339:irmp.c        **** #define NIKON_FRAME_REPEAT_PAUSE_LEN_MAX        (uint16_t)(F_INTERRUPTS * NIKON_FRAME_REPEAT_PAUSE_
 340:irmp.c        **** 
 341:irmp.c        **** #define KATHREIN_START_BIT_PULSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * KATHREIN_START_BIT_PULSE_
 342:irmp.c        **** #define KATHREIN_START_BIT_PULSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * KATHREIN_START_BIT_PULSE_
 343:irmp.c        **** #define KATHREIN_START_BIT_PAUSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * KATHREIN_START_BIT_PAUSE_
 344:irmp.c        **** #define KATHREIN_START_BIT_PAUSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * KATHREIN_START_BIT_PAUSE_
 345:irmp.c        **** #define KATHREIN_1_PULSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KATHREIN_1_PULSE_TIME * M
 346:irmp.c        **** #define KATHREIN_1_PULSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KATHREIN_1_PULSE_TIME * M
 347:irmp.c        **** #define KATHREIN_1_PAUSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KATHREIN_1_PAUSE_TIME * M
 348:irmp.c        **** #define KATHREIN_1_PAUSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KATHREIN_1_PAUSE_TIME * M
 349:irmp.c        **** #define KATHREIN_0_PULSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KATHREIN_0_PULSE_TIME * M
 350:irmp.c        **** #define KATHREIN_0_PULSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KATHREIN_0_PULSE_TIME * M
 351:irmp.c        **** #define KATHREIN_0_PAUSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KATHREIN_0_PAUSE_TIME * M
 352:irmp.c        **** #define KATHREIN_0_PAUSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KATHREIN_0_PAUSE_TIME * M
 353:irmp.c        **** #define KATHREIN_SYNC_BIT_PAUSE_LEN_MIN         ((uint8_t)(F_INTERRUPTS * KATHREIN_SYNC_BIT_PAUSE_L
 354:irmp.c        **** #define KATHREIN_SYNC_BIT_PAUSE_LEN_MAX         ((uint8_t)(F_INTERRUPTS * KATHREIN_SYNC_BIT_PAUSE_L
 355:irmp.c        **** 
 356:irmp.c        **** #define NETBOX_START_BIT_PULSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * NETBOX_START_BIT_PULSE_TI
 357:irmp.c        **** #define NETBOX_START_BIT_PULSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * NETBOX_START_BIT_PULSE_TI
 358:irmp.c        **** #define NETBOX_START_BIT_PAUSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * NETBOX_START_BIT_PAUSE_TI
 359:irmp.c        **** #define NETBOX_START_BIT_PAUSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * NETBOX_START_BIT_PAUSE_TI
 360:irmp.c        **** #define NETBOX_PULSE_LEN                        ((uint8_t)(F_INTERRUPTS * NETBOX_PULSE_TIME))
 361:irmp.c        **** #define NETBOX_PAUSE_LEN                        ((uint8_t)(F_INTERRUPTS * NETBOX_PAUSE_TIME))
 362:irmp.c        **** #define NETBOX_PULSE_REST_LEN                   ((uint8_t)(F_INTERRUPTS * NETBOX_PULSE_TIME / 4))
 363:irmp.c        **** #define NETBOX_PAUSE_REST_LEN                   ((uint8_t)(F_INTERRUPTS * NETBOX_PAUSE_TIME / 4))
 364:irmp.c        **** 
 365:irmp.c        **** #define LEGO_START_BIT_PULSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * LEGO_START_BIT_PULSE_TIME
 366:irmp.c        **** #define LEGO_START_BIT_PULSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * LEGO_START_BIT_PULSE_TIME
 367:irmp.c        **** #define LEGO_START_BIT_PAUSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * LEGO_START_BIT_PAUSE_TIME
 368:irmp.c        **** #define LEGO_START_BIT_PAUSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * LEGO_START_BIT_PAUSE_TIME
 369:irmp.c        **** #define LEGO_PULSE_LEN_MIN                      ((uint8_t)(F_INTERRUPTS * LEGO_PULSE_TIME * MIN_TOL
 370:irmp.c        **** #define LEGO_PULSE_LEN_MAX                      ((uint8_t)(F_INTERRUPTS * LEGO_PULSE_TIME * MAX_TOL
 371:irmp.c        **** #define LEGO_1_PAUSE_LEN_MIN                    ((uint8_t)(F_INTERRUPTS * LEGO_1_PAUSE_TIME * MIN_T
 372:irmp.c        **** #define LEGO_1_PAUSE_LEN_MAX                    ((uint8_t)(F_INTERRUPTS * LEGO_1_PAUSE_TIME * MAX_T
 373:irmp.c        **** #define LEGO_0_PAUSE_LEN_MIN                    ((uint8_t)(F_INTERRUPTS * LEGO_0_PAUSE_TIME * MIN_T
 374:irmp.c        **** #define LEGO_0_PAUSE_LEN_MAX                    ((uint8_t)(F_INTERRUPTS * LEGO_0_PAUSE_TIME * MAX_T
 375:irmp.c        **** 
 376:irmp.c        **** #define BOSE_START_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * BOSE_START_BIT_PULSE_TIM
 377:irmp.c        **** #define BOSE_START_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * BOSE_START_BIT_PULSE_TIM
 378:irmp.c        **** #define BOSE_START_BIT_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * BOSE_START_BIT_PAUSE_TIM
 379:irmp.c        **** #define BOSE_START_BIT_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * BOSE_START_BIT_PAUSE_TIM
 380:irmp.c        **** #define BOSE_PULSE_LEN_MIN                       ((uint8_t)(F_INTERRUPTS * BOSE_PULSE_TIME * MIN_TO
 381:irmp.c        **** #define BOSE_PULSE_LEN_MAX                       ((uint8_t)(F_INTERRUPTS * BOSE_PULSE_TIME * MAX_TO
 382:irmp.c        **** #define BOSE_1_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * BOSE_1_PAUSE_TIME * MIN_
 383:irmp.c        **** #define BOSE_1_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * BOSE_1_PAUSE_TIME * MAX_
 384:irmp.c        **** #define BOSE_0_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * BOSE_0_PAUSE_TIME * MIN_
 385:irmp.c        **** #define BOSE_0_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * BOSE_0_PAUSE_TIME * MAX_
 386:irmp.c        **** #define BOSE_FRAME_REPEAT_PAUSE_LEN_MAX          (uint16_t)(F_INTERRUPTS * 100.0e-3 * MAX_TOLERANCE
 387:irmp.c        **** 
 388:irmp.c        **** #define A1TVBOX_START_BIT_PULSE_LEN_MIN         ((uint8_t)(F_INTERRUPTS * A1TVBOX_START_BIT_PULSE_T
 389:irmp.c        **** #define A1TVBOX_START_BIT_PULSE_LEN_MAX         ((uint8_t)(F_INTERRUPTS * A1TVBOX_START_BIT_PULSE_T
 390:irmp.c        **** #define A1TVBOX_START_BIT_PAUSE_LEN_MIN         ((uint8_t)(F_INTERRUPTS * A1TVBOX_START_BIT_PAUSE_T
 391:irmp.c        **** #define A1TVBOX_START_BIT_PAUSE_LEN_MAX         ((uint8_t)(F_INTERRUPTS * A1TVBOX_START_BIT_PAUSE_T
 392:irmp.c        **** #define A1TVBOX_BIT_PULSE_LEN_MIN               ((uint8_t)(F_INTERRUPTS * A1TVBOX_BIT_PULSE_TIME * 
 393:irmp.c        **** #define A1TVBOX_BIT_PULSE_LEN_MAX               ((uint8_t)(F_INTERRUPTS * A1TVBOX_BIT_PULSE_TIME * 
 394:irmp.c        **** #define A1TVBOX_BIT_PAUSE_LEN_MIN               ((uint8_t)(F_INTERRUPTS * A1TVBOX_BIT_PAUSE_TIME * 
 395:irmp.c        **** #define A1TVBOX_BIT_PAUSE_LEN_MAX               ((uint8_t)(F_INTERRUPTS * A1TVBOX_BIT_PAUSE_TIME * 
 396:irmp.c        **** 
 397:irmp.c        **** #define ORTEK_START_BIT_PULSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * ORTEK_START_BIT_PULSE_TIM
 398:irmp.c        **** #define ORTEK_START_BIT_PULSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * ORTEK_START_BIT_PULSE_TIM
 399:irmp.c        **** #define ORTEK_START_BIT_PAUSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * ORTEK_START_BIT_PAUSE_TIM
 400:irmp.c        **** #define ORTEK_START_BIT_PAUSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * ORTEK_START_BIT_PAUSE_TIM
 401:irmp.c        **** #define ORTEK_BIT_PULSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * ORTEK_BIT_TIME * MIN_TOLE
 402:irmp.c        **** #define ORTEK_BIT_PULSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * ORTEK_BIT_TIME * MAX_TOLE
 403:irmp.c        **** #define ORTEK_BIT_PAUSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * ORTEK_BIT_TIME * MIN_TOLE
 404:irmp.c        **** #define ORTEK_BIT_PAUSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * ORTEK_BIT_TIME * MAX_TOLE
 405:irmp.c        **** 
 406:irmp.c        **** #define TELEFUNKEN_START_BIT_PULSE_LEN_MIN      ((uint8_t)(F_INTERRUPTS * TELEFUNKEN_START_BIT_PULS
 407:irmp.c        **** #define TELEFUNKEN_START_BIT_PULSE_LEN_MAX      ((uint8_t)(F_INTERRUPTS * TELEFUNKEN_START_BIT_PULS
 408:irmp.c        **** #define TELEFUNKEN_START_BIT_PAUSE_LEN_MIN      ((uint8_t)(F_INTERRUPTS * (TELEFUNKEN_START_BIT_PAU
 409:irmp.c        **** #define TELEFUNKEN_START_BIT_PAUSE_LEN_MAX      ((uint8_t)(F_INTERRUPTS * (TELEFUNKEN_START_BIT_PAU
 410:irmp.c        **** #define TELEFUNKEN_PULSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * TELEFUNKEN_PULSE_TIME * M
 411:irmp.c        **** #define TELEFUNKEN_PULSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * TELEFUNKEN_PULSE_TIME * M
 412:irmp.c        **** #define TELEFUNKEN_1_PAUSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * TELEFUNKEN_1_PAUSE_TIME *
 413:irmp.c        **** #define TELEFUNKEN_1_PAUSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * TELEFUNKEN_1_PAUSE_TIME *
 414:irmp.c        **** #define TELEFUNKEN_0_PAUSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * TELEFUNKEN_0_PAUSE_TIME *
 415:irmp.c        **** #define TELEFUNKEN_0_PAUSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * TELEFUNKEN_0_PAUSE_TIME *
 416:irmp.c        **** // autodetect TELEFUNKEN repetition frame within 50 msec:
 417:irmp.c        **** // #define TELEFUNKEN_FRAME_REPEAT_PAUSE_LEN_MAX   (uint16_t)(F_INTERRUPTS * TELEFUNKEN_FRAME_REPEA
 418:irmp.c        **** 
 419:irmp.c        **** #define ROOMBA_START_BIT_PULSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * ROOMBA_START_BIT_PULSE_TI
 420:irmp.c        **** #define ROOMBA_START_BIT_PULSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * ROOMBA_START_BIT_PULSE_TI
 421:irmp.c        **** #define ROOMBA_START_BIT_PAUSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * ROOMBA_START_BIT_PAUSE_TI
 422:irmp.c        **** #define ROOMBA_START_BIT_PAUSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * ROOMBA_START_BIT_PAUSE_TI
 423:irmp.c        **** #define ROOMBA_1_PAUSE_LEN_EXACT                ((uint8_t)(F_INTERRUPTS * ROOMBA_1_PAUSE_TIME + 0.5
 424:irmp.c        **** #define ROOMBA_1_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * ROOMBA_1_PULSE_TIME * MIN
 425:irmp.c        **** #define ROOMBA_1_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * ROOMBA_1_PULSE_TIME * MAX
 426:irmp.c        **** #define ROOMBA_1_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * ROOMBA_1_PAUSE_TIME * MIN
 427:irmp.c        **** #define ROOMBA_1_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * ROOMBA_1_PAUSE_TIME * MAX
 428:irmp.c        **** #define ROOMBA_0_PAUSE_LEN                      ((uint8_t)(F_INTERRUPTS * ROOMBA_0_PAUSE_TIME))
 429:irmp.c        **** #define ROOMBA_0_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * ROOMBA_0_PULSE_TIME * MIN
 430:irmp.c        **** #define ROOMBA_0_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * ROOMBA_0_PULSE_TIME * MAX
 431:irmp.c        **** #define ROOMBA_0_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * ROOMBA_0_PAUSE_TIME * MIN
 432:irmp.c        **** #define ROOMBA_0_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * ROOMBA_0_PAUSE_TIME * MAX
 433:irmp.c        **** 
 434:irmp.c        **** #define RCMM32_START_BIT_PULSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * RCMM32_START_BIT_PULSE_TI
 435:irmp.c        **** #define RCMM32_START_BIT_PULSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * RCMM32_START_BIT_PULSE_TI
 436:irmp.c        **** #define RCMM32_START_BIT_PAUSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * RCMM32_START_BIT_PAUSE_TI
 437:irmp.c        **** #define RCMM32_START_BIT_PAUSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * RCMM32_START_BIT_PAUSE_TI
 438:irmp.c        **** #define RCMM32_BIT_PULSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * RCMM32_PULSE_TIME * MIN_T
 439:irmp.c        **** #define RCMM32_BIT_PULSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * RCMM32_PULSE_TIME * MAX_T
 440:irmp.c        **** #define RCMM32_BIT_00_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * RCMM32_00_PAUSE_TIME * MI
 441:irmp.c        **** #define RCMM32_BIT_00_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * RCMM32_00_PAUSE_TIME * MA
 442:irmp.c        **** #define RCMM32_BIT_01_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * RCMM32_01_PAUSE_TIME * MI
 443:irmp.c        **** #define RCMM32_BIT_01_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * RCMM32_01_PAUSE_TIME * MA
 444:irmp.c        **** #define RCMM32_BIT_10_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * RCMM32_10_PAUSE_TIME * MI
 445:irmp.c        **** #define RCMM32_BIT_10_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * RCMM32_10_PAUSE_TIME * MA
 446:irmp.c        **** #define RCMM32_BIT_11_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * RCMM32_11_PAUSE_TIME * MI
 447:irmp.c        **** #define RCMM32_BIT_11_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * RCMM32_11_PAUSE_TIME * MA
 448:irmp.c        **** 
 449:irmp.c        **** #define RADIO1_START_BIT_PULSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * RADIO1_START_BIT_PULSE_TI
 450:irmp.c        **** #define RADIO1_START_BIT_PULSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * RADIO1_START_BIT_PULSE_TI
 451:irmp.c        **** #define RADIO1_START_BIT_PAUSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * RADIO1_START_BIT_PAUSE_TI
 452:irmp.c        **** #define RADIO1_START_BIT_PAUSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * RADIO1_START_BIT_PAUSE_TI
 453:irmp.c        **** #define RADIO1_1_PAUSE_LEN_EXACT                ((uint8_t)(F_INTERRUPTS * RADIO1_1_PAUSE_TIME + 0.5
 454:irmp.c        **** #define RADIO1_1_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * RADIO1_1_PULSE_TIME * MIN
 455:irmp.c        **** #define RADIO1_1_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * RADIO1_1_PULSE_TIME * MAX
 456:irmp.c        **** #define RADIO1_1_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * RADIO1_1_PAUSE_TIME * MIN
 457:irmp.c        **** #define RADIO1_1_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * RADIO1_1_PAUSE_TIME * MAX
 458:irmp.c        **** #define RADIO1_0_PAUSE_LEN                      ((uint8_t)(F_INTERRUPTS * RADIO1_0_PAUSE_TIME))
 459:irmp.c        **** #define RADIO1_0_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * RADIO1_0_PULSE_TIME * MIN
 460:irmp.c        **** #define RADIO1_0_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * RADIO1_0_PULSE_TIME * MAX
 461:irmp.c        **** #define RADIO1_0_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * RADIO1_0_PAUSE_TIME * MIN
 462:irmp.c        **** #define RADIO1_0_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * RADIO1_0_PAUSE_TIME * MAX
 463:irmp.c        **** 
 464:irmp.c        **** #define AUTO_FRAME_REPETITION_LEN               (uint16_t)(F_INTERRUPTS * AUTO_FRAME_REPETITION_TIM
 465:irmp.c        **** 
 466:irmp.c        **** #ifdef ANALYZE
 467:irmp.c        **** #  define ANALYZE_PUTCHAR(a)                    { if (! silent)             { putchar (a);         
 468:irmp.c        **** #  define ANALYZE_ONLY_NORMAL_PUTCHAR(a)        { if (! silent && !verbose) { putchar (a);         
 469:irmp.c        **** #  define ANALYZE_PRINTF(...)                   { if (verbose)              { printf (__VA_ARGS__);
 470:irmp.c        **** #  define ANALYZE_ONLY_NORMAL_PRINTF(...)       { if (! silent && !verbose) { printf (__VA_ARGS__);
 471:irmp.c        **** #  define ANALYZE_NEWLINE()                     { if (verbose)              { putchar ('\n');      
 472:irmp.c        **** static int                                      silent;
 473:irmp.c        **** static int                                      time_counter;
 474:irmp.c        **** static int                                      verbose;
 475:irmp.c        **** 
 476:irmp.c        **** /*******************************                not every PIC compiler knows variadic macros :-(
 477:irmp.c        **** #else
 478:irmp.c        **** #  define ANALYZE_PUTCHAR(a)
 479:irmp.c        **** #  define ANALYZE_ONLY_NORMAL_PUTCHAR(a)
 480:irmp.c        **** #  define ANALYZE_PRINTF(...)
 481:irmp.c        **** #  define ANALYZE_ONLY_NORMAL_PRINTF(...)
 482:irmp.c        **** #  endif
 483:irmp.c        **** #  define ANALYZE_NEWLINE()
 484:irmp.c        **** *********************************/
 485:irmp.c        **** #endif
 486:irmp.c        **** 
 487:irmp.c        **** #if IRMP_USE_CALLBACK == 1
 488:irmp.c        **** static void                                     (*irmp_callback_ptr) (uint8_t);
 489:irmp.c        **** #endif // IRMP_USE_CALLBACK == 1
 490:irmp.c        **** 
 491:irmp.c        **** #define PARITY_CHECK_OK                         1
 492:irmp.c        **** #define PARITY_CHECK_FAILED                     0
 493:irmp.c        **** 
 494:irmp.c        **** /*-------------------------------------------------------------------------------------------------
 495:irmp.c        ****  *  Protocol names
 496:irmp.c        ****  *-------------------------------------------------------------------------------------------------
 497:irmp.c        ****  */
 498:irmp.c        **** #if defined(UNIX_OR_WINDOWS) || IRMP_PROTOCOL_NAMES == 1
 499:irmp.c        **** static const char proto_unknown[]       PROGMEM = "UNKNOWN";
 500:irmp.c        **** static const char proto_sircs[]         PROGMEM = "SIRCS";
 501:irmp.c        **** static const char proto_nec[]           PROGMEM = "NEC";
 502:irmp.c        **** static const char proto_samsung[]       PROGMEM = "SAMSUNG";
 503:irmp.c        **** static const char proto_matsushita[]    PROGMEM = "MATSUSH";
 504:irmp.c        **** static const char proto_kaseikyo[]      PROGMEM = "KASEIKYO";
 505:irmp.c        **** static const char proto_recs80[]        PROGMEM = "RECS80";
 506:irmp.c        **** static const char proto_rc5[]           PROGMEM = "RC5";
 507:irmp.c        **** static const char proto_denon[]         PROGMEM = "DENON";
 508:irmp.c        **** static const char proto_rc6[]           PROGMEM = "RC6";
 509:irmp.c        **** static const char proto_samsung32[]     PROGMEM = "SAMSG32";
 510:irmp.c        **** static const char proto_apple[]         PROGMEM = "APPLE";
 511:irmp.c        **** static const char proto_recs80ext[]     PROGMEM = "RECS80EX";
 512:irmp.c        **** static const char proto_nubert[]        PROGMEM = "NUBERT";
 513:irmp.c        **** static const char proto_bang_olufsen[]  PROGMEM = "BANG OLU";
 514:irmp.c        **** static const char proto_grundig[]       PROGMEM = "GRUNDIG";
 515:irmp.c        **** static const char proto_nokia[]         PROGMEM = "NOKIA";
 516:irmp.c        **** static const char proto_siemens[]       PROGMEM = "SIEMENS";
 517:irmp.c        **** static const char proto_fdc[]           PROGMEM = "FDC";
 518:irmp.c        **** static const char proto_rccar[]         PROGMEM = "RCCAR";
 519:irmp.c        **** static const char proto_jvc[]           PROGMEM = "JVC";
 520:irmp.c        **** static const char proto_rc6a[]          PROGMEM = "RC6A";
 521:irmp.c        **** static const char proto_nikon[]         PROGMEM = "NIKON";
 522:irmp.c        **** static const char proto_ruwido[]        PROGMEM = "RUWIDO";
 523:irmp.c        **** static const char proto_ir60[]          PROGMEM = "IR60";
 524:irmp.c        **** static const char proto_kathrein[]      PROGMEM = "KATHREIN";
 525:irmp.c        **** static const char proto_netbox[]        PROGMEM = "NETBOX";
 526:irmp.c        **** static const char proto_nec16[]         PROGMEM = "NEC16";
 527:irmp.c        **** static const char proto_nec42[]         PROGMEM = "NEC42";
 528:irmp.c        **** static const char proto_lego[]          PROGMEM = "LEGO";
 529:irmp.c        **** static const char proto_thomson[]       PROGMEM = "THOMSON";
 530:irmp.c        **** static const char proto_bose[]          PROGMEM = "BOSE";
 531:irmp.c        **** static const char proto_a1tvbox[]       PROGMEM = "A1TVBOX";
 532:irmp.c        **** static const char proto_ortek[]         PROGMEM = "ORTEK";
 533:irmp.c        **** static const char proto_telefunken[]    PROGMEM = "TELEFUNKEN";
 534:irmp.c        **** static const char proto_roomba[]        PROGMEM = "ROOMBA";
 535:irmp.c        **** static const char proto_rcmm32[]        PROGMEM = "RCMM32";
 536:irmp.c        **** static const char proto_rcmm24[]        PROGMEM = "RCMM24";
 537:irmp.c        **** static const char proto_rcmm12[]        PROGMEM = "RCMM12";
 538:irmp.c        **** static const char proto_speaker[]       PROGMEM = "SPEAKER";
 539:irmp.c        **** static const char proto_lgair[]         PROGMEM = "LGAIR";
 540:irmp.c        **** static const char proto_samsung48[]     PROGMEM = "SAMSG48";
 541:irmp.c        **** 
 542:irmp.c        **** static const char proto_radio1[]        PROGMEM = "RADIO1";
 543:irmp.c        **** 
 544:irmp.c        **** const char * const
 545:irmp.c        **** irmp_protocol_names[IRMP_N_PROTOCOLS + 1] PROGMEM =
 546:irmp.c        **** {
 547:irmp.c        ****     proto_unknown,
 548:irmp.c        ****     proto_sircs,
 549:irmp.c        ****     proto_nec,
 550:irmp.c        ****     proto_samsung,
 551:irmp.c        ****     proto_matsushita,
 552:irmp.c        ****     proto_kaseikyo,
 553:irmp.c        ****     proto_recs80,
 554:irmp.c        ****     proto_rc5,
 555:irmp.c        ****     proto_denon,
 556:irmp.c        ****     proto_rc6,
 557:irmp.c        ****     proto_samsung32,
 558:irmp.c        ****     proto_apple,
 559:irmp.c        ****     proto_recs80ext,
 560:irmp.c        ****     proto_nubert,
 561:irmp.c        ****     proto_bang_olufsen,
 562:irmp.c        ****     proto_grundig,
 563:irmp.c        ****     proto_nokia,
 564:irmp.c        ****     proto_siemens,
 565:irmp.c        ****     proto_fdc,
 566:irmp.c        ****     proto_rccar,
 567:irmp.c        ****     proto_jvc,
 568:irmp.c        ****     proto_rc6a,
 569:irmp.c        ****     proto_nikon,
 570:irmp.c        ****     proto_ruwido,
 571:irmp.c        ****     proto_ir60,
 572:irmp.c        ****     proto_kathrein,
 573:irmp.c        ****     proto_netbox,
 574:irmp.c        ****     proto_nec16,
 575:irmp.c        ****     proto_nec42,
 576:irmp.c        ****     proto_lego,
 577:irmp.c        ****     proto_thomson,
 578:irmp.c        ****     proto_bose,
 579:irmp.c        ****     proto_a1tvbox,
 580:irmp.c        ****     proto_ortek,
 581:irmp.c        ****     proto_telefunken,
 582:irmp.c        ****     proto_roomba,
 583:irmp.c        ****     proto_rcmm32,
 584:irmp.c        ****     proto_rcmm24,
 585:irmp.c        ****     proto_rcmm12,
 586:irmp.c        ****     proto_speaker,
 587:irmp.c        ****     proto_lgair,
 588:irmp.c        ****     proto_samsung48,
 589:irmp.c        **** 
 590:irmp.c        ****     proto_radio1
 591:irmp.c        **** };
 592:irmp.c        **** 
 593:irmp.c        **** #endif
 594:irmp.c        **** 
 595:irmp.c        **** /*-------------------------------------------------------------------------------------------------
 596:irmp.c        ****  *  Logging
 597:irmp.c        ****  *-------------------------------------------------------------------------------------------------
 598:irmp.c        ****  */
 599:irmp.c        **** #if IRMP_LOGGING == 1                                                   // logging via UART
 600:irmp.c        **** 
 601:irmp.c        **** #if defined(ARM_STM32F4XX)
 602:irmp.c        **** #  define  STM32_GPIO_CLOCK   RCC_AHB1Periph_GPIOA                      // UART2 on PA2
 603:irmp.c        **** #  define  STM32_UART_CLOCK   RCC_APB1Periph_USART2
 604:irmp.c        **** #  define  STM32_GPIO_PORT    GPIOA
 605:irmp.c        **** #  define  STM32_GPIO_PIN     GPIO_Pin_2
 606:irmp.c        **** #  define  STM32_GPIO_SOURCE  GPIO_PinSource2
 607:irmp.c        **** #  define  STM32_UART_AF      GPIO_AF_USART2
 608:irmp.c        **** #  define  STM32_UART_COM     USART2
 609:irmp.c        **** #  define  STM32_UART_BAUD    115200                                    // 115200 Baud
 610:irmp.c        **** #  include "stm32f4xx_usart.h"
 611:irmp.c        **** #elif defined(ARM_STM32F10X)
 612:irmp.c        **** #  define  STM32_UART_COM     USART3                                    // UART3 on PB10
 613:irmp.c        **** #  include "stm32f10x_usart.h"
 614:irmp.c        **** #else
 615:irmp.c        **** #  if IRMP_EXT_LOGGING == 1                                             // use external logging
 616:irmp.c        **** #    include "irmpextlog.h"
 617:irmp.c        **** #  else                                                                 // normal UART log (IRMP_EX
 618:irmp.c        **** #    define BAUD                                    9600L
 619:irmp.c        **** #  ifndef UNIX_OR_WINDOWS
 620:irmp.c        **** #    include <util/setbaud.h>
 621:irmp.c        **** #  endif
 622:irmp.c        **** 
 623:irmp.c        **** #ifdef UBRR0H
 624:irmp.c        **** 
 625:irmp.c        **** #define UART0_UBRRH                             UBRR0H
 626:irmp.c        **** #define UART0_UBRRL                             UBRR0L
 627:irmp.c        **** #define UART0_UCSRA                             UCSR0A
 628:irmp.c        **** #define UART0_UCSRB                             UCSR0B
 629:irmp.c        **** #define UART0_UCSRC                             UCSR0C
 630:irmp.c        **** #define UART0_UDRE_BIT_VALUE                    (1<<UDRE0)
 631:irmp.c        **** #define UART0_UCSZ1_BIT_VALUE                   (1<<UCSZ01)
 632:irmp.c        **** #define UART0_UCSZ0_BIT_VALUE                   (1<<UCSZ00)
 633:irmp.c        **** #ifdef URSEL0
 634:irmp.c        **** #define UART0_URSEL_BIT_VALUE                   (1<<URSEL0)
 635:irmp.c        **** #else
 636:irmp.c        **** #define UART0_URSEL_BIT_VALUE                   (0)
 637:irmp.c        **** #endif
 638:irmp.c        **** #define UART0_TXEN_BIT_VALUE                    (1<<TXEN0)
 639:irmp.c        **** #define UART0_UDR                               UDR0
 640:irmp.c        **** #define UART0_U2X                               U2X0
 641:irmp.c        ****         
 642:irmp.c        **** #else
 643:irmp.c        **** 
 644:irmp.c        **** #define UART0_UBRRH                             UBRRH
 645:irmp.c        **** #define UART0_UBRRL                             UBRRL
 646:irmp.c        **** #define UART0_UCSRA                             UCSRA
 647:irmp.c        **** #define UART0_UCSRB                             UCSRB
 648:irmp.c        **** #define UART0_UCSRC                             UCSRC
 649:irmp.c        **** #define UART0_UDRE_BIT_VALUE                    (1<<UDRE)
 650:irmp.c        **** #define UART0_UCSZ1_BIT_VALUE                   (1<<UCSZ1)
 651:irmp.c        **** #define UART0_UCSZ0_BIT_VALUE                   (1<<UCSZ0)
 652:irmp.c        **** #ifdef URSEL
 653:irmp.c        **** #define UART0_URSEL_BIT_VALUE                   (1<<URSEL)
 654:irmp.c        **** #else
 655:irmp.c        **** #define UART0_URSEL_BIT_VALUE                   (0)
 656:irmp.c        **** #endif
 657:irmp.c        **** #define UART0_TXEN_BIT_VALUE                    (1<<TXEN)
 658:irmp.c        **** #define UART0_UDR                               UDR
 659:irmp.c        **** #define UART0_U2X                               U2X
 660:irmp.c        **** 
 661:irmp.c        **** #endif //UBRR0H
 662:irmp.c        **** #endif //IRMP_EXT_LOGGING
 663:irmp.c        **** #endif //ARM_STM32F4XX
 664:irmp.c        **** 
 665:irmp.c        **** /*-------------------------------------------------------------------------------------------------
 666:irmp.c        ****  *  Initialize  UART
 667:irmp.c        ****  *  @details  Initializes UART
 668:irmp.c        ****  *-------------------------------------------------------------------------------------------------
 669:irmp.c        ****  */
 670:irmp.c        **** void
 671:irmp.c        **** irmp_uart_init (void)
 672:irmp.c        **** {
 673:irmp.c        **** #ifndef UNIX_OR_WINDOWS
 674:irmp.c        **** #if defined(ARM_STM32F4XX)
 675:irmp.c        ****     GPIO_InitTypeDef GPIO_InitStructure;
 676:irmp.c        ****     USART_InitTypeDef USART_InitStructure;
 677:irmp.c        **** 
 678:irmp.c        ****     // Clock enable vom TX Pin
 679:irmp.c        ****     RCC_AHB1PeriphClockCmd(STM32_GPIO_CLOCK, ENABLE);
 680:irmp.c        **** 
 681:irmp.c        ****     // Clock enable der UART
 682:irmp.c        ****     RCC_APB1PeriphClockCmd(STM32_UART_CLOCK, ENABLE);
 683:irmp.c        **** 
 684:irmp.c        ****     // UART Alternative-Funktion mit dem IO-Pin verbinden
 685:irmp.c        ****     GPIO_PinAFConfig(STM32_GPIO_PORT,STM32_GPIO_SOURCE,STM32_UART_AF);
 686:irmp.c        **** 
 687:irmp.c        ****     // UART als Alternative-Funktion mit PushPull
 688:irmp.c        ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 689:irmp.c        ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 690:irmp.c        ****     GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 691:irmp.c        ****     GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 692:irmp.c        **** 
 693:irmp.c        ****     // TX-Pin
 694:irmp.c        ****     GPIO_InitStructure.GPIO_Pin = STM32_GPIO_PIN;
 695:irmp.c        ****     GPIO_Init(STM32_GPIO_PORT, &GPIO_InitStructure);
 696:irmp.c        **** 
 697:irmp.c        ****     // Oversampling
 698:irmp.c        ****     USART_OverSampling8Cmd(STM32_UART_COM, ENABLE);
 699:irmp.c        **** 
 700:irmp.c        ****     // init mit Baudrate, 8Databits, 1Stopbit, keine Paritt, kein RTS+CTS
 701:irmp.c        ****     USART_InitStructure.USART_BaudRate = STM32_UART_BAUD;
 702:irmp.c        ****     USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 703:irmp.c        ****     USART_InitStructure.USART_StopBits = USART_StopBits_1;
 704:irmp.c        ****     USART_InitStructure.USART_Parity = USART_Parity_No;
 705:irmp.c        ****     USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 706:irmp.c        ****     USART_InitStructure.USART_Mode = USART_Mode_Tx;
 707:irmp.c        ****     USART_Init(STM32_UART_COM, &USART_InitStructure);
 708:irmp.c        **** 
 709:irmp.c        ****     // UART enable
 710:irmp.c        ****     USART_Cmd(STM32_UART_COM, ENABLE);
 711:irmp.c        **** 
 712:irmp.c        **** #elif defined(ARM_STM32F10X)
 713:irmp.c        ****     GPIO_InitTypeDef GPIO_InitStructure;
 714:irmp.c        ****     USART_InitTypeDef USART_InitStructure;
 715:irmp.c        **** 
 716:irmp.c        ****     // Clock enable vom TX Pin
 717:irmp.c        ****     RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // UART3 an PB10
 718:irmp.c        **** 
 719:irmp.c        ****     // Clock enable der UART
 720:irmp.c        ****     RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
 721:irmp.c        **** 
 722:irmp.c        ****     // UART als Alternative-Funktion mit PushPull
 723:irmp.c        ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 724:irmp.c        ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 725:irmp.c        **** 
 726:irmp.c        ****     // TX-Pin
 727:irmp.c        ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 728:irmp.c        ****     GPIO_Init(GPIOB, &GPIO_InitStructure);
 729:irmp.c        **** 
 730:irmp.c        ****     // Oversampling
 731:irmp.c        ****     USART_OverSampling8Cmd(STM32_UART_COM, ENABLE);
 732:irmp.c        **** 
 733:irmp.c        ****     // init mit Baudrate, 8Databits, 1Stopbit, keine Paritt, kein RTS+CTS
 734:irmp.c        ****     USART_InitStructure.USART_BaudRate = 115200;
 735:irmp.c        ****     USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 736:irmp.c        ****     USART_InitStructure.USART_StopBits = USART_StopBits_1;
 737:irmp.c        ****     USART_InitStructure.USART_Parity = USART_Parity_No;
 738:irmp.c        ****     USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 739:irmp.c        ****     USART_InitStructure.USART_Mode = USART_Mode_Tx;
 740:irmp.c        ****     USART_Init(STM32_UART_COM, &USART_InitStructure);
 741:irmp.c        **** 
 742:irmp.c        ****     // UART enable
 743:irmp.c        ****     USART_Cmd(STM32_UART_COM, ENABLE);
 744:irmp.c        **** #else
 745:irmp.c        **** 
 746:irmp.c        **** #if (IRMP_EXT_LOGGING == 0)                                                                        
 747:irmp.c        ****     UART0_UBRRH = UBRRH_VALUE;                                                                     
 748:irmp.c        ****     UART0_UBRRL = UBRRL_VALUE;
 749:irmp.c        **** 
 750:irmp.c        **** #if USE_2X
 751:irmp.c        ****     UART0_UCSRA |= (1<<UART0_U2X);
 752:irmp.c        **** #else
 753:irmp.c        ****     UART0_UCSRA &= ~(1<<UART0_U2X);
 754:irmp.c        **** #endif
 755:irmp.c        **** 
 756:irmp.c        ****     UART0_UCSRC = UART0_UCSZ1_BIT_VALUE | UART0_UCSZ0_BIT_VALUE | UART0_URSEL_BIT_VALUE;
 757:irmp.c        ****     UART0_UCSRB |= UART0_TXEN_BIT_VALUE;                                                           
 758:irmp.c        **** #else                                                                                              
 759:irmp.c        ****     initextlog();                                                         
 760:irmp.c        **** #endif //IRMP_EXT_LOGGING
 761:irmp.c        **** #endif //ARM_STM32F4XX
 762:irmp.c        **** #endif // UNIX_OR_WINDOWS
 763:irmp.c        **** }
 764:irmp.c        **** 
 765:irmp.c        **** /*-------------------------------------------------------------------------------------------------
 766:irmp.c        ****  *  Send character
 767:irmp.c        ****  *  @details  Sends character
 768:irmp.c        ****  *  @param    ch character to be transmitted
 769:irmp.c        ****  *-------------------------------------------------------------------------------------------------
 770:irmp.c        ****  */
 771:irmp.c        **** void
 772:irmp.c        **** irmp_uart_putc (unsigned char ch)
 773:irmp.c        **** {
 774:irmp.c        **** #ifndef UNIX_OR_WINDOWS
 775:irmp.c        **** #if defined(ARM_STM32F4XX) || defined(ARM_STM32F10X)
 776:irmp.c        ****     // warten bis altes Byte gesendet wurde
 777:irmp.c        ****     while (USART_GetFlagStatus(STM32_UART_COM, USART_FLAG_TXE) == RESET)
 778:irmp.c        ****     {
 779:irmp.c        ****         ;
 780:irmp.c        ****     }
 781:irmp.c        **** 
 782:irmp.c        ****     USART_SendData(STM32_UART_COM, ch);
 783:irmp.c        **** 
 784:irmp.c        ****     if (ch == '\n')
 785:irmp.c        ****     {
 786:irmp.c        ****         while (USART_GetFlagStatus(STM32_UART_COM, USART_FLAG_TXE) == RESET);
 787:irmp.c        ****         USART_SendData(STM32_UART_COM, '\r');
 788:irmp.c        ****     }
 789:irmp.c        **** 
 790:irmp.c        **** #else
 791:irmp.c        **** #if (IRMP_EXT_LOGGING == 0)
 792:irmp.c        **** 
 793:irmp.c        ****     while (!(UART0_UCSRA & UART0_UDRE_BIT_VALUE))
 794:irmp.c        ****     {
 795:irmp.c        ****         ;
 796:irmp.c        ****     }
 797:irmp.c        **** 
 798:irmp.c        ****     UART0_UDR = ch;
 799:irmp.c        **** 
 800:irmp.c        **** #else
 801:irmp.c        **** 
 802:irmp.c        ****     sendextlog(ch);                                                         // use external log
 803:irmp.c        **** 
 804:irmp.c        **** #endif //IRMP_EXT_LOGGING
 805:irmp.c        **** #endif //ARM_STM32F4XX
 806:irmp.c        **** #else
 807:irmp.c        ****     fputc (ch, stderr);
 808:irmp.c        **** #endif // UNIX_OR_WINDOWS
 809:irmp.c        **** }
 810:irmp.c        **** 
 811:irmp.c        **** /*-------------------------------------------------------------------------------------------------
 812:irmp.c        ****  *  Log IR signal
 813:irmp.c        ****  *-------------------------------------------------------------------------------------------------
 814:irmp.c        ****  */
 815:irmp.c        **** 
 816:irmp.c        **** #define STARTCYCLES                       2                                 // min count of zeros b
 817:irmp.c        **** #define ENDBITS                        1000                                 // number of sequenced 
 818:irmp.c        **** #define DATALEN                         700                                 // log buffer size
 819:irmp.c        **** 
 820:irmp.c        **** static void
 821:irmp.c        **** irmp_log (uint8_t val)
 822:irmp.c        **** {
 823:irmp.c        ****     static uint8_t  buf[DATALEN];                                           // logging buffer
 824:irmp.c        ****     static uint16_t buf_idx;                                                // index
 825:irmp.c        ****     static uint8_t  startcycles;                                            // current number of st
 826:irmp.c        ****     static uint16_t cnt;                                                    // counts sequenced hig
 827:irmp.c        ****     static uint8_t  last_val = 1;
 828:irmp.c        **** 
 829:irmp.c        ****     if (! val && (startcycles < STARTCYCLES) && !buf_idx)                   // prevent that single 
 830:irmp.c        ****     {
 831:irmp.c        ****         startcycles++;
 832:irmp.c        ****     }
 833:irmp.c        ****     else
 834:irmp.c        ****     {
 835:irmp.c        ****         startcycles = 0;
 836:irmp.c        **** 
 837:irmp.c        ****         if (! val || buf_idx != 0)                                          // start or continue lo
 838:irmp.c        ****         {
 839:irmp.c        ****             if (last_val == val)
 840:irmp.c        ****             {
 841:irmp.c        ****                 cnt++;
 842:irmp.c        **** 
 843:irmp.c        ****                 if (val && cnt > ENDBITS)                                   // if high received the
 844:irmp.c        ****                 {                                                           // if stop condition is
 845:irmp.c        ****                     uint8_t     i8;
 846:irmp.c        ****                     uint16_t    i;
 847:irmp.c        ****                     uint16_t    j;
 848:irmp.c        ****                     uint8_t     v = '1';
 849:irmp.c        ****                     uint16_t    d;
 850:irmp.c        **** 
 851:irmp.c        ****                     for (i8 = 0; i8 < STARTCYCLES; i8++)
 852:irmp.c        ****                     {
 853:irmp.c        ****                         irmp_uart_putc ('0');                               // the ignored starting
 854:irmp.c        ****                     }
 855:irmp.c        **** 
 856:irmp.c        ****                     for (i = 0; i < buf_idx; i++)
 857:irmp.c        ****                     {
 858:irmp.c        ****                         d = buf[i];
 859:irmp.c        **** 
 860:irmp.c        ****                         if (d == 0xff)
 861:irmp.c        ****                         {
 862:irmp.c        ****                             i++;
 863:irmp.c        ****                             d = buf[i];
 864:irmp.c        ****                             i++;
 865:irmp.c        ****                             d |= ((uint16_t) buf[i] << 8);
 866:irmp.c        ****                         }
 867:irmp.c        **** 
 868:irmp.c        ****                         for (j = 0; j < d; j++)
 869:irmp.c        ****                         {
 870:irmp.c        ****                             irmp_uart_putc (v);
 871:irmp.c        ****                         }
 872:irmp.c        **** 
 873:irmp.c        ****                         v = (v == '1') ? '0' : '1';
 874:irmp.c        ****                     }
 875:irmp.c        **** 
 876:irmp.c        ****                     for (i8 = 0; i8 < 20; i8++)
 877:irmp.c        ****                     {
 878:irmp.c        ****                         irmp_uart_putc ('1');
 879:irmp.c        ****                     }
 880:irmp.c        **** 
 881:irmp.c        ****                     irmp_uart_putc ('\n');
 882:irmp.c        ****                     buf_idx = 0;
 883:irmp.c        ****                     last_val = 1;
 884:irmp.c        ****                     cnt = 0;
 885:irmp.c        ****                 }
 886:irmp.c        ****             }
 887:irmp.c        ****             else if (buf_idx < DATALEN - 3)
 888:irmp.c        ****             {
 889:irmp.c        ****                 if (cnt >= 0xff)
 890:irmp.c        ****                 {
 891:irmp.c        ****                     buf[buf_idx++]  = 0xff;
 892:irmp.c        ****                     buf[buf_idx++]  = (cnt & 0xff);
 893:irmp.c        ****                     buf[buf_idx]    = (cnt >> 8);
 894:irmp.c        ****                 }
 895:irmp.c        ****                 else
 896:irmp.c        ****                 {
 897:irmp.c        ****                     buf[buf_idx] = cnt;
 898:irmp.c        ****                 }
 899:irmp.c        **** 
 900:irmp.c        ****                 buf_idx++;
 901:irmp.c        ****                 cnt = 1;
 902:irmp.c        ****                 last_val = val;
 903:irmp.c        ****             }
 904:irmp.c        ****         }
 905:irmp.c        ****     }
 906:irmp.c        **** }
 907:irmp.c        **** 
 908:irmp.c        **** #else
 909:irmp.c        **** #define irmp_log(val)
 910:irmp.c        **** #endif //IRMP_LOGGING
 911:irmp.c        **** 
 912:irmp.c        **** typedef struct
 913:irmp.c        **** {
 914:irmp.c        ****     uint8_t    protocol;                                                // ir protocol
 915:irmp.c        ****     uint8_t    pulse_1_len_min;                                         // minimum length of pulse 
 916:irmp.c        ****     uint8_t    pulse_1_len_max;                                         // maximum length of pulse 
 917:irmp.c        ****     uint8_t    pause_1_len_min;                                         // minimum length of pause 
 918:irmp.c        ****     uint8_t    pause_1_len_max;                                         // maximum length of pause 
 919:irmp.c        ****     uint8_t    pulse_0_len_min;                                         // minimum length of pulse 
 920:irmp.c        ****     uint8_t    pulse_0_len_max;                                         // maximum length of pulse 
 921:irmp.c        ****     uint8_t    pause_0_len_min;                                         // minimum length of pause 
 922:irmp.c        ****     uint8_t    pause_0_len_max;                                         // maximum length of pause 
 923:irmp.c        ****     uint8_t    address_offset;                                          // address offset
 924:irmp.c        ****     uint8_t    address_end;                                             // end of address
 925:irmp.c        ****     uint8_t    command_offset;                                          // command offset
 926:irmp.c        ****     uint8_t    command_end;                                             // end of command
 927:irmp.c        ****     uint8_t    complete_len;                                            // complete length of frame
 928:irmp.c        ****     uint8_t    stop_bit;                                                // flag: frame has stop bit
 929:irmp.c        ****     uint8_t    lsb_first;                                               // flag: LSB first
 930:irmp.c        ****     uint8_t    flags;                                                   // some flags
 931:irmp.c        **** } IRMP_PARAMETER;
 932:irmp.c        **** 
 933:irmp.c        **** #if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
 934:irmp.c        **** 
 935:irmp.c        **** static const PROGMEM IRMP_PARAMETER sircs_param =
 936:irmp.c        **** {
 937:irmp.c        ****     IRMP_SIRCS_PROTOCOL,                                                // protocol:        ir prot
 938:irmp.c        ****     SIRCS_1_PULSE_LEN_MIN,                                              // pulse_1_len_min: minimum
 939:irmp.c        ****     SIRCS_1_PULSE_LEN_MAX,                                              // pulse_1_len_max: maximum
 940:irmp.c        ****     SIRCS_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum
 941:irmp.c        ****     SIRCS_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum
 942:irmp.c        ****     SIRCS_0_PULSE_LEN_MIN,                                              // pulse_0_len_min: minimum
 943:irmp.c        ****     SIRCS_0_PULSE_LEN_MAX,                                              // pulse_0_len_max: maximum
 944:irmp.c        ****     SIRCS_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum
 945:irmp.c        ****     SIRCS_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum
 946:irmp.c        ****     SIRCS_ADDRESS_OFFSET,                                               // address_offset:  address
 947:irmp.c        ****     SIRCS_ADDRESS_OFFSET + SIRCS_ADDRESS_LEN,                           // address_end:     end of 
 948:irmp.c        ****     SIRCS_COMMAND_OFFSET,                                               // command_offset:  command
 949:irmp.c        ****     SIRCS_COMMAND_OFFSET + SIRCS_COMMAND_LEN,                           // command_end:     end of 
 950:irmp.c        ****     SIRCS_COMPLETE_DATA_LEN,                                            // complete_len:    complet
 951:irmp.c        ****     SIRCS_STOP_BIT,                                                     // stop_bit:        flag: f
 952:irmp.c        ****     SIRCS_LSB,                                                          // lsb_first:       flag: L
 953:irmp.c        ****     SIRCS_FLAGS                                                         // flags:           some fl
 954:irmp.c        **** };
 955:irmp.c        **** 
 956:irmp.c        **** #endif
 957:irmp.c        **** 
 958:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
 959:irmp.c        **** 
 960:irmp.c        **** static const PROGMEM IRMP_PARAMETER nec_param =
 961:irmp.c        **** {
 962:irmp.c        ****     IRMP_NEC_PROTOCOL,                                                  // protocol:        ir prot
 963:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum
 964:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum
 965:irmp.c        ****     NEC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum
 966:irmp.c        ****     NEC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum
 967:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum
 968:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum
 969:irmp.c        ****     NEC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum
 970:irmp.c        ****     NEC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum
 971:irmp.c        ****     NEC_ADDRESS_OFFSET,                                                 // address_offset:  address
 972:irmp.c        ****     NEC_ADDRESS_OFFSET + NEC_ADDRESS_LEN,                               // address_end:     end of 
 973:irmp.c        ****     NEC_COMMAND_OFFSET,                                                 // command_offset:  command
 974:irmp.c        ****     NEC_COMMAND_OFFSET + NEC_COMMAND_LEN,                               // command_end:     end of 
 975:irmp.c        ****     NEC_COMPLETE_DATA_LEN,                                              // complete_len:    complet
 976:irmp.c        ****     NEC_STOP_BIT,                                                       // stop_bit:        flag: f
 977:irmp.c        ****     NEC_LSB,                                                            // lsb_first:       flag: L
 978:irmp.c        ****     NEC_FLAGS                                                           // flags:           some fl
 979:irmp.c        **** };
 980:irmp.c        **** 
 981:irmp.c        **** static const PROGMEM IRMP_PARAMETER nec_rep_param =
 982:irmp.c        **** {
 983:irmp.c        ****     IRMP_NEC_PROTOCOL,                                                  // protocol:        ir prot
 984:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum
 985:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum
 986:irmp.c        ****     NEC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum
 987:irmp.c        ****     NEC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum
 988:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum
 989:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum
 990:irmp.c        ****     NEC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum
 991:irmp.c        ****     NEC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum
 992:irmp.c        ****     0,                                                                  // address_offset:  address
 993:irmp.c        ****     0,                                                                  // address_end:     end of 
 994:irmp.c        ****     0,                                                                  // command_offset:  command
 995:irmp.c        ****     0,                                                                  // command_end:     end of 
 996:irmp.c        ****     0,                                                                  // complete_len:    complet
 997:irmp.c        ****     NEC_STOP_BIT,                                                       // stop_bit:        flag: f
 998:irmp.c        ****     NEC_LSB,                                                            // lsb_first:       flag: L
 999:irmp.c        ****     NEC_FLAGS                                                           // flags:           some fl
1000:irmp.c        **** };
1001:irmp.c        **** 
1002:irmp.c        **** #endif
1003:irmp.c        **** 
1004:irmp.c        **** #if IRMP_SUPPORT_NEC42_PROTOCOL == 1
1005:irmp.c        **** 
1006:irmp.c        **** static const PROGMEM IRMP_PARAMETER nec42_param =
1007:irmp.c        **** {
1008:irmp.c        ****     IRMP_NEC42_PROTOCOL,                                                // protocol:        ir prot
1009:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum
1010:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum
1011:irmp.c        ****     NEC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum
1012:irmp.c        ****     NEC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum
1013:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum
1014:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum
1015:irmp.c        ****     NEC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum
1016:irmp.c        ****     NEC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum
1017:irmp.c        ****     NEC42_ADDRESS_OFFSET,                                               // address_offset:  address
1018:irmp.c        ****     NEC42_ADDRESS_OFFSET + NEC42_ADDRESS_LEN,                           // address_end:     end of 
1019:irmp.c        ****     NEC42_COMMAND_OFFSET,                                               // command_offset:  command
1020:irmp.c        ****     NEC42_COMMAND_OFFSET + NEC42_COMMAND_LEN,                           // command_end:     end of 
1021:irmp.c        ****     NEC42_COMPLETE_DATA_LEN,                                            // complete_len:    complet
1022:irmp.c        ****     NEC_STOP_BIT,                                                       // stop_bit:        flag: f
1023:irmp.c        ****     NEC_LSB,                                                            // lsb_first:       flag: L
1024:irmp.c        ****     NEC_FLAGS                                                           // flags:           some fl
1025:irmp.c        **** };
1026:irmp.c        **** 
1027:irmp.c        **** #endif
1028:irmp.c        **** 
1029:irmp.c        **** #if IRMP_SUPPORT_LGAIR_PROTOCOL == 1
1030:irmp.c        **** 
1031:irmp.c        **** static const PROGMEM IRMP_PARAMETER lgair_param =
1032:irmp.c        **** {
1033:irmp.c        ****     IRMP_LGAIR_PROTOCOL,                                                // protocol:        ir prot
1034:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum
1035:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum
1036:irmp.c        ****     NEC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum
1037:irmp.c        ****     NEC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum
1038:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum
1039:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum
1040:irmp.c        ****     NEC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum
1041:irmp.c        ****     NEC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum
1042:irmp.c        ****     LGAIR_ADDRESS_OFFSET,                                               // address_offset:  address
1043:irmp.c        ****     LGAIR_ADDRESS_OFFSET + LGAIR_ADDRESS_LEN,                           // address_end:     end of 
1044:irmp.c        ****     LGAIR_COMMAND_OFFSET,                                               // command_offset:  command
1045:irmp.c        ****     LGAIR_COMMAND_OFFSET + LGAIR_COMMAND_LEN,                           // command_end:     end of 
1046:irmp.c        ****     LGAIR_COMPLETE_DATA_LEN,                                            // complete_len:    complet
1047:irmp.c        ****     NEC_STOP_BIT,                                                       // stop_bit:        flag: f
1048:irmp.c        ****     NEC_LSB,                                                            // lsb_first:       flag: L
1049:irmp.c        ****     NEC_FLAGS                                                           // flags:           some fl
1050:irmp.c        **** };
1051:irmp.c        **** 
1052:irmp.c        **** #endif
1053:irmp.c        **** 
1054:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
1055:irmp.c        **** 
1056:irmp.c        **** static const PROGMEM IRMP_PARAMETER samsung_param =
1057:irmp.c        **** {
1058:irmp.c        ****     IRMP_SAMSUNG_PROTOCOL,                                              // protocol:        ir prot
1059:irmp.c        ****     SAMSUNG_PULSE_LEN_MIN,                                              // pulse_1_len_min: minimum
1060:irmp.c        ****     SAMSUNG_PULSE_LEN_MAX,                                              // pulse_1_len_max: maximum
1061:irmp.c        ****     SAMSUNG_1_PAUSE_LEN_MIN,                                            // pause_1_len_min: minimum
1062:irmp.c        ****     SAMSUNG_1_PAUSE_LEN_MAX,                                            // pause_1_len_max: maximum
1063:irmp.c        ****     SAMSUNG_PULSE_LEN_MIN,                                              // pulse_0_len_min: minimum
1064:irmp.c        ****     SAMSUNG_PULSE_LEN_MAX,                                              // pulse_0_len_max: maximum
1065:irmp.c        ****     SAMSUNG_0_PAUSE_LEN_MIN,                                            // pause_0_len_min: minimum
1066:irmp.c        ****     SAMSUNG_0_PAUSE_LEN_MAX,                                            // pause_0_len_max: maximum
1067:irmp.c        ****     SAMSUNG_ADDRESS_OFFSET,                                             // address_offset:  address
1068:irmp.c        ****     SAMSUNG_ADDRESS_OFFSET + SAMSUNG_ADDRESS_LEN,                       // address_end:     end of 
1069:irmp.c        ****     SAMSUNG_COMMAND_OFFSET,                                             // command_offset:  command
1070:irmp.c        ****     SAMSUNG_COMMAND_OFFSET + SAMSUNG_COMMAND_LEN,                       // command_end:     end of 
1071:irmp.c        ****     SAMSUNG_COMPLETE_DATA_LEN,                                          // complete_len:    complet
1072:irmp.c        ****     SAMSUNG_STOP_BIT,                                                   // stop_bit:        flag: f
1073:irmp.c        ****     SAMSUNG_LSB,                                                        // lsb_first:       flag: L
1074:irmp.c        ****     SAMSUNG_FLAGS                                                       // flags:           some fl
1075:irmp.c        **** };
1076:irmp.c        **** 
1077:irmp.c        **** #endif
1078:irmp.c        **** 
1079:irmp.c        **** #if IRMP_SUPPORT_TELEFUNKEN_PROTOCOL == 1
1080:irmp.c        **** 
1081:irmp.c        **** static const PROGMEM IRMP_PARAMETER telefunken_param =
1082:irmp.c        **** {
1083:irmp.c        ****     IRMP_TELEFUNKEN_PROTOCOL,                                           // protocol:        ir prot
1084:irmp.c        ****     TELEFUNKEN_PULSE_LEN_MIN,                                           // pulse_1_len_min: minimum
1085:irmp.c        ****     TELEFUNKEN_PULSE_LEN_MAX,                                           // pulse_1_len_max: maximum
1086:irmp.c        ****     TELEFUNKEN_1_PAUSE_LEN_MIN,                                         // pause_1_len_min: minimum
1087:irmp.c        ****     TELEFUNKEN_1_PAUSE_LEN_MAX,                                         // pause_1_len_max: maximum
1088:irmp.c        ****     TELEFUNKEN_PULSE_LEN_MIN,                                           // pulse_0_len_min: minimum
1089:irmp.c        ****     TELEFUNKEN_PULSE_LEN_MAX,                                           // pulse_0_len_max: maximum
1090:irmp.c        ****     TELEFUNKEN_0_PAUSE_LEN_MIN,                                         // pause_0_len_min: minimum
1091:irmp.c        ****     TELEFUNKEN_0_PAUSE_LEN_MAX,                                         // pause_0_len_max: maximum
1092:irmp.c        ****     TELEFUNKEN_ADDRESS_OFFSET,                                          // address_offset:  address
1093:irmp.c        ****     TELEFUNKEN_ADDRESS_OFFSET + TELEFUNKEN_ADDRESS_LEN,                 // address_end:     end of 
1094:irmp.c        ****     TELEFUNKEN_COMMAND_OFFSET,                                          // command_offset:  command
1095:irmp.c        ****     TELEFUNKEN_COMMAND_OFFSET + TELEFUNKEN_COMMAND_LEN,                 // command_end:     end of 
1096:irmp.c        ****     TELEFUNKEN_COMPLETE_DATA_LEN,                                       // complete_len:    complet
1097:irmp.c        ****     TELEFUNKEN_STOP_BIT,                                                // stop_bit:        flag: f
1098:irmp.c        ****     TELEFUNKEN_LSB,                                                     // lsb_first:       flag: L
1099:irmp.c        ****     TELEFUNKEN_FLAGS                                                    // flags:           some fl
1100:irmp.c        **** };
1101:irmp.c        **** 
1102:irmp.c        **** #endif
1103:irmp.c        **** 
1104:irmp.c        **** #if IRMP_SUPPORT_MATSUSHITA_PROTOCOL == 1
1105:irmp.c        **** 
1106:irmp.c        **** static const PROGMEM IRMP_PARAMETER matsushita_param =
1107:irmp.c        **** {
1108:irmp.c        ****     IRMP_MATSUSHITA_PROTOCOL,                                           // protocol:        ir prot
1109:irmp.c        ****     MATSUSHITA_PULSE_LEN_MIN,                                           // pulse_1_len_min: minimum
1110:irmp.c        ****     MATSUSHITA_PULSE_LEN_MAX,                                           // pulse_1_len_max: maximum
1111:irmp.c        ****     MATSUSHITA_1_PAUSE_LEN_MIN,                                         // pause_1_len_min: minimum
1112:irmp.c        ****     MATSUSHITA_1_PAUSE_LEN_MAX,                                         // pause_1_len_max: maximum
1113:irmp.c        ****     MATSUSHITA_PULSE_LEN_MIN,                                           // pulse_0_len_min: minimum
1114:irmp.c        ****     MATSUSHITA_PULSE_LEN_MAX,                                           // pulse_0_len_max: maximum
1115:irmp.c        ****     MATSUSHITA_0_PAUSE_LEN_MIN,                                         // pause_0_len_min: minimum
1116:irmp.c        ****     MATSUSHITA_0_PAUSE_LEN_MAX,                                         // pause_0_len_max: maximum
1117:irmp.c        ****     MATSUSHITA_ADDRESS_OFFSET,                                          // address_offset:  address
1118:irmp.c        ****     MATSUSHITA_ADDRESS_OFFSET + MATSUSHITA_ADDRESS_LEN,                 // address_end:     end of 
1119:irmp.c        ****     MATSUSHITA_COMMAND_OFFSET,                                          // command_offset:  command
1120:irmp.c        ****     MATSUSHITA_COMMAND_OFFSET + MATSUSHITA_COMMAND_LEN,                 // command_end:     end of 
1121:irmp.c        ****     MATSUSHITA_COMPLETE_DATA_LEN,                                       // complete_len:    complet
1122:irmp.c        ****     MATSUSHITA_STOP_BIT,                                                // stop_bit:        flag: f
1123:irmp.c        ****     MATSUSHITA_LSB,                                                     // lsb_first:       flag: L
1124:irmp.c        ****     MATSUSHITA_FLAGS                                                    // flags:           some fl
1125:irmp.c        **** };
1126:irmp.c        **** 
1127:irmp.c        **** #endif
1128:irmp.c        **** 
1129:irmp.c        **** #if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
1130:irmp.c        **** 
1131:irmp.c        **** static const PROGMEM IRMP_PARAMETER kaseikyo_param =
1132:irmp.c        **** {
1133:irmp.c        ****     IRMP_KASEIKYO_PROTOCOL,                                             // protocol:        ir prot
1134:irmp.c        ****     KASEIKYO_PULSE_LEN_MIN,                                             // pulse_1_len_min: minimum
1135:irmp.c        ****     KASEIKYO_PULSE_LEN_MAX,                                             // pulse_1_len_max: maximum
1136:irmp.c        ****     KASEIKYO_1_PAUSE_LEN_MIN,                                           // pause_1_len_min: minimum
1137:irmp.c        ****     KASEIKYO_1_PAUSE_LEN_MAX,                                           // pause_1_len_max: maximum
1138:irmp.c        ****     KASEIKYO_PULSE_LEN_MIN,                                             // pulse_0_len_min: minimum
1139:irmp.c        ****     KASEIKYO_PULSE_LEN_MAX,                                             // pulse_0_len_max: maximum
1140:irmp.c        ****     KASEIKYO_0_PAUSE_LEN_MIN,                                           // pause_0_len_min: minimum
1141:irmp.c        ****     KASEIKYO_0_PAUSE_LEN_MAX,                                           // pause_0_len_max: maximum
1142:irmp.c        ****     KASEIKYO_ADDRESS_OFFSET,                                            // address_offset:  address
1143:irmp.c        ****     KASEIKYO_ADDRESS_OFFSET + KASEIKYO_ADDRESS_LEN,                     // address_end:     end of 
1144:irmp.c        ****     KASEIKYO_COMMAND_OFFSET,                                            // command_offset:  command
1145:irmp.c        ****     KASEIKYO_COMMAND_OFFSET + KASEIKYO_COMMAND_LEN,                     // command_end:     end of 
1146:irmp.c        ****     KASEIKYO_COMPLETE_DATA_LEN,                                         // complete_len:    complet
1147:irmp.c        ****     KASEIKYO_STOP_BIT,                                                  // stop_bit:        flag: f
1148:irmp.c        ****     KASEIKYO_LSB,                                                       // lsb_first:       flag: L
1149:irmp.c        ****     KASEIKYO_FLAGS                                                      // flags:           some fl
1150:irmp.c        **** };
1151:irmp.c        **** 
1152:irmp.c        **** #endif
1153:irmp.c        **** 
1154:irmp.c        **** #if IRMP_SUPPORT_RECS80_PROTOCOL == 1
1155:irmp.c        **** 
1156:irmp.c        **** static const PROGMEM IRMP_PARAMETER recs80_param =
1157:irmp.c        **** {
1158:irmp.c        ****     IRMP_RECS80_PROTOCOL,                                               // protocol:        ir prot
1159:irmp.c        ****     RECS80_PULSE_LEN_MIN,                                               // pulse_1_len_min: minimum
1160:irmp.c        ****     RECS80_PULSE_LEN_MAX,                                               // pulse_1_len_max: maximum
1161:irmp.c        ****     RECS80_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum
1162:irmp.c        ****     RECS80_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum
1163:irmp.c        ****     RECS80_PULSE_LEN_MIN,                                               // pulse_0_len_min: minimum
1164:irmp.c        ****     RECS80_PULSE_LEN_MAX,                                               // pulse_0_len_max: maximum
1165:irmp.c        ****     RECS80_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum
1166:irmp.c        ****     RECS80_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum
1167:irmp.c        ****     RECS80_ADDRESS_OFFSET,                                              // address_offset:  address
1168:irmp.c        ****     RECS80_ADDRESS_OFFSET + RECS80_ADDRESS_LEN,                         // address_end:     end of 
1169:irmp.c        ****     RECS80_COMMAND_OFFSET,                                              // command_offset:  command
1170:irmp.c        ****     RECS80_COMMAND_OFFSET + RECS80_COMMAND_LEN,                         // command_end:     end of 
1171:irmp.c        ****     RECS80_COMPLETE_DATA_LEN,                                           // complete_len:    complet
1172:irmp.c        ****     RECS80_STOP_BIT,                                                    // stop_bit:        flag: f
1173:irmp.c        ****     RECS80_LSB,                                                         // lsb_first:       flag: L
1174:irmp.c        ****     RECS80_FLAGS                                                        // flags:           some fl
1175:irmp.c        **** };
1176:irmp.c        **** 
1177:irmp.c        **** #endif
1178:irmp.c        **** 
1179:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1
1180:irmp.c        **** 
1181:irmp.c        **** static const PROGMEM IRMP_PARAMETER rc5_param =
1182:irmp.c        **** {
1183:irmp.c        ****     IRMP_RC5_PROTOCOL,                                                  // protocol:        ir prot
1184:irmp.c        ****     RC5_BIT_LEN_MIN,                                                    // pulse_1_len_min: here: m
1185:irmp.c        ****     RC5_BIT_LEN_MAX,                                                    // pulse_1_len_max: here: m
1186:irmp.c        ****     RC5_BIT_LEN_MIN,                                                    // pause_1_len_min: here: m
1187:irmp.c        ****     RC5_BIT_LEN_MAX,                                                    // pause_1_len_max: here: m
1188:irmp.c        ****     0,                                                                  // pulse_0_len_min: here: n
1189:irmp.c        ****     0,                                                                  // pulse_0_len_max: here: n
1190:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
1191:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
1192:irmp.c        ****     RC5_ADDRESS_OFFSET,                                                 // address_offset:  address
1193:irmp.c        ****     RC5_ADDRESS_OFFSET + RC5_ADDRESS_LEN,                               // address_end:     end of 
1194:irmp.c        ****     RC5_COMMAND_OFFSET,                                                 // command_offset:  command
1195:irmp.c        ****     RC5_COMMAND_OFFSET + RC5_COMMAND_LEN,                               // command_end:     end of 
1196:irmp.c        ****     RC5_COMPLETE_DATA_LEN,                                              // complete_len:    complet
1197:irmp.c        ****     RC5_STOP_BIT,                                                       // stop_bit:        flag: f
1198:irmp.c        ****     RC5_LSB,                                                            // lsb_first:       flag: L
1199:irmp.c        ****     RC5_FLAGS                                                           // flags:           some fl
1200:irmp.c        **** };
1201:irmp.c        **** 
1202:irmp.c        **** #endif
1203:irmp.c        **** 
1204:irmp.c        **** #if IRMP_SUPPORT_DENON_PROTOCOL == 1
1205:irmp.c        **** 
1206:irmp.c        **** static const PROGMEM IRMP_PARAMETER denon_param =
1207:irmp.c        **** {
1208:irmp.c        ****     IRMP_DENON_PROTOCOL,                                                // protocol:        ir prot
1209:irmp.c        ****     DENON_PULSE_LEN_MIN,                                                // pulse_1_len_min: minimum
1210:irmp.c        ****     DENON_PULSE_LEN_MAX,                                                // pulse_1_len_max: maximum
1211:irmp.c        ****     DENON_1_PAUSE_LEN_MIN,                                              // pause_1_len_min: minimum
1212:irmp.c        ****     DENON_1_PAUSE_LEN_MAX,                                              // pause_1_len_max: maximum
1213:irmp.c        ****     DENON_PULSE_LEN_MIN,                                                // pulse_0_len_min: minimum
1214:irmp.c        ****     DENON_PULSE_LEN_MAX,                                                // pulse_0_len_max: maximum
1215:irmp.c        ****     DENON_0_PAUSE_LEN_MIN,                                              // pause_0_len_min: minimum
1216:irmp.c        ****     DENON_0_PAUSE_LEN_MAX,                                              // pause_0_len_max: maximum
1217:irmp.c        ****     DENON_ADDRESS_OFFSET,                                               // address_offset:  address
1218:irmp.c        ****     DENON_ADDRESS_OFFSET + DENON_ADDRESS_LEN,                           // address_end:     end of 
1219:irmp.c        ****     DENON_COMMAND_OFFSET,                                               // command_offset:  command
1220:irmp.c        ****     DENON_COMMAND_OFFSET + DENON_COMMAND_LEN,                           // command_end:     end of 
1221:irmp.c        ****     DENON_COMPLETE_DATA_LEN,                                            // complete_len:    complet
1222:irmp.c        ****     DENON_STOP_BIT,                                                     // stop_bit:        flag: f
1223:irmp.c        ****     DENON_LSB,                                                          // lsb_first:       flag: L
1224:irmp.c        ****     DENON_FLAGS                                                         // flags:           some fl
1225:irmp.c        **** };
1226:irmp.c        **** 
1227:irmp.c        **** #endif
1228:irmp.c        **** 
1229:irmp.c        **** #if IRMP_SUPPORT_RC6_PROTOCOL == 1
1230:irmp.c        **** 
1231:irmp.c        **** static const PROGMEM IRMP_PARAMETER rc6_param =
1232:irmp.c        **** {
1233:irmp.c        ****     IRMP_RC6_PROTOCOL,                                                  // protocol:        ir prot
1234:irmp.c        **** 
1235:irmp.c        ****     RC6_BIT_PULSE_LEN_MIN,                                              // pulse_1_len_min: here: m
1236:irmp.c        ****     RC6_BIT_PULSE_LEN_MAX,                                              // pulse_1_len_max: here: m
1237:irmp.c        ****     RC6_BIT_PAUSE_LEN_MIN,                                              // pause_1_len_min: here: m
1238:irmp.c        ****     RC6_BIT_PAUSE_LEN_MAX,                                              // pause_1_len_max: here: m
1239:irmp.c        ****     0,                                                                  // pulse_0_len_min: here: n
1240:irmp.c        ****     0,                                                                  // pulse_0_len_max: here: n
1241:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
1242:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
1243:irmp.c        ****     RC6_ADDRESS_OFFSET,                                                 // address_offset:  address
1244:irmp.c        ****     RC6_ADDRESS_OFFSET + RC6_ADDRESS_LEN,                               // address_end:     end of 
1245:irmp.c        ****     RC6_COMMAND_OFFSET,                                                 // command_offset:  command
1246:irmp.c        ****     RC6_COMMAND_OFFSET + RC6_COMMAND_LEN,                               // command_end:     end of 
1247:irmp.c        ****     RC6_COMPLETE_DATA_LEN_SHORT,                                        // complete_len:    complet
1248:irmp.c        ****     RC6_STOP_BIT,                                                       // stop_bit:        flag: f
1249:irmp.c        ****     RC6_LSB,                                                            // lsb_first:       flag: L
1250:irmp.c        ****     RC6_FLAGS                                                           // flags:           some fl
1251:irmp.c        **** };
1252:irmp.c        **** 
1253:irmp.c        **** #endif
1254:irmp.c        **** 
1255:irmp.c        **** #if IRMP_SUPPORT_RECS80EXT_PROTOCOL == 1
1256:irmp.c        **** 
1257:irmp.c        **** static const PROGMEM IRMP_PARAMETER recs80ext_param =
1258:irmp.c        **** {
1259:irmp.c        ****     IRMP_RECS80EXT_PROTOCOL,                                            // protocol:        ir prot
1260:irmp.c        ****     RECS80EXT_PULSE_LEN_MIN,                                            // pulse_1_len_min: minimum
1261:irmp.c        ****     RECS80EXT_PULSE_LEN_MAX,                                            // pulse_1_len_max: maximum
1262:irmp.c        ****     RECS80EXT_1_PAUSE_LEN_MIN,                                          // pause_1_len_min: minimum
1263:irmp.c        ****     RECS80EXT_1_PAUSE_LEN_MAX,                                          // pause_1_len_max: maximum
1264:irmp.c        ****     RECS80EXT_PULSE_LEN_MIN,                                            // pulse_0_len_min: minimum
1265:irmp.c        ****     RECS80EXT_PULSE_LEN_MAX,                                            // pulse_0_len_max: maximum
1266:irmp.c        ****     RECS80EXT_0_PAUSE_LEN_MIN,                                          // pause_0_len_min: minimum
1267:irmp.c        ****     RECS80EXT_0_PAUSE_LEN_MAX,                                          // pause_0_len_max: maximum
1268:irmp.c        ****     RECS80EXT_ADDRESS_OFFSET,                                           // address_offset:  address
1269:irmp.c        ****     RECS80EXT_ADDRESS_OFFSET + RECS80EXT_ADDRESS_LEN,                   // address_end:     end of 
1270:irmp.c        ****     RECS80EXT_COMMAND_OFFSET,                                           // command_offset:  command
1271:irmp.c        ****     RECS80EXT_COMMAND_OFFSET + RECS80EXT_COMMAND_LEN,                   // command_end:     end of 
1272:irmp.c        ****     RECS80EXT_COMPLETE_DATA_LEN,                                        // complete_len:    complet
1273:irmp.c        ****     RECS80EXT_STOP_BIT,                                                 // stop_bit:        flag: f
1274:irmp.c        ****     RECS80EXT_LSB,                                                      // lsb_first:       flag: L
1275:irmp.c        ****     RECS80EXT_FLAGS                                                     // flags:           some fl
1276:irmp.c        **** };
1277:irmp.c        **** 
1278:irmp.c        **** #endif
1279:irmp.c        **** 
1280:irmp.c        **** #if IRMP_SUPPORT_NUBERT_PROTOCOL == 1
1281:irmp.c        **** 
1282:irmp.c        **** static const PROGMEM IRMP_PARAMETER nubert_param =
1283:irmp.c        **** {
1284:irmp.c        ****     IRMP_NUBERT_PROTOCOL,                                               // protocol:        ir prot
1285:irmp.c        ****     NUBERT_1_PULSE_LEN_MIN,                                             // pulse_1_len_min: minimum
1286:irmp.c        ****     NUBERT_1_PULSE_LEN_MAX,                                             // pulse_1_len_max: maximum
1287:irmp.c        ****     NUBERT_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum
1288:irmp.c        ****     NUBERT_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum
1289:irmp.c        ****     NUBERT_0_PULSE_LEN_MIN,                                             // pulse_0_len_min: minimum
1290:irmp.c        ****     NUBERT_0_PULSE_LEN_MAX,                                             // pulse_0_len_max: maximum
1291:irmp.c        ****     NUBERT_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum
1292:irmp.c        ****     NUBERT_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum
1293:irmp.c        ****     NUBERT_ADDRESS_OFFSET,                                              // address_offset:  address
1294:irmp.c        ****     NUBERT_ADDRESS_OFFSET + NUBERT_ADDRESS_LEN,                         // address_end:     end of 
1295:irmp.c        ****     NUBERT_COMMAND_OFFSET,                                              // command_offset:  command
1296:irmp.c        ****     NUBERT_COMMAND_OFFSET + NUBERT_COMMAND_LEN,                         // command_end:     end of 
1297:irmp.c        ****     NUBERT_COMPLETE_DATA_LEN,                                           // complete_len:    complet
1298:irmp.c        ****     NUBERT_STOP_BIT,                                                    // stop_bit:        flag: f
1299:irmp.c        ****     NUBERT_LSB,                                                         // lsb_first:       flag: L
1300:irmp.c        ****     NUBERT_FLAGS                                                        // flags:           some fl
1301:irmp.c        **** };
1302:irmp.c        **** 
1303:irmp.c        **** #endif
1304:irmp.c        **** 
1305:irmp.c        **** #if IRMP_SUPPORT_SPEAKER_PROTOCOL == 1
1306:irmp.c        **** 
1307:irmp.c        **** static const PROGMEM IRMP_PARAMETER speaker_param =
1308:irmp.c        **** {
1309:irmp.c        ****     IRMP_SPEAKER_PROTOCOL,                                              // protocol:        ir prot
1310:irmp.c        ****     SPEAKER_1_PULSE_LEN_MIN,                                            // pulse_1_len_min: minimum
1311:irmp.c        ****     SPEAKER_1_PULSE_LEN_MAX,                                            // pulse_1_len_max: maximum
1312:irmp.c        ****     SPEAKER_1_PAUSE_LEN_MIN,                                            // pause_1_len_min: minimum
1313:irmp.c        ****     SPEAKER_1_PAUSE_LEN_MAX,                                            // pause_1_len_max: maximum
1314:irmp.c        ****     SPEAKER_0_PULSE_LEN_MIN,                                            // pulse_0_len_min: minimum
1315:irmp.c        ****     SPEAKER_0_PULSE_LEN_MAX,                                            // pulse_0_len_max: maximum
1316:irmp.c        ****     SPEAKER_0_PAUSE_LEN_MIN,                                            // pause_0_len_min: minimum
1317:irmp.c        ****     SPEAKER_0_PAUSE_LEN_MAX,                                            // pause_0_len_max: maximum
1318:irmp.c        ****     SPEAKER_ADDRESS_OFFSET,                                             // address_offset:  address
1319:irmp.c        ****     SPEAKER_ADDRESS_OFFSET + SPEAKER_ADDRESS_LEN,                       // address_end:     end of 
1320:irmp.c        ****     SPEAKER_COMMAND_OFFSET,                                             // command_offset:  command
1321:irmp.c        ****     SPEAKER_COMMAND_OFFSET + SPEAKER_COMMAND_LEN,                       // command_end:     end of 
1322:irmp.c        ****     SPEAKER_COMPLETE_DATA_LEN,                                          // complete_len:    complet
1323:irmp.c        ****     SPEAKER_STOP_BIT,                                                   // stop_bit:        flag: f
1324:irmp.c        ****     SPEAKER_LSB,                                                        // lsb_first:       flag: L
1325:irmp.c        ****     SPEAKER_FLAGS                                                       // flags:           some fl
1326:irmp.c        **** };
1327:irmp.c        **** 
1328:irmp.c        **** #endif
1329:irmp.c        **** 
1330:irmp.c        **** #if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
1331:irmp.c        **** 
1332:irmp.c        **** static const PROGMEM IRMP_PARAMETER bang_olufsen_param =
1333:irmp.c        **** {
1334:irmp.c        ****     IRMP_BANG_OLUFSEN_PROTOCOL,                                         // protocol:        ir prot
1335:irmp.c        ****     BANG_OLUFSEN_PULSE_LEN_MIN,                                         // pulse_1_len_min: minimum
1336:irmp.c        ****     BANG_OLUFSEN_PULSE_LEN_MAX,                                         // pulse_1_len_max: maximum
1337:irmp.c        ****     BANG_OLUFSEN_1_PAUSE_LEN_MIN,                                       // pause_1_len_min: minimum
1338:irmp.c        ****     BANG_OLUFSEN_1_PAUSE_LEN_MAX,                                       // pause_1_len_max: maximum
1339:irmp.c        ****     BANG_OLUFSEN_PULSE_LEN_MIN,                                         // pulse_0_len_min: minimum
1340:irmp.c        ****     BANG_OLUFSEN_PULSE_LEN_MAX,                                         // pulse_0_len_max: maximum
1341:irmp.c        ****     BANG_OLUFSEN_0_PAUSE_LEN_MIN,                                       // pause_0_len_min: minimum
1342:irmp.c        ****     BANG_OLUFSEN_0_PAUSE_LEN_MAX,                                       // pause_0_len_max: maximum
1343:irmp.c        ****     BANG_OLUFSEN_ADDRESS_OFFSET,                                        // address_offset:  address
1344:irmp.c        ****     BANG_OLUFSEN_ADDRESS_OFFSET + BANG_OLUFSEN_ADDRESS_LEN,             // address_end:     end of 
1345:irmp.c        ****     BANG_OLUFSEN_COMMAND_OFFSET,                                        // command_offset:  command
1346:irmp.c        ****     BANG_OLUFSEN_COMMAND_OFFSET + BANG_OLUFSEN_COMMAND_LEN,             // command_end:     end of 
1347:irmp.c        ****     BANG_OLUFSEN_COMPLETE_DATA_LEN,                                     // complete_len:    complet
1348:irmp.c        ****     BANG_OLUFSEN_STOP_BIT,                                              // stop_bit:        flag: f
1349:irmp.c        ****     BANG_OLUFSEN_LSB,                                                   // lsb_first:       flag: L
1350:irmp.c        ****     BANG_OLUFSEN_FLAGS                                                  // flags:           some fl
1351:irmp.c        **** };
1352:irmp.c        **** 
1353:irmp.c        **** #endif
1354:irmp.c        **** 
1355:irmp.c        **** #if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
1356:irmp.c        **** 
1357:irmp.c        **** static uint8_t first_bit;
1358:irmp.c        **** 
1359:irmp.c        **** static const PROGMEM IRMP_PARAMETER grundig_param =
1360:irmp.c        **** {
1361:irmp.c        ****     IRMP_GRUNDIG_PROTOCOL,                                              // protocol:        ir prot
1362:irmp.c        **** 
1363:irmp.c        ****     GRUNDIG_NOKIA_IR60_BIT_LEN_MIN,                                     // pulse_1_len_min: here: m
1364:irmp.c        ****     GRUNDIG_NOKIA_IR60_BIT_LEN_MAX,                                     // pulse_1_len_max: here: m
1365:irmp.c        ****     GRUNDIG_NOKIA_IR60_BIT_LEN_MIN,                                     // pause_1_len_min: here: m
1366:irmp.c        ****     GRUNDIG_NOKIA_IR60_BIT_LEN_MAX,                                     // pause_1_len_max: here: m
1367:irmp.c        ****     0,                                                                  // pulse_0_len_min: here: n
1368:irmp.c        ****     0,                                                                  // pulse_0_len_max: here: n
1369:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
1370:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
1371:irmp.c        ****     GRUNDIG_ADDRESS_OFFSET,                                             // address_offset:  address
1372:irmp.c        ****     GRUNDIG_ADDRESS_OFFSET + GRUNDIG_ADDRESS_LEN,                       // address_end:     end of 
1373:irmp.c        ****     GRUNDIG_COMMAND_OFFSET,                                             // command_offset:  command
1374:irmp.c        ****     GRUNDIG_COMMAND_OFFSET + GRUNDIG_COMMAND_LEN + 1,                   // command_end:     end of 
1375:irmp.c        ****     NOKIA_COMPLETE_DATA_LEN,                                            // complete_len:    complet
1376:irmp.c        ****     GRUNDIG_NOKIA_IR60_STOP_BIT,                                        // stop_bit:        flag: f
1377:irmp.c        ****     GRUNDIG_NOKIA_IR60_LSB,                                             // lsb_first:       flag: L
1378:irmp.c        ****     GRUNDIG_NOKIA_IR60_FLAGS                                            // flags:           some fl
1379:irmp.c        **** };
1380:irmp.c        **** 
1381:irmp.c        **** #endif
1382:irmp.c        **** 
1383:irmp.c        **** #if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
1384:irmp.c        **** 
1385:irmp.c        **** static const PROGMEM IRMP_PARAMETER ruwido_param =
1386:irmp.c        **** {
1387:irmp.c        ****     IRMP_RUWIDO_PROTOCOL,                                               // protocol:        ir prot
1388:irmp.c        ****     SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MIN,                                // pulse_1_len_min: here: m
1389:irmp.c        ****     SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MAX,                                // pulse_1_len_max: here: m
1390:irmp.c        ****     SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MIN,                                // pause_1_len_min: here: m
1391:irmp.c        ****     SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MAX,                                // pause_1_len_max: here: m
1392:irmp.c        ****     0,                                                                  // pulse_0_len_min: here: n
1393:irmp.c        ****     0,                                                                  // pulse_0_len_max: here: n
1394:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
1395:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
1396:irmp.c        ****     RUWIDO_ADDRESS_OFFSET,                                              // address_offset:  address
1397:irmp.c        ****     RUWIDO_ADDRESS_OFFSET + RUWIDO_ADDRESS_LEN,                         // address_end:     end of 
1398:irmp.c        ****     RUWIDO_COMMAND_OFFSET,                                              // command_offset:  command
1399:irmp.c        ****     RUWIDO_COMMAND_OFFSET + RUWIDO_COMMAND_LEN,                         // command_end:     end of 
1400:irmp.c        ****     SIEMENS_COMPLETE_DATA_LEN,                                          // complete_len:    complet
1401:irmp.c        ****     SIEMENS_OR_RUWIDO_STOP_BIT,                                         // stop_bit:        flag: f
1402:irmp.c        ****     SIEMENS_OR_RUWIDO_LSB,                                              // lsb_first:       flag: L
1403:irmp.c        ****     SIEMENS_OR_RUWIDO_FLAGS                                             // flags:           some fl
1404:irmp.c        **** };
1405:irmp.c        **** 
1406:irmp.c        **** #endif
1407:irmp.c        **** 
1408:irmp.c        **** #if IRMP_SUPPORT_FDC_PROTOCOL == 1
1409:irmp.c        **** 
1410:irmp.c        **** static const PROGMEM IRMP_PARAMETER fdc_param =
1411:irmp.c        **** {
1412:irmp.c        ****     IRMP_FDC_PROTOCOL,                                                  // protocol:        ir prot
1413:irmp.c        ****     FDC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum
1414:irmp.c        ****     FDC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum
1415:irmp.c        ****     FDC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum
1416:irmp.c        ****     FDC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum
1417:irmp.c        ****     FDC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum
1418:irmp.c        ****     FDC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum
1419:irmp.c        ****     FDC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum
1420:irmp.c        ****     FDC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum
1421:irmp.c        ****     FDC_ADDRESS_OFFSET,                                                 // address_offset:  address
1422:irmp.c        ****     FDC_ADDRESS_OFFSET + FDC_ADDRESS_LEN,                               // address_end:     end of 
1423:irmp.c        ****     FDC_COMMAND_OFFSET,                                                 // command_offset:  command
1424:irmp.c        ****     FDC_COMMAND_OFFSET + FDC_COMMAND_LEN,                               // command_end:     end of 
1425:irmp.c        ****     FDC_COMPLETE_DATA_LEN,                                              // complete_len:    complet
1426:irmp.c        ****     FDC_STOP_BIT,                                                       // stop_bit:        flag: f
1427:irmp.c        ****     FDC_LSB,                                                            // lsb_first:       flag: L
1428:irmp.c        ****     FDC_FLAGS                                                           // flags:           some fl
1429:irmp.c        **** };
1430:irmp.c        **** 
1431:irmp.c        **** #endif
1432:irmp.c        **** 
1433:irmp.c        **** #if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
1434:irmp.c        **** 
1435:irmp.c        **** static const PROGMEM IRMP_PARAMETER rccar_param =
1436:irmp.c        **** {
1437:irmp.c        ****     IRMP_RCCAR_PROTOCOL,                                                // protocol:        ir prot
1438:irmp.c        ****     RCCAR_PULSE_LEN_MIN,                                                // pulse_1_len_min: minimum
1439:irmp.c        ****     RCCAR_PULSE_LEN_MAX,                                                // pulse_1_len_max: maximum
1440:irmp.c        ****     RCCAR_1_PAUSE_LEN_MIN,                                              // pause_1_len_min: minimum
1441:irmp.c        ****     RCCAR_1_PAUSE_LEN_MAX,                                              // pause_1_len_max: maximum
1442:irmp.c        ****     RCCAR_PULSE_LEN_MIN,                                                // pulse_0_len_min: minimum
1443:irmp.c        ****     RCCAR_PULSE_LEN_MAX,                                                // pulse_0_len_max: maximum
1444:irmp.c        ****     RCCAR_0_PAUSE_LEN_MIN,                                              // pause_0_len_min: minimum
1445:irmp.c        ****     RCCAR_0_PAUSE_LEN_MAX,                                              // pause_0_len_max: maximum
1446:irmp.c        ****     RCCAR_ADDRESS_OFFSET,                                               // address_offset:  address
1447:irmp.c        ****     RCCAR_ADDRESS_OFFSET + RCCAR_ADDRESS_LEN,                           // address_end:     end of 
1448:irmp.c        ****     RCCAR_COMMAND_OFFSET,                                               // command_offset:  command
1449:irmp.c        ****     RCCAR_COMMAND_OFFSET + RCCAR_COMMAND_LEN,                           // command_end:     end of 
1450:irmp.c        ****     RCCAR_COMPLETE_DATA_LEN,                                            // complete_len:    complet
1451:irmp.c        ****     RCCAR_STOP_BIT,                                                     // stop_bit:        flag: f
1452:irmp.c        ****     RCCAR_LSB,                                                          // lsb_first:       flag: L
1453:irmp.c        ****     RCCAR_FLAGS                                                         // flags:           some fl
1454:irmp.c        **** };
1455:irmp.c        **** 
1456:irmp.c        **** #endif
1457:irmp.c        **** 
1458:irmp.c        **** #if IRMP_SUPPORT_NIKON_PROTOCOL == 1
1459:irmp.c        **** 
1460:irmp.c        **** static const PROGMEM IRMP_PARAMETER nikon_param =
1461:irmp.c        **** {
1462:irmp.c        ****     IRMP_NIKON_PROTOCOL,                                                // protocol:        ir prot
1463:irmp.c        ****     NIKON_PULSE_LEN_MIN,                                                // pulse_1_len_min: minimum
1464:irmp.c        ****     NIKON_PULSE_LEN_MAX,                                                // pulse_1_len_max: maximum
1465:irmp.c        ****     NIKON_1_PAUSE_LEN_MIN,                                              // pause_1_len_min: minimum
1466:irmp.c        ****     NIKON_1_PAUSE_LEN_MAX,                                              // pause_1_len_max: maximum
1467:irmp.c        ****     NIKON_PULSE_LEN_MIN,                                                // pulse_0_len_min: minimum
1468:irmp.c        ****     NIKON_PULSE_LEN_MAX,                                                // pulse_0_len_max: maximum
1469:irmp.c        ****     NIKON_0_PAUSE_LEN_MIN,                                              // pause_0_len_min: minimum
1470:irmp.c        ****     NIKON_0_PAUSE_LEN_MAX,                                              // pause_0_len_max: maximum
1471:irmp.c        ****     NIKON_ADDRESS_OFFSET,                                               // address_offset:  address
1472:irmp.c        ****     NIKON_ADDRESS_OFFSET + NIKON_ADDRESS_LEN,                           // address_end:     end of 
1473:irmp.c        ****     NIKON_COMMAND_OFFSET,                                               // command_offset:  command
1474:irmp.c        ****     NIKON_COMMAND_OFFSET + NIKON_COMMAND_LEN,                           // command_end:     end of 
1475:irmp.c        ****     NIKON_COMPLETE_DATA_LEN,                                            // complete_len:    complet
1476:irmp.c        ****     NIKON_STOP_BIT,                                                     // stop_bit:        flag: f
1477:irmp.c        ****     NIKON_LSB,                                                          // lsb_first:       flag: L
1478:irmp.c        ****     NIKON_FLAGS                                                         // flags:           some fl
1479:irmp.c        **** };
1480:irmp.c        **** 
1481:irmp.c        **** #endif
1482:irmp.c        **** 
1483:irmp.c        **** #if IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
1484:irmp.c        **** 
1485:irmp.c        **** static const PROGMEM IRMP_PARAMETER kathrein_param =
1486:irmp.c        **** {
1487:irmp.c        ****     IRMP_KATHREIN_PROTOCOL,                                             // protocol:        ir prot
1488:irmp.c        ****     KATHREIN_1_PULSE_LEN_MIN,                                           // pulse_1_len_min: minimum
1489:irmp.c        ****     KATHREIN_1_PULSE_LEN_MAX,                                           // pulse_1_len_max: maximum
1490:irmp.c        ****     KATHREIN_1_PAUSE_LEN_MIN,                                           // pause_1_len_min: minimum
1491:irmp.c        ****     KATHREIN_1_PAUSE_LEN_MAX,                                           // pause_1_len_max: maximum
1492:irmp.c        ****     KATHREIN_0_PULSE_LEN_MIN,                                           // pulse_0_len_min: minimum
1493:irmp.c        ****     KATHREIN_0_PULSE_LEN_MAX,                                           // pulse_0_len_max: maximum
1494:irmp.c        ****     KATHREIN_0_PAUSE_LEN_MIN,                                           // pause_0_len_min: minimum
1495:irmp.c        ****     KATHREIN_0_PAUSE_LEN_MAX,                                           // pause_0_len_max: maximum
1496:irmp.c        ****     KATHREIN_ADDRESS_OFFSET,                                            // address_offset:  address
1497:irmp.c        ****     KATHREIN_ADDRESS_OFFSET + KATHREIN_ADDRESS_LEN,                     // address_end:     end of 
1498:irmp.c        ****     KATHREIN_COMMAND_OFFSET,                                            // command_offset:  command
1499:irmp.c        ****     KATHREIN_COMMAND_OFFSET + KATHREIN_COMMAND_LEN,                     // command_end:     end of 
1500:irmp.c        ****     KATHREIN_COMPLETE_DATA_LEN,                                         // complete_len:    complet
1501:irmp.c        ****     KATHREIN_STOP_BIT,                                                  // stop_bit:        flag: f
1502:irmp.c        ****     KATHREIN_LSB,                                                       // lsb_first:       flag: L
1503:irmp.c        ****     KATHREIN_FLAGS                                                      // flags:           some fl
1504:irmp.c        **** };
1505:irmp.c        **** 
1506:irmp.c        **** #endif
1507:irmp.c        **** 
1508:irmp.c        **** #if IRMP_SUPPORT_NETBOX_PROTOCOL == 1
1509:irmp.c        **** 
1510:irmp.c        **** static const PROGMEM IRMP_PARAMETER netbox_param =
1511:irmp.c        **** {
1512:irmp.c        ****     IRMP_NETBOX_PROTOCOL,                                               // protocol:        ir prot
1513:irmp.c        ****     NETBOX_PULSE_LEN,                                                   // pulse_1_len_min: minimum
1514:irmp.c        ****     NETBOX_PULSE_REST_LEN,                                              // pulse_1_len_max: maximum
1515:irmp.c        ****     NETBOX_PAUSE_LEN,                                                   // pause_1_len_min: minimum
1516:irmp.c        ****     NETBOX_PAUSE_REST_LEN,                                              // pause_1_len_max: maximum
1517:irmp.c        ****     NETBOX_PULSE_LEN,                                                   // pulse_0_len_min: minimum
1518:irmp.c        ****     NETBOX_PULSE_REST_LEN,                                              // pulse_0_len_max: maximum
1519:irmp.c        ****     NETBOX_PAUSE_LEN,                                                   // pause_0_len_min: minimum
1520:irmp.c        ****     NETBOX_PAUSE_REST_LEN,                                              // pause_0_len_max: maximum
1521:irmp.c        ****     NETBOX_ADDRESS_OFFSET,                                              // address_offset:  address
1522:irmp.c        ****     NETBOX_ADDRESS_OFFSET + NETBOX_ADDRESS_LEN,                         // address_end:     end of 
1523:irmp.c        ****     NETBOX_COMMAND_OFFSET,                                              // command_offset:  command
1524:irmp.c        ****     NETBOX_COMMAND_OFFSET + NETBOX_COMMAND_LEN,                         // command_end:     end of 
1525:irmp.c        ****     NETBOX_COMPLETE_DATA_LEN,                                           // complete_len:    complet
1526:irmp.c        ****     NETBOX_STOP_BIT,                                                    // stop_bit:        flag: f
1527:irmp.c        ****     NETBOX_LSB,                                                         // lsb_first:       flag: L
1528:irmp.c        ****     NETBOX_FLAGS                                                        // flags:           some fl
1529:irmp.c        **** };
1530:irmp.c        **** 
1531:irmp.c        **** #endif
1532:irmp.c        **** 
1533:irmp.c        **** #if IRMP_SUPPORT_LEGO_PROTOCOL == 1
1534:irmp.c        **** 
1535:irmp.c        **** static const PROGMEM IRMP_PARAMETER lego_param =
1536:irmp.c        **** {
1537:irmp.c        ****     IRMP_LEGO_PROTOCOL,                                                 // protocol:        ir prot
1538:irmp.c        ****     LEGO_PULSE_LEN_MIN,                                                 // pulse_1_len_min: minimum
1539:irmp.c        ****     LEGO_PULSE_LEN_MAX,                                                 // pulse_1_len_max: maximum
1540:irmp.c        ****     LEGO_1_PAUSE_LEN_MIN,                                               // pause_1_len_min: minimum
1541:irmp.c        ****     LEGO_1_PAUSE_LEN_MAX,                                               // pause_1_len_max: maximum
1542:irmp.c        ****     LEGO_PULSE_LEN_MIN,                                                 // pulse_0_len_min: minimum
1543:irmp.c        ****     LEGO_PULSE_LEN_MAX,                                                 // pulse_0_len_max: maximum
1544:irmp.c        ****     LEGO_0_PAUSE_LEN_MIN,                                               // pause_0_len_min: minimum
1545:irmp.c        ****     LEGO_0_PAUSE_LEN_MAX,                                               // pause_0_len_max: maximum
1546:irmp.c        ****     LEGO_ADDRESS_OFFSET,                                                // address_offset:  address
1547:irmp.c        ****     LEGO_ADDRESS_OFFSET + LEGO_ADDRESS_LEN,                             // address_end:     end of 
1548:irmp.c        ****     LEGO_COMMAND_OFFSET,                                                // command_offset:  command
1549:irmp.c        ****     LEGO_COMMAND_OFFSET + LEGO_COMMAND_LEN,                             // command_end:     end of 
1550:irmp.c        ****     LEGO_COMPLETE_DATA_LEN,                                             // complete_len:    complet
1551:irmp.c        ****     LEGO_STOP_BIT,                                                      // stop_bit:        flag: f
1552:irmp.c        ****     LEGO_LSB,                                                           // lsb_first:       flag: L
1553:irmp.c        ****     LEGO_FLAGS                                                          // flags:           some fl
1554:irmp.c        **** };
1555:irmp.c        **** 
1556:irmp.c        **** #endif
1557:irmp.c        **** 
1558:irmp.c        **** #if IRMP_SUPPORT_THOMSON_PROTOCOL == 1
1559:irmp.c        **** 
1560:irmp.c        **** static const PROGMEM IRMP_PARAMETER thomson_param =
1561:irmp.c        **** {
1562:irmp.c        ****     IRMP_THOMSON_PROTOCOL,                                              // protocol:        ir prot
1563:irmp.c        ****     THOMSON_PULSE_LEN_MIN,                                              // pulse_1_len_min: minimum
1564:irmp.c        ****     THOMSON_PULSE_LEN_MAX,                                              // pulse_1_len_max: maximum
1565:irmp.c        ****     THOMSON_1_PAUSE_LEN_MIN,                                            // pause_1_len_min: minimum
1566:irmp.c        ****     THOMSON_1_PAUSE_LEN_MAX,                                            // pause_1_len_max: maximum
1567:irmp.c        ****     THOMSON_PULSE_LEN_MIN,                                              // pulse_0_len_min: minimum
1568:irmp.c        ****     THOMSON_PULSE_LEN_MAX,                                              // pulse_0_len_max: maximum
1569:irmp.c        ****     THOMSON_0_PAUSE_LEN_MIN,                                            // pause_0_len_min: minimum
1570:irmp.c        ****     THOMSON_0_PAUSE_LEN_MAX,                                            // pause_0_len_max: maximum
1571:irmp.c        ****     THOMSON_ADDRESS_OFFSET,                                             // address_offset:  address
1572:irmp.c        ****     THOMSON_ADDRESS_OFFSET + THOMSON_ADDRESS_LEN,                       // address_end:     end of 
1573:irmp.c        ****     THOMSON_COMMAND_OFFSET,                                             // command_offset:  command
1574:irmp.c        ****     THOMSON_COMMAND_OFFSET + THOMSON_COMMAND_LEN,                       // command_end:     end of 
1575:irmp.c        ****     THOMSON_COMPLETE_DATA_LEN,                                          // complete_len:    complet
1576:irmp.c        ****     THOMSON_STOP_BIT,                                                   // stop_bit:        flag: f
1577:irmp.c        ****     THOMSON_LSB,                                                        // lsb_first:       flag: L
1578:irmp.c        ****     THOMSON_FLAGS                                                       // flags:           some fl
1579:irmp.c        **** };
1580:irmp.c        **** 
1581:irmp.c        **** #endif
1582:irmp.c        **** 
1583:irmp.c        **** #if IRMP_SUPPORT_BOSE_PROTOCOL == 1
1584:irmp.c        **** 
1585:irmp.c        **** static const PROGMEM IRMP_PARAMETER bose_param =
1586:irmp.c        **** {
1587:irmp.c        ****     IRMP_BOSE_PROTOCOL,                                                 // protocol:        ir prot
1588:irmp.c        ****     BOSE_PULSE_LEN_MIN,                                                 // pulse_1_len_min: minimum
1589:irmp.c        ****     BOSE_PULSE_LEN_MAX,                                                 // pulse_1_len_max: maximum
1590:irmp.c        ****     BOSE_1_PAUSE_LEN_MIN,                                               // pause_1_len_min: minimum
1591:irmp.c        ****     BOSE_1_PAUSE_LEN_MAX,                                               // pause_1_len_max: maximum
1592:irmp.c        ****     BOSE_PULSE_LEN_MIN,                                                 // pulse_0_len_min: minimum
1593:irmp.c        ****     BOSE_PULSE_LEN_MAX,                                                 // pulse_0_len_max: maximum
1594:irmp.c        ****     BOSE_0_PAUSE_LEN_MIN,                                               // pause_0_len_min: minimum
1595:irmp.c        ****     BOSE_0_PAUSE_LEN_MAX,                                               // pause_0_len_max: maximum
1596:irmp.c        ****     BOSE_ADDRESS_OFFSET,                                                // address_offset:  address
1597:irmp.c        ****     BOSE_ADDRESS_OFFSET + BOSE_ADDRESS_LEN,                             // address_end:     end of 
1598:irmp.c        ****     BOSE_COMMAND_OFFSET,                                                // command_offset:  command
1599:irmp.c        ****     BOSE_COMMAND_OFFSET + BOSE_COMMAND_LEN,                             // command_end:     end of 
1600:irmp.c        ****     BOSE_COMPLETE_DATA_LEN,                                             // complete_len:    complet
1601:irmp.c        ****     BOSE_STOP_BIT,                                                      // stop_bit:        flag: f
1602:irmp.c        ****     BOSE_LSB,                                                           // lsb_first:       flag: L
1603:irmp.c        ****     BOSE_FLAGS                                                          // flags:           some fl
1604:irmp.c        **** };
1605:irmp.c        **** 
1606:irmp.c        **** #endif
1607:irmp.c        **** 
1608:irmp.c        **** #if IRMP_SUPPORT_A1TVBOX_PROTOCOL == 1
1609:irmp.c        **** 
1610:irmp.c        **** static const PROGMEM IRMP_PARAMETER a1tvbox_param =
1611:irmp.c        **** {
1612:irmp.c        ****     IRMP_A1TVBOX_PROTOCOL,                                              // protocol:        ir prot
1613:irmp.c        **** 
1614:irmp.c        ****     A1TVBOX_BIT_PULSE_LEN_MIN,                                          // pulse_1_len_min: here: m
1615:irmp.c        ****     A1TVBOX_BIT_PULSE_LEN_MAX,                                          // pulse_1_len_max: here: m
1616:irmp.c        ****     A1TVBOX_BIT_PAUSE_LEN_MIN,                                          // pause_1_len_min: here: m
1617:irmp.c        ****     A1TVBOX_BIT_PAUSE_LEN_MAX,                                          // pause_1_len_max: here: m
1618:irmp.c        ****     0,                                                                  // pulse_0_len_min: here: n
1619:irmp.c        ****     0,                                                                  // pulse_0_len_max: here: n
1620:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
1621:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
1622:irmp.c        ****     A1TVBOX_ADDRESS_OFFSET,                                             // address_offset:  address
1623:irmp.c        ****     A1TVBOX_ADDRESS_OFFSET + A1TVBOX_ADDRESS_LEN,                       // address_end:     end of 
1624:irmp.c        ****     A1TVBOX_COMMAND_OFFSET,                                             // command_offset:  command
1625:irmp.c        ****     A1TVBOX_COMMAND_OFFSET + A1TVBOX_COMMAND_LEN,                       // command_end:     end of 
1626:irmp.c        ****     A1TVBOX_COMPLETE_DATA_LEN,                                          // complete_len:    complet
1627:irmp.c        ****     A1TVBOX_STOP_BIT,                                                   // stop_bit:        flag: f
1628:irmp.c        ****     A1TVBOX_LSB,                                                        // lsb_first:       flag: L
1629:irmp.c        ****     A1TVBOX_FLAGS                                                       // flags:           some fl
1630:irmp.c        **** };
1631:irmp.c        **** 
1632:irmp.c        **** #endif
1633:irmp.c        **** 
1634:irmp.c        **** #if IRMP_SUPPORT_ORTEK_PROTOCOL == 1
1635:irmp.c        **** 
1636:irmp.c        **** static const PROGMEM IRMP_PARAMETER ortek_param =
1637:irmp.c        **** {
1638:irmp.c        ****     IRMP_ORTEK_PROTOCOL,                                                // protocol:        ir prot
1639:irmp.c        **** 
1640:irmp.c        ****     ORTEK_BIT_PULSE_LEN_MIN,                                            // pulse_1_len_min: here: m
1641:irmp.c        ****     ORTEK_BIT_PULSE_LEN_MAX,                                            // pulse_1_len_max: here: m
1642:irmp.c        ****     ORTEK_BIT_PAUSE_LEN_MIN,                                            // pause_1_len_min: here: m
1643:irmp.c        ****     ORTEK_BIT_PAUSE_LEN_MAX,                                            // pause_1_len_max: here: m
1644:irmp.c        ****     0,                                                                  // pulse_0_len_min: here: n
1645:irmp.c        ****     0,                                                                  // pulse_0_len_max: here: n
1646:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
1647:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
1648:irmp.c        ****     ORTEK_ADDRESS_OFFSET,                                               // address_offset:  address
1649:irmp.c        ****     ORTEK_ADDRESS_OFFSET + ORTEK_ADDRESS_LEN,                           // address_end:     end of 
1650:irmp.c        ****     ORTEK_COMMAND_OFFSET,                                               // command_offset:  command
1651:irmp.c        ****     ORTEK_COMMAND_OFFSET + ORTEK_COMMAND_LEN,                           // command_end:     end of 
1652:irmp.c        ****     ORTEK_COMPLETE_DATA_LEN,                                            // complete_len:    complet
1653:irmp.c        ****     ORTEK_STOP_BIT,                                                     // stop_bit:        flag: f
1654:irmp.c        ****     ORTEK_LSB,                                                          // lsb_first:       flag: L
1655:irmp.c        ****     ORTEK_FLAGS                                                         // flags:           some fl
1656:irmp.c        **** };
1657:irmp.c        **** 
1658:irmp.c        **** #endif
1659:irmp.c        **** 
1660:irmp.c        **** #if IRMP_SUPPORT_ROOMBA_PROTOCOL == 1
1661:irmp.c        **** 
1662:irmp.c        **** static const PROGMEM IRMP_PARAMETER roomba_param =
1663:irmp.c        **** {
1664:irmp.c        ****     IRMP_ROOMBA_PROTOCOL,                                               // protocol:        ir prot
1665:irmp.c        ****     ROOMBA_1_PULSE_LEN_MIN,                                             // pulse_1_len_min: minimum
1666:irmp.c        ****     ROOMBA_1_PULSE_LEN_MAX,                                             // pulse_1_len_max: maximum
1667:irmp.c        ****     ROOMBA_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum
1668:irmp.c        ****     ROOMBA_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum
1669:irmp.c        ****     ROOMBA_0_PULSE_LEN_MIN,                                             // pulse_0_len_min: minimum
1670:irmp.c        ****     ROOMBA_0_PULSE_LEN_MAX,                                             // pulse_0_len_max: maximum
1671:irmp.c        ****     ROOMBA_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum
1672:irmp.c        ****     ROOMBA_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum
1673:irmp.c        ****     ROOMBA_ADDRESS_OFFSET,                                              // address_offset:  address
1674:irmp.c        ****     ROOMBA_ADDRESS_OFFSET + ROOMBA_ADDRESS_LEN,                         // address_end:     end of 
1675:irmp.c        ****     ROOMBA_COMMAND_OFFSET,                                              // command_offset:  command
1676:irmp.c        ****     ROOMBA_COMMAND_OFFSET + ROOMBA_COMMAND_LEN,                         // command_end:     end of 
1677:irmp.c        ****     ROOMBA_COMPLETE_DATA_LEN,                                           // complete_len:    complet
1678:irmp.c        ****     ROOMBA_STOP_BIT,                                                    // stop_bit:        flag: f
1679:irmp.c        ****     ROOMBA_LSB,                                                         // lsb_first:       flag: L
1680:irmp.c        ****     ROOMBA_FLAGS                                                        // flags:           some fl
1681:irmp.c        **** };
1682:irmp.c        **** 
1683:irmp.c        **** #endif
1684:irmp.c        **** 
1685:irmp.c        **** #if IRMP_SUPPORT_RCMM_PROTOCOL == 1
1686:irmp.c        **** 
1687:irmp.c        **** static const PROGMEM IRMP_PARAMETER rcmm_param =
1688:irmp.c        **** {
1689:irmp.c        ****     IRMP_RCMM32_PROTOCOL,                                               // protocol:        ir prot
1690:irmp.c        ****    
1691:irmp.c        ****     RCMM32_BIT_PULSE_LEN_MIN,                                           // pulse_1_len_min: here: m
1692:irmp.c        ****     RCMM32_BIT_PULSE_LEN_MAX,                                           // pulse_1_len_max: here: m
1693:irmp.c        ****     0,                                                                  // pause_1_len_min: here: m
1694:irmp.c        ****     0,                                                                  // pause_1_len_max: here: m
1695:irmp.c        ****     RCMM32_BIT_PULSE_LEN_MIN,                                           // pulse_0_len_min: here: n
1696:irmp.c        ****     RCMM32_BIT_PULSE_LEN_MAX,                                           // pulse_0_len_max: here: n
1697:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
1698:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
1699:irmp.c        ****     RCMM32_ADDRESS_OFFSET,                                              // address_offset:  address
1700:irmp.c        ****     RCMM32_ADDRESS_OFFSET + RCMM32_ADDRESS_LEN,                         // address_end:     end of 
1701:irmp.c        ****     RCMM32_COMMAND_OFFSET,                                              // command_offset:  command
1702:irmp.c        ****     RCMM32_COMMAND_OFFSET + RCMM32_COMMAND_LEN,                         // command_end:     end of 
1703:irmp.c        ****     RCMM32_COMPLETE_DATA_LEN,                                           // complete_len:    complet
1704:irmp.c        ****     RCMM32_STOP_BIT,                                                    // stop_bit:        flag: f
1705:irmp.c        ****     RCMM32_LSB,                                                         // lsb_first:       flag: L
1706:irmp.c        ****     RCMM32_FLAGS                                                        // flags:           some fl
1707:irmp.c        **** };
1708:irmp.c        **** 
1709:irmp.c        **** #endif
1710:irmp.c        **** 
1711:irmp.c        **** #if IRMP_SUPPORT_RADIO1_PROTOCOL == 1
1712:irmp.c        **** 
1713:irmp.c        **** static const PROGMEM IRMP_PARAMETER radio1_param =
1714:irmp.c        **** {
1715:irmp.c        ****     IRMP_RADIO1_PROTOCOL,                                               // protocol:        ir prot
1716:irmp.c        ****    
1717:irmp.c        ****     RADIO1_1_PULSE_LEN_MIN,                                             // pulse_1_len_min: minimum
1718:irmp.c        ****     RADIO1_1_PULSE_LEN_MAX,                                             // pulse_1_len_max: maximum
1719:irmp.c        ****     RADIO1_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum
1720:irmp.c        ****     RADIO1_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum
1721:irmp.c        ****     RADIO1_0_PULSE_LEN_MIN,                                             // pulse_0_len_min: minimum
1722:irmp.c        ****     RADIO1_0_PULSE_LEN_MAX,                                             // pulse_0_len_max: maximum
1723:irmp.c        ****     RADIO1_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum
1724:irmp.c        ****     RADIO1_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum
1725:irmp.c        ****     RADIO1_ADDRESS_OFFSET,                                              // address_offset:  address
1726:irmp.c        ****     RADIO1_ADDRESS_OFFSET + RADIO1_ADDRESS_LEN,                         // address_end:     end of 
1727:irmp.c        ****     RADIO1_COMMAND_OFFSET,                                              // command_offset:  command
1728:irmp.c        ****     RADIO1_COMMAND_OFFSET + RADIO1_COMMAND_LEN,                         // command_end:     end of 
1729:irmp.c        ****     RADIO1_COMPLETE_DATA_LEN,                                           // complete_len:    complet
1730:irmp.c        ****     RADIO1_STOP_BIT,                                                    // stop_bit:        flag: f
1731:irmp.c        ****     RADIO1_LSB,                                                         // lsb_first:       flag: L
1732:irmp.c        ****     RADIO1_FLAGS                                                        // flags:           some fl
1733:irmp.c        **** };
1734:irmp.c        **** 
1735:irmp.c        **** #endif
1736:irmp.c        **** 
1737:irmp.c        **** static uint8_t                              irmp_bit;                   // current bit position
1738:irmp.c        **** static IRMP_PARAMETER                       irmp_param;
1739:irmp.c        **** 
1740:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCO
1741:irmp.c        **** static IRMP_PARAMETER                       irmp_param2;
1742:irmp.c        **** #endif
1743:irmp.c        **** 
1744:irmp.c        **** static volatile uint8_t                     irmp_ir_detected = FALSE;
1745:irmp.c        **** static volatile uint8_t                     irmp_protocol;
1746:irmp.c        **** static volatile uint16_t                    irmp_address;
1747:irmp.c        **** static volatile uint16_t                    irmp_command;
1748:irmp.c        **** static volatile uint16_t                    irmp_id;                    // only used for SAMSUNG pr
1749:irmp.c        **** static volatile uint8_t                     irmp_flags;
1750:irmp.c        **** // static volatile uint8_t                  irmp_busy_flag;
1751:irmp.c        **** 
1752:irmp.c        **** #ifdef ANALYZE
1753:irmp.c        **** #define input(x)                            (x)
1754:irmp.c        **** static uint8_t                              IRMP_PIN;
1755:irmp.c        **** static uint8_t                              radio;
1756:irmp.c        **** #endif
1757:irmp.c        **** 
1758:irmp.c        **** /*-------------------------------------------------------------------------------------------------
1759:irmp.c        ****  *  Initialize IRMP decoder
1760:irmp.c        ****  *  @details  Configures IRMP input pin
1761:irmp.c        ****  *-------------------------------------------------------------------------------------------------
1762:irmp.c        ****  */
1763:irmp.c        **** #ifndef ANALYZE
1764:irmp.c        **** void
1765:irmp.c        **** irmp_init (void)
1766:irmp.c        **** {
 104               	LM0-.LFBB1
 105               	.LM0:
 106               	.LFBB1:
 107               	/* prologue: function */
 108               	/* frame size = 0 */
1767:irmp.c        **** #if defined(PIC_CCS) || defined(PIC_C18)                                // PIC: do nothing
1768:irmp.c        **** #elif defined (ARM_STM32)                                               // STM32
1769:irmp.c        ****    GPIO_InitTypeDef     GPIO_InitStructure;
1770:irmp.c        **** 
1771:irmp.c        ****    /* GPIOx clock enable */
1772:irmp.c        ****  #if defined (ARM_STM32L1XX)
1773:irmp.c        ****    RCC_AHBPeriphClockCmd(IRMP_PORT_RCC, ENABLE);
1774:irmp.c        ****  #elif defined (ARM_STM32F10X)
1775:irmp.c        ****    RCC_APB2PeriphClockCmd(IRMP_PORT_RCC, ENABLE);
1776:irmp.c        ****  #elif defined (ARM_STM32F4XX)
1777:irmp.c        ****    RCC_AHB1PeriphClockCmd(IRMP_PORT_RCC, ENABLE);
1778:irmp.c        ****  #endif
1779:irmp.c        **** 
1780:irmp.c        ****    /* GPIO Configuration */
1781:irmp.c        ****    GPIO_InitStructure.GPIO_Pin = IRMP_BIT;
1782:irmp.c        ****  #if defined (ARM_STM32L1XX) || defined (ARM_STM32F4XX)
1783:irmp.c        ****    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
1784:irmp.c        ****    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
1785:irmp.c        ****    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
1786:irmp.c        ****    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
1787:irmp.c        ****  #elif defined (ARM_STM32F10X)
1788:irmp.c        ****    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
1789:irmp.c        ****    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
1790:irmp.c        ****  #endif
1791:irmp.c        ****    GPIO_Init(IRMP_PORT, &GPIO_InitStructure);
1792:irmp.c        **** #elif defined(STELLARIS_ARM_CORTEX_M4)
1793:irmp.c        ****      // Enable the GPIO port
1794:irmp.c        ****      ROM_SysCtlPeripheralEnable(IRMP_PORT_PERIPH);
1795:irmp.c        **** 
1796:irmp.c        ****      // Set as an input
1797:irmp.c        ****      ROM_GPIODirModeSet(IRMP_PORT_BASE, IRMP_PORT_PIN, GPIO_DIR_MODE_IN);
1798:irmp.c        ****      ROM_GPIOPadConfigSet(IRMP_PORT_BASE, IRMP_PORT_PIN,
1799:irmp.c        ****                           GPIO_STRENGTH_2MA,
1800:irmp.c        ****                           GPIO_PIN_TYPE_STD_WPU);
1801:irmp.c        **** #else                                                                   // AVR
1802:irmp.c        ****     IRMP_PORT &= ~(1<<IRMP_BIT);                                        // deactivate pullup
 109               	bn	68,0,1802,.LM1-.LFBB1
 110               	.LM1:
 111 0000 2B98      		cbi 37-32,3
1803:irmp.c        ****     IRMP_DDR &= ~(1<<IRMP_BIT);                                         // set pin to input
 112               	tabn	68,0,1803,.LM2-.LFBB1
 113               	.LM2:
 114 0002 2398      		cbi 36-32,3
 115               	/* epilogue start */
1804:irmp.c        **** #endif
1805:irmp.c        **** 
1806:irmp.c        **** #if IRMP_LOGGING == 1
1807:irmp.c        ****     irmp_uart_init ();
1808:irmp.c        **** #endif
1809:irmp.c        **** }
 116               	abn	68,0,1809,.LM3-.LFBB1
 117               	.LM3:
 118 0004 0895      		ret
 120               	.Lscope1:
 123               	.global	irmp_get_data
 125               	irmp_get_data:
1810:irmp.c        **** #endif
1811:irmp.c        **** /*-------------------------------------------------------------------------------------------------
1812:irmp.c        ****  *  Get IRMP data
1813:irmp.c        ****  *  @details  gets decoded IRMP data
1814:irmp.c        ****  *  @param    pointer in order to store IRMP data
1815:irmp.c        ****  *  @return    TRUE: successful, FALSE: failed
1816:irmp.c        ****  *-------------------------------------------------------------------------------------------------
1817:irmp.c        ****  */
1818:irmp.c        **** uint8_t
1819:irmp.c        **** irmp_get_data (IRMP_DATA * irmp_data_p)
1820:irmp.c        **** {
 126               	,0,1820,.LM4-.LFBB2
 127               	.LM4:
 128               	.LFBB2:
 129               	/* prologue: function */
 130               	/* frame size = 0 */
 131 0006 FC01      		movw r30,r24
1821:irmp.c        ****     uint8_t   rtc = FALSE;
1822:irmp.c        **** 
1823:irmp.c        ****     if (irmp_ir_detected)
 132               	n	68,0,1823,.LM5-.LFBB2
 133               	.LM5:
 134 0008 8091 0000 		lds r24,irmp_ir_detected
 135 000c 8823      		tst r24
 136 000e 01F0      		breq .L5
1824:irmp.c        ****     {
1825:irmp.c        ****         switch (irmp_protocol)
 137               	bn	68,0,1825,.LM6-.LFBB2
 138               	.LM6:
 139 0010 8091 0000 		lds r24,irmp_protocol
 140 0014 8730      		cpi r24,lo8(7)
 141 0016 01F4      		brne .L6
1826:irmp.c        ****         {
1827:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
1828:irmp.c        ****             case IRMP_SAMSUNG_PROTOCOL:
1829:irmp.c        ****                 if ((irmp_command >> 8) == (~irmp_command & 0x00FF))
1830:irmp.c        ****                 {
1831:irmp.c        ****                     irmp_command &= 0xff;
1832:irmp.c        ****                     irmp_command |= irmp_id << 8;
1833:irmp.c        ****                     rtc = TRUE;
1834:irmp.c        ****                 }
1835:irmp.c        ****                 break;
1836:irmp.c        **** 
1837:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG48_PROTOCOL == 1
1838:irmp.c        ****             case IRMP_SAMSUNG48_PROTOCOL:
1839:irmp.c        ****                 irmp_command = (irmp_command & 0x00FF) | ((irmp_id & 0x00FF) << 8);
1840:irmp.c        ****                 rtc = TRUE;
1841:irmp.c        ****                 break;
1842:irmp.c        **** #endif
1843:irmp.c        **** #endif
1844:irmp.c        **** 
1845:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
1846:irmp.c        ****             case IRMP_NEC_PROTOCOL:
1847:irmp.c        ****                 if ((irmp_command >> 8) == (~irmp_command & 0x00FF))
1848:irmp.c        ****                 {
1849:irmp.c        ****                     irmp_command &= 0xff;
1850:irmp.c        ****                     rtc = TRUE;
1851:irmp.c        ****                 }
1852:irmp.c        ****                 else if (irmp_address == 0x87EE)
1853:irmp.c        ****                 {
1854:irmp.c        **** #ifdef ANALYZE
1855:irmp.c        ****                     ANALYZE_PRINTF ("Switching to APPLE protocol\n");
1856:irmp.c        **** #endif // ANALYZE
1857:irmp.c        ****                     irmp_protocol = IRMP_APPLE_PROTOCOL;
1858:irmp.c        ****                     irmp_address = (irmp_command & 0xFF00) >> 8;
1859:irmp.c        ****                     irmp_command &= 0x00FF;
1860:irmp.c        ****                     rtc = TRUE;
1861:irmp.c        ****                 }
1862:irmp.c        ****                 break;
1863:irmp.c        **** #endif
1864:irmp.c        **** #if IRMP_SUPPORT_BOSE_PROTOCOL == 1
1865:irmp.c        ****             case IRMP_BOSE_PROTOCOL:
1866:irmp.c        ****                 if ((irmp_command >> 8) == (~irmp_command & 0x00FF))
1867:irmp.c        ****                 {
1868:irmp.c        ****                     irmp_command &= 0xff;
1869:irmp.c        ****                     rtc = TRUE;
1870:irmp.c        ****                 }
1871:irmp.c        ****                 break;
1872:irmp.c        **** #endif
1873:irmp.c        **** #if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
1874:irmp.c        ****             case IRMP_SIEMENS_PROTOCOL:
1875:irmp.c        ****             case IRMP_RUWIDO_PROTOCOL:
1876:irmp.c        ****                 if (((irmp_command >> 1) & 0x0001) == (~irmp_command & 0x0001))
1877:irmp.c        ****                 {
1878:irmp.c        ****                     irmp_command >>= 1;
1879:irmp.c        ****                     rtc = TRUE;
1880:irmp.c        ****                 }
1881:irmp.c        ****                 break;
1882:irmp.c        **** #endif
1883:irmp.c        **** #if IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
1884:irmp.c        ****             case IRMP_KATHREIN_PROTOCOL:
1885:irmp.c        ****                 if (irmp_command != 0x0000)
1886:irmp.c        ****                 {
1887:irmp.c        ****                     rtc = TRUE;
1888:irmp.c        ****                 }
1889:irmp.c        ****                 break;
1890:irmp.c        **** #endif
1891:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1
1892:irmp.c        ****             case IRMP_RC5_PROTOCOL:
1893:irmp.c        ****                 irmp_address &= ~0x20;                              // clear toggle bit
 142               	bn	68,0,1893,.LM7-.LFBB2
 143               	.LM7:
 144 0018 8091 0000 		lds r24,irmp_address
 145 001c 9091 0000 		lds r25,(irmp_address)+1
 146 0020 8F7D      		andi r24,lo8(-33)
 147 0022 9093 0000 		sts (irmp_address)+1,r25
 148 0026 8093 0000 		sts irmp_address,r24
 149               	.L6:
1894:irmp.c        ****                 rtc = TRUE;
1895:irmp.c        ****                 break;
1896:irmp.c        **** #endif
1897:irmp.c        **** #if IRMP_SUPPORT_IR60_PROTOCOL == 1
1898:irmp.c        ****             case IRMP_IR60_PROTOCOL:
1899:irmp.c        ****                 if (irmp_command != 0x007d)                         // 0x007d (== 62<<1 + 1) is sta
1900:irmp.c        ****                 {
1901:irmp.c        ****                     rtc = TRUE;
1902:irmp.c        ****                 }
1903:irmp.c        ****                 else
1904:irmp.c        ****                 {
1905:irmp.c        **** #ifdef ANALYZE
1906:irmp.c        ****                     ANALYZE_PRINTF("Info IR60: got start instruction frame\n");
1907:irmp.c        **** #endif // ANALYZE
1908:irmp.c        ****                 }
1909:irmp.c        ****                 break;
1910:irmp.c        **** #endif
1911:irmp.c        **** #if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
1912:irmp.c        ****             case IRMP_RCCAR_PROTOCOL:
1913:irmp.c        ****                 // frame in irmp_data:
1914:irmp.c        ****                 // Bit 12 11 10 9  8  7  6  5  4  3  2  1  0
1915:irmp.c        ****                 //     V  D7 D6 D5 D4 D3 D2 D1 D0 A1 A0 C1 C0   //         10 9  8  7  6  5  4  3  
1916:irmp.c        ****                 irmp_address = (irmp_command & 0x000C) >> 2;    // addr:   0  0  0  0  0  0  0  0  
1917:irmp.c        ****                 irmp_command = ((irmp_command & 0x1000) >> 2) | // V-Bit:  V  0  0  0  0  0  0  0  
1918:irmp.c        ****                                ((irmp_command & 0x0003) << 8) | // C-Bits: 0  C1 C0 0  0  0  0  0  
1919:irmp.c        ****                                ((irmp_command & 0x0FF0) >> 4);  // D-Bits:          D7 D6 D5 D4 D3 
1920:irmp.c        ****                 rtc = TRUE;                                     // Summe:  V  C1 C0 D7 D6 D5 D4 D3 
1921:irmp.c        ****                 break;
1922:irmp.c        **** #endif
1923:irmp.c        **** 
1924:irmp.c        **** #if IRMP_SUPPORT_NETBOX_PROTOCOL == 1                           // squeeze code to 8 bit, upper bit
1925:irmp.c        ****             case IRMP_NETBOX_PROTOCOL:
1926:irmp.c        ****                 if (irmp_command & 0x1000)                      // last bit set?
1927:irmp.c        ****                 {
1928:irmp.c        ****                     if ((irmp_command & 0x1f) == 0x15)          // key pressed: 101 01 (LSB)
1929:irmp.c        ****                     {
1930:irmp.c        ****                         irmp_command >>= 5;
1931:irmp.c        ****                         irmp_command &= 0x7F;
1932:irmp.c        ****                         rtc = TRUE;
1933:irmp.c        ****                     }
1934:irmp.c        ****                     else if ((irmp_command & 0x1f) == 0x10)     // key released: 000 01 (LSB)
1935:irmp.c        ****                     {
1936:irmp.c        ****                         irmp_command >>= 5;
1937:irmp.c        ****                         irmp_command |= 0x80;
1938:irmp.c        ****                         rtc = TRUE;
1939:irmp.c        ****                     }
1940:irmp.c        ****                     else
1941:irmp.c        ****                     {
1942:irmp.c        **** #ifdef ANALYZE
1943:irmp.c        ****                         ANALYZE_PRINTF("error NETBOX: bit6/7 must be 0/1\n");
1944:irmp.c        **** #endif // ANALYZE
1945:irmp.c        ****                     }
1946:irmp.c        ****                 }
1947:irmp.c        ****                 else
1948:irmp.c        ****                 {
1949:irmp.c        **** #ifdef ANALYZE
1950:irmp.c        ****                     ANALYZE_PRINTF("error NETBOX: last bit not set\n");
1951:irmp.c        **** #endif // ANALYZE
1952:irmp.c        ****                 }
1953:irmp.c        ****                 break;
1954:irmp.c        **** #endif
1955:irmp.c        **** #if IRMP_SUPPORT_LEGO_PROTOCOL == 1
1956:irmp.c        ****             case IRMP_LEGO_PROTOCOL:
1957:irmp.c        ****             {
1958:irmp.c        ****                 uint8_t crc = 0x0F ^ ((irmp_command & 0xF000) >> 12) ^ ((irmp_command & 0x0F00) >> 
1959:irmp.c        **** 
1960:irmp.c        ****                 if ((irmp_command & 0x000F) == crc)
1961:irmp.c        ****                 {
1962:irmp.c        ****                     irmp_command >>= 4;
1963:irmp.c        ****                     rtc = TRUE;
1964:irmp.c        ****                 }
1965:irmp.c        ****                 else
1966:irmp.c        ****                 {
1967:irmp.c        **** #ifdef ANALYZE
1968:irmp.c        ****                     ANALYZE_PRINTF ("CRC error in LEGO protocol\n");
1969:irmp.c        **** #endif // ANALYZE
1970:irmp.c        ****                     // rtc = TRUE;                              // don't accept codes with CRC erro
1971:irmp.c        ****                 }
1972:irmp.c        ****                 break;
1973:irmp.c        ****             }
1974:irmp.c        **** #endif
1975:irmp.c        **** 
1976:irmp.c        ****             default:
1977:irmp.c        ****             {
1978:irmp.c        ****                 rtc = TRUE;
1979:irmp.c        ****                 break;
1980:irmp.c        ****             }
1981:irmp.c        ****         }
1982:irmp.c        **** 
1983:irmp.c        ****         if (rtc)
1984:irmp.c        ****         {
1985:irmp.c        ****             irmp_data_p->protocol = irmp_protocol;
 150               	68,0,1985,.LM8-.LFBB2
 151               	.LM8:
 152 002a 8091 0000 		lds r24,irmp_protocol
 153 002e 8083      		st Z,r24
1986:irmp.c        ****             irmp_data_p->address = irmp_address;
 154               	abn	68,0,1986,.LM9-.LFBB2
 155               	.LM9:
 156 0030 8091 0000 		lds r24,irmp_address
 157 0034 9091 0000 		lds r25,(irmp_address)+1
 158 0038 9283      		std Z+2,r25
 159 003a 8183      		std Z+1,r24
1987:irmp.c        ****             irmp_data_p->command = irmp_command;
 160               	n	68,0,1987,.LM10-.LFBB2
 161               	.LM10:
 162 003c 8091 0000 		lds r24,irmp_command
 163 0040 9091 0000 		lds r25,(irmp_command)+1
 164 0044 9483      		std Z+4,r25
 165 0046 8383      		std Z+3,r24
1988:irmp.c        ****             irmp_data_p->flags   = irmp_flags;
 166               	n	68,0,1988,.LM11-.LFBB2
 167               	.LM11:
 168 0048 8091 0000 		lds r24,irmp_flags
 169 004c 8583      		std Z+5,r24
1989:irmp.c        ****             irmp_command = 0;
 170               	abn	68,0,1989,.LM12-.LFBB2
 171               	.LM12:
 172 004e 1092 0000 		sts (irmp_command)+1,__zero_reg__
 173 0052 1092 0000 		sts irmp_command,__zero_reg__
1990:irmp.c        ****             irmp_address = 0;
 174               	abn	68,0,1990,.LM13-.LFBB2
 175               	.LM13:
 176 0056 1092 0000 		sts (irmp_address)+1,__zero_reg__
 177 005a 1092 0000 		sts irmp_address,__zero_reg__
1991:irmp.c        ****             irmp_flags   = 0;
 178               	abn	68,0,1991,.LM14-.LFBB2
 179               	.LM14:
 180 005e 1092 0000 		sts irmp_flags,__zero_reg__
1992:irmp.c        ****         }
1993:irmp.c        **** 
1994:irmp.c        ****         irmp_ir_detected = FALSE;
 181               	tabn	68,0,1994,.LM15-.LFBB2
 182               	.LM15:
 183 0062 1092 0000 		sts irmp_ir_detected,__zero_reg__
 184 0066 81E0      		ldi r24,lo8(1)
 185               	.L5:
1995:irmp.c        ****     }
1996:irmp.c        **** 
1997:irmp.c        ****     return rtc;
1998:irmp.c        **** }
 186               	bn	68,0,1998,.LM16-.LFBB2
 187               	.LM16:
 188 0068 0895      		ret
 193               	.Lscope2:
 197               	irmp_store_bit:
1999:irmp.c        **** 
2000:irmp.c        **** // uint8_t
2001:irmp.c        **** // irmp_is_busy (void)
2002:irmp.c        **** // {
2003:irmp.c        **** //     return irmp_busy_flag;
2004:irmp.c        **** // }
2005:irmp.c        **** 
2006:irmp.c        **** #if IRMP_USE_CALLBACK == 1
2007:irmp.c        **** void
2008:irmp.c        **** irmp_set_callback_ptr (void (*cb)(uint8_t))
2009:irmp.c        **** {
2010:irmp.c        ****     irmp_callback_ptr = cb;
2011:irmp.c        **** }
2012:irmp.c        **** #endif // IRMP_USE_CALLBACK == 1
2013:irmp.c        **** 
2014:irmp.c        **** // these statics must not be volatile, because they are only used by irmp_store_bit(), which is cal
2015:irmp.c        **** static uint16_t irmp_tmp_address;                                                       // ir addre
2016:irmp.c        **** static uint16_t irmp_tmp_command;                                                       // ir comma
2017:irmp.c        **** 
2018:irmp.c        **** #if (IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOC
2019:irmp.c        **** static uint16_t irmp_tmp_address2;                                                      // ir addre
2020:irmp.c        **** static uint16_t irmp_tmp_command2;                                                      // ir comma
2021:irmp.c        **** #endif
2022:irmp.c        **** 
2023:irmp.c        **** #if IRMP_SUPPORT_LGAIR_PROTOCOL == 1
2024:irmp.c        **** static uint16_t irmp_lgair_address;                                                     // ir addre
2025:irmp.c        **** static uint16_t irmp_lgair_command;                                                     // ir comma
2026:irmp.c        **** #endif
2027:irmp.c        **** 
2028:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
2029:irmp.c        **** static uint16_t irmp_tmp_id;                                                            // ir id (o
2030:irmp.c        **** #endif
2031:irmp.c        **** #if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
2032:irmp.c        **** static uint8_t  xor_check[6];                                                           // check ka
2033:irmp.c        **** static uint8_t  genre2;                                                                 // save gen
2034:irmp.c        **** #endif
2035:irmp.c        **** 
2036:irmp.c        **** #if IRMP_SUPPORT_ORTEK_PROTOCOL == 1
2037:irmp.c        **** static uint8_t  parity;                                                                 // number o
2038:irmp.c        **** #endif
2039:irmp.c        **** 
2040:irmp.c        **** /*-------------------------------------------------------------------------------------------------
2041:irmp.c        ****  *  store bit
2042:irmp.c        ****  *  @details  store bit in temp address or temp command
2043:irmp.c        ****  *  @param    value to store: 0 or 1
2044:irmp.c        ****  *-------------------------------------------------------------------------------------------------
2045:irmp.c        ****  */
2046:irmp.c        **** // verhindert, dass irmp_store_bit() inline compiliert wird:
2047:irmp.c        **** // static void irmp_store_bit (uint8_t) __attribute__ ((noinline));
2048:irmp.c        **** 
2049:irmp.c        **** static void
2050:irmp.c        **** irmp_store_bit (uint8_t value)
2051:irmp.c        **** {
 198               	,2051,.LM17-.LFBB3
 199               	.LM17:
 200               	.LFBB3:
 201               	/* prologue: function */
 202               	/* frame size = 0 */
 203 006a 982F      		mov r25,r24
2052:irmp.c        **** #if IRMP_SUPPORT_ORTEK_PROTOCOL == 1
2053:irmp.c        ****     if (irmp_param.protocol == IRMP_ORTEK_PROTOCOL)
2054:irmp.c        ****     {
2055:irmp.c        ****         if (irmp_bit < 14)
2056:irmp.c        ****         {
2057:irmp.c        ****             if (value)
2058:irmp.c        ****             {
2059:irmp.c        ****                 parity++;
2060:irmp.c        ****             }
2061:irmp.c        ****         }
2062:irmp.c        ****         else if (irmp_bit == 14)
2063:irmp.c        ****         {
2064:irmp.c        ****             if (value)                                                                             
2065:irmp.c        ****             {
2066:irmp.c        ****                 if (parity & 0x01)
2067:irmp.c        ****                 {
2068:irmp.c        ****                     parity = PARITY_CHECK_FAILED;
2069:irmp.c        ****                 }
2070:irmp.c        ****                 else
2071:irmp.c        ****                 {
2072:irmp.c        ****                     parity = PARITY_CHECK_OK;
2073:irmp.c        ****                 }
2074:irmp.c        ****             }
2075:irmp.c        ****             else
2076:irmp.c        ****             {
2077:irmp.c        ****                 if (parity & 0x01)                                                                 
2078:irmp.c        ****                 {
2079:irmp.c        ****                     parity = PARITY_CHECK_OK;
2080:irmp.c        ****                 }
2081:irmp.c        ****                 else
2082:irmp.c        ****                 {
2083:irmp.c        ****                     parity = PARITY_CHECK_FAILED;
2084:irmp.c        ****                 }
2085:irmp.c        ****             }
2086:irmp.c        ****         }
2087:irmp.c        ****     }
2088:irmp.c        **** #endif
2089:irmp.c        **** 
2090:irmp.c        **** #if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
2091:irmp.c        ****     if (irmp_bit == 0 && irmp_param.protocol == IRMP_GRUNDIG_PROTOCOL)
2092:irmp.c        ****     {
2093:irmp.c        ****         first_bit = value;
2094:irmp.c        ****     }
2095:irmp.c        ****     else
2096:irmp.c        **** #endif
2097:irmp.c        **** 
2098:irmp.c        ****     if (irmp_bit >= irmp_param.address_offset && irmp_bit < irmp_param.address_end)
 204               	n	68,0,2098,.LM18-.LFBB3
 205               	.LM18:
 206 006c 6091 0000 		lds r22,irmp_bit
 207 0070 7091 0000 		lds r23,irmp_param+9
 208 0074 6717      		cp r22,r23
 209 0076 00F0      		brlo .L10
 210 0078 8091 0000 		lds r24,irmp_param+10
 211 007c 6817      		cp r22,r24
 212 007e 00F4      		brsh .L10
2099:irmp.c        ****     {
2100:irmp.c        ****         if (irmp_param.lsb_first)
 213               	8,0,2100,.LM19-.LFBB3
 214               	.LM19:
 215 0080 8091 0000 		lds r24,irmp_param+15
 216 0084 292F      		mov r18,r25
 217 0086 30E0      		ldi r19,lo8(0)
 218 0088 4091 0000 		lds r20,irmp_tmp_address
 219 008c 5091 0000 		lds r21,(irmp_tmp_address)+1
 220 0090 8823      		tst r24
 221 0092 01F0      		breq .L11
2101:irmp.c        ****         {
2102:irmp.c        ****             irmp_tmp_address |= (((uint16_t) (value)) << (irmp_bit - irmp_param.address_offset));  
 222               	8,0,2102,.LM20-.LFBB3
 223               	.LM20:
 224 0094 862F      		mov r24,r22
 225 0096 90E0      		ldi r25,lo8(0)
 226 0098 871B      		sub r24,r23
 227 009a 9109      		sbc r25,__zero_reg__
 228 009c 00C0      		rjmp 2f
 229 009e 220F      	1:	lsl r18
 230 00a0 331F      		rol r19
 231 00a2 8A95      	2:	dec r24
 232 00a4 02F4      		brpl 1b
 233 00a6 422B      		or r20,r18
 234 00a8 532B      		or r21,r19
 235 00aa 5093 0000 		sts (irmp_tmp_address)+1,r21
 236 00ae 4093 0000 		sts irmp_tmp_address,r20
 237 00b2 00C0      		rjmp .L12
 238               	.L11:
2103:irmp.c        ****         }
2104:irmp.c        ****         else
2105:irmp.c        ****         {
2106:irmp.c        ****             irmp_tmp_address <<= 1;
2107:irmp.c        ****             irmp_tmp_address |= value;
 239               	,.LM21-.LFBB3
 240               	.LM21:
 241 00b4 440F      		lsl r20
 242 00b6 551F      		rol r21
 243 00b8 242B      		or r18,r20
 244 00ba 352B      		or r19,r21
 245 00bc 3093 0000 		sts (irmp_tmp_address)+1,r19
 246 00c0 2093 0000 		sts irmp_tmp_address,r18
 247 00c4 00C0      		rjmp .L12
 248               	.L10:
2108:irmp.c        ****         }
2109:irmp.c        ****     }
2110:irmp.c        ****     else if (irmp_bit >= irmp_param.command_offset && irmp_bit < irmp_param.command_end)
 249               	,0,2110,.LM22-.LFBB3
 250               	.LM22:
 251 00c6 7091 0000 		lds r23,irmp_param+11
 252 00ca 6717      		cp r22,r23
 253 00cc 00F0      		brlo .L12
 254 00ce 8091 0000 		lds r24,irmp_param+12
 255 00d2 6817      		cp r22,r24
 256 00d4 00F4      		brsh .L12
2111:irmp.c        ****     {
2112:irmp.c        ****         if (irmp_param.lsb_first)
 257               	68,0,2112,.LM23-.LFBB3
 258               	.LM23:
 259 00d6 8091 0000 		lds r24,irmp_param+15
 260 00da 292F      		mov r18,r25
 261 00dc 30E0      		ldi r19,lo8(0)
 262 00de 4091 0000 		lds r20,irmp_tmp_command
 263 00e2 5091 0000 		lds r21,(irmp_tmp_command)+1
 264 00e6 8823      		tst r24
 265 00e8 01F0      		breq .L13
2113:irmp.c        ****         {
2114:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG48_PROTOCOL == 1
2115:irmp.c        ****             if (irmp_param.protocol == IRMP_SAMSUNG48_PROTOCOL && irmp_bit >= 32)
2116:irmp.c        ****             {
2117:irmp.c        ****                 irmp_tmp_id |= (((uint16_t) (value)) << (irmp_bit - 32));   // CV wants cast
2118:irmp.c        ****             }
2119:irmp.c        ****             else
2120:irmp.c        **** #endif
2121:irmp.c        ****             {
2122:irmp.c        ****                 irmp_tmp_command |= (((uint16_t) (value)) << (irmp_bit - irmp_param.command_offset)
 266               	8,0,2122,.LM24-.LFBB3
 267               	.LM24:
 268 00ea 862F      		mov r24,r22
 269 00ec 90E0      		ldi r25,lo8(0)
 270 00ee 871B      		sub r24,r23
 271 00f0 9109      		sbc r25,__zero_reg__
 272 00f2 00C0      		rjmp 2f
 273 00f4 220F      	1:	lsl r18
 274 00f6 331F      		rol r19
 275 00f8 8A95      	2:	dec r24
 276 00fa 02F4      		brpl 1b
 277 00fc 422B      		or r20,r18
 278 00fe 532B      		or r21,r19
 279 0100 5093 0000 		sts (irmp_tmp_command)+1,r21
 280 0104 4093 0000 		sts irmp_tmp_command,r20
 281 0108 00C0      		rjmp .L12
 282               	.L13:
2123:irmp.c        ****             }
2124:irmp.c        ****         }
2125:irmp.c        ****         else
2126:irmp.c        ****         {
2127:irmp.c        ****             irmp_tmp_command <<= 1;
2128:irmp.c        ****             irmp_tmp_command |= value;
 283               	,.LM25-.LFBB3
 284               	.LM25:
 285 010a 440F      		lsl r20
 286 010c 551F      		rol r21
 287 010e 242B      		or r18,r20
 288 0110 352B      		or r19,r21
 289 0112 3093 0000 		sts (irmp_tmp_command)+1,r19
 290 0116 2093 0000 		sts irmp_tmp_command,r18
 291               	.L12:
2129:irmp.c        ****         }
2130:irmp.c        ****     }
2131:irmp.c        **** 
2132:irmp.c        **** #if IRMP_SUPPORT_LGAIR_PROTOCOL == 1
2133:irmp.c        ****     if (irmp_param.protocol == IRMP_NEC_PROTOCOL || irmp_param.protocol == IRMP_NEC42_PROTOCOL)
2134:irmp.c        ****     {
2135:irmp.c        ****         if (irmp_bit < 8)
2136:irmp.c        ****         {
2137:irmp.c        ****             irmp_lgair_address <<= 1;                                                              
2138:irmp.c        ****             irmp_lgair_address |= value;
2139:irmp.c        ****         }
2140:irmp.c        ****         else if (irmp_bit < 24)
2141:irmp.c        ****         {
2142:irmp.c        ****             irmp_lgair_command <<= 1;                                                              
2143:irmp.c        ****             irmp_lgair_command |= value;
2144:irmp.c        ****         }
2145:irmp.c        ****     }
2146:irmp.c        ****     // NO else!
2147:irmp.c        **** #endif
2148:irmp.c        **** 
2149:irmp.c        **** #if IRMP_SUPPORT_NEC42_PROTOCOL == 1
2150:irmp.c        ****     if (irmp_param.protocol == IRMP_NEC42_PROTOCOL && irmp_bit >= 13 && irmp_bit < 26)
2151:irmp.c        ****     {
2152:irmp.c        ****         irmp_tmp_address2 |= (((uint16_t) (value)) << (irmp_bit - 13));                            
2153:irmp.c        ****     }
2154:irmp.c        ****     else
2155:irmp.c        **** #endif
2156:irmp.c        **** 
2157:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
2158:irmp.c        ****     if (irmp_param.protocol == IRMP_SAMSUNG_PROTOCOL && irmp_bit >= SAMSUNG_ID_OFFSET && irmp_bit <
2159:irmp.c        ****     {
2160:irmp.c        ****         irmp_tmp_id |= (((uint16_t) (value)) << (irmp_bit - SAMSUNG_ID_OFFSET));                   
2161:irmp.c        ****     }
2162:irmp.c        ****     else
2163:irmp.c        **** #endif
2164:irmp.c        **** 
2165:irmp.c        **** #if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
2166:irmp.c        ****     if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL)
2167:irmp.c        ****     {
2168:irmp.c        ****         if (irmp_bit >= 20 && irmp_bit < 24)
2169:irmp.c        ****         {
2170:irmp.c        ****             irmp_tmp_command |= (((uint16_t) (value)) << (irmp_bit - 8));       // store 4 system b
2171:irmp.c        ****         }
2172:irmp.c        ****         else if (irmp_bit >= 24 && irmp_bit < 28)
2173:irmp.c        ****         {
2174:irmp.c        ****             genre2 |= (((uint8_t) (value)) << (irmp_bit - 20));                 // store 4 system b
2175:irmp.c        ****         }
2176:irmp.c        **** 
2177:irmp.c        ****         if (irmp_bit < KASEIKYO_COMPLETE_DATA_LEN)
2178:irmp.c        ****         {
2179:irmp.c        ****             if (value)
2180:irmp.c        ****             {
2181:irmp.c        ****                 xor_check[irmp_bit / 8] |= 1 << (irmp_bit % 8);
2182:irmp.c        ****             }
2183:irmp.c        ****             else
2184:irmp.c        ****             {
2185:irmp.c        ****                 xor_check[irmp_bit / 8] &= ~(1 << (irmp_bit % 8));
2186:irmp.c        ****             }
2187:irmp.c        ****         }
2188:irmp.c        ****     }
2189:irmp.c        ****     else
2190:irmp.c        **** #endif
2191:irmp.c        ****     {
2192:irmp.c        ****         ;
2193:irmp.c        ****     }
2194:irmp.c        **** 
2195:irmp.c        ****     irmp_bit++;
 292               	8,0,2195,.LM26-.LFBB3
 293               	.LM26:
 294 011a 6F5F      		subi r22,lo8(-(1))
 295 011c 6093 0000 		sts irmp_bit,r22
 296               	/* epilogue start */
2196:irmp.c        **** }
 297               	bn	68,0,2196,.LM27-.LFBB3
 298               	.LM27:
 299 0120 0895      		ret
 301               	.Lscope3:
 303               	.global	irmp_ISR
 305               	irmp_ISR:
2197:irmp.c        **** 
2198:irmp.c        **** /*-------------------------------------------------------------------------------------------------
2199:irmp.c        ****  *  store bit
2200:irmp.c        ****  *  @details  store bit in temp address or temp command
2201:irmp.c        ****  *  @param    value to store: 0 or 1
2202:irmp.c        ****  *-------------------------------------------------------------------------------------------------
2203:irmp.c        ****  */
2204:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCO
2205:irmp.c        **** static void
2206:irmp.c        **** irmp_store_bit2 (uint8_t value)
2207:irmp.c        **** {
2208:irmp.c        ****     uint8_t irmp_bit2;
2209:irmp.c        **** 
2210:irmp.c        ****     if (irmp_param.protocol)
2211:irmp.c        ****     {
2212:irmp.c        ****         irmp_bit2 = irmp_bit - 2;
2213:irmp.c        ****     }
2214:irmp.c        ****     else
2215:irmp.c        ****     {
2216:irmp.c        ****         irmp_bit2 = irmp_bit - 1;
2217:irmp.c        ****     }
2218:irmp.c        **** 
2219:irmp.c        ****     if (irmp_bit2 >= irmp_param2.address_offset && irmp_bit2 < irmp_param2.address_end)
2220:irmp.c        ****     {
2221:irmp.c        ****         irmp_tmp_address2 |= (((uint16_t) (value)) << (irmp_bit2 - irmp_param2.address_offset));   
2222:irmp.c        ****     }
2223:irmp.c        ****     else if (irmp_bit2 >= irmp_param2.command_offset && irmp_bit2 < irmp_param2.command_end)
2224:irmp.c        ****     {
2225:irmp.c        ****         irmp_tmp_command2 |= (((uint16_t) (value)) << (irmp_bit2 - irmp_param2.command_offset));   
2226:irmp.c        ****     }
2227:irmp.c        **** }
2228:irmp.c        **** #endif // IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_P
2229:irmp.c        **** 
2230:irmp.c        **** /*-------------------------------------------------------------------------------------------------
2231:irmp.c        ****  *  ISR routine
2232:irmp.c        ****  *  @details  ISR routine, called 10000 times per second
2233:irmp.c        ****  *-------------------------------------------------------------------------------------------------
2234:irmp.c        ****  */
2235:irmp.c        **** uint8_t
2236:irmp.c        **** irmp_ISR (void)
2237:irmp.c        **** {
 306               	8,0,2237,.LM28-.LFBB4
 307               	.LM28:
 308               	.LFBB4:
 309               	/* prologue: function */
 310               	/* frame size = 0 */
2238:irmp.c        ****     static uint8_t      irmp_start_bit_detected;                                // flag: start bit 
2239:irmp.c        ****     static uint8_t      wait_for_space;                                         // flag: wait for d
2240:irmp.c        ****     static uint8_t      wait_for_start_space;                                   // flag: wait for s
2241:irmp.c        ****     static uint8_t      irmp_pulse_time;                                        // count bit time f
2242:irmp.c        ****     static PAUSE_LEN    irmp_pause_time;                                        // count bit time f
2243:irmp.c        ****     static uint16_t     last_irmp_address = 0xFFFF;                             // save last irmp a
2244:irmp.c        ****     static uint16_t     last_irmp_command = 0xFFFF;                             // save last irmp c
2245:irmp.c        ****     static uint16_t     key_repetition_len;                                     // SIRCS repeats fr
2246:irmp.c        ****     static uint8_t      repetition_frame_number;
2247:irmp.c        **** #if IRMP_SUPPORT_DENON_PROTOCOL == 1
2248:irmp.c        ****     static uint16_t     last_irmp_denon_command;                                // save last irmp c
2249:irmp.c        ****     static uint16_t     denon_repetition_len = 0xFFFF;                          // denon repetition
2250:irmp.c        **** #endif
2251:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1
2252:irmp.c        ****     static uint8_t      rc5_cmd_bit6;                                           // bit 6 of RC5 com
2253:irmp.c        **** #endif
2254:irmp.c        **** #if IRMP_SUPPORT_MANCHESTER == 1
2255:irmp.c        ****     static PAUSE_LEN    last_pause;                                             // last pause value
2256:irmp.c        **** #endif
2257:irmp.c        **** #if IRMP_SUPPORT_MANCHESTER == 1 || IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
2258:irmp.c        ****     static uint8_t      last_value;                                             // last bit value
2259:irmp.c        **** #endif
2260:irmp.c        ****     uint8_t             irmp_input;                                             // input value
2261:irmp.c        **** 
2262:irmp.c        **** #ifdef ANALYZE
2263:irmp.c        ****     time_counter++;
2264:irmp.c        **** #endif // ANALYZE
2265:irmp.c        **** 
2266:irmp.c        ****     irmp_input = input(IRMP_PIN);
 311               	bn	68,0,2266,.LM29-.LFBB4
 312               	.LM29:
 313 0122 93B1      		in r25,35-32
2267:irmp.c        **** 
2268:irmp.c        **** #if IRMP_USE_CALLBACK == 1
2269:irmp.c        ****     if (irmp_callback_ptr)
2270:irmp.c        ****     {
2271:irmp.c        ****         static uint8_t last_inverted_input;
2272:irmp.c        **** 
2273:irmp.c        ****         if (last_inverted_input != !irmp_input)
2274:irmp.c        ****         {
2275:irmp.c        ****             (*irmp_callback_ptr) (! irmp_input);
2276:irmp.c        ****             last_inverted_input = !irmp_input;
2277:irmp.c        ****         }
2278:irmp.c        ****     }
2279:irmp.c        **** #endif // IRMP_USE_CALLBACK == 1
2280:irmp.c        **** 
2281:irmp.c        ****     irmp_log(irmp_input);                                                       // log ir signal, i
2282:irmp.c        **** 
2283:irmp.c        ****     if (! irmp_ir_detected)                                                     // ir code already 
 314               	tabn	68,0,2283,.LM30-.LFBB4
 315               	.LM30:
 316 0124 8091 0000 		lds r24,irmp_ir_detected
 317 0128 8823      		tst r24
 318 012a 01F0      		breq .+2
 319 012c 00C0      		rjmp .L16
 321               	.LM31:
 322 012e 292F      		mov r18,r25
 323 0130 2870      		andi r18,lo8(8)
2284:irmp.c        ****     {                                                                           // no...
2285:irmp.c        ****         if (! irmp_start_bit_detected)                                          // start bit detect
 324               	,0,2285,.LM32-.LFBB4
 325               	.LM32:
 326 0132 8091 0000 		lds r24,irmp_start_bit_detected.1725
 327 0136 8823      		tst r24
 328 0138 01F4      		brne .L17
 329 013a 9091 0000 		lds r25,irmp_pulse_time.1728
2286:irmp.c        ****         {                                                                       // no...
2287:irmp.c        ****             if (! irmp_input)                                                   // receiving burst?
 330               	n	68,0,2287,.LM33-.LFBB4
 331               	.LM33:
 332 013e 2223      		tst r18
 333 0140 01F4      		brne .L18
2288:irmp.c        ****             {                                                                   // yes...
2289:irmp.c        **** //              irmp_busy_flag = TRUE;
2290:irmp.c        **** #ifdef ANALYZE
2291:irmp.c        ****                 if (! irmp_pulse_time)
2292:irmp.c        ****                 {
2293:irmp.c        ****                     ANALYZE_PRINTF("%8.3fms [starting pulse]\n", (double) (time_counter * 1000) / F
2294:irmp.c        ****                 }
2295:irmp.c        **** #endif // ANALYZE
2296:irmp.c        ****                 irmp_pulse_time++;                                              // increment counte
 334               	abn	68,0,2296,.LM34-.LFBB4
 335               	.LM34:
 336 0142 9F5F      		subi r25,lo8(-(1))
 337 0144 9093 0000 		sts irmp_pulse_time.1728,r25
 338 0148 00C0      		rjmp .L16
 339               	.L18:
2297:irmp.c        ****             }
2298:irmp.c        ****             else
2299:irmp.c        ****             {                                                                   // no...
2300:irmp.c        ****                 if (irmp_pulse_time)                                            // it's dark....
 340               	n	68,0,2300,.LM35-.LFBB4
 341               	.LM35:
 342 014a 9923      		tst r25
 343 014c 01F0      		breq .L19
2301:irmp.c        ****                 {                                                               // set flags for co
2302:irmp.c        ****                     irmp_start_bit_detected = 1;
 344               	abn	68,0,2302,.LM36-.LFBB4
 345               	.LM36:
 346 014e 91E0      		ldi r25,lo8(1)
 347 0150 9093 0000 		sts irmp_start_bit_detected.1725,r25
2303:irmp.c        ****                     wait_for_start_space    = 1;
 348               	abn	68,0,2303,.LM37-.LFBB4
 349               	.LM37:
 350 0154 9093 0000 		sts wait_for_start_space.1727,r25
2304:irmp.c        ****                     wait_for_space          = 0;
 351               	tabn	68,0,2304,.LM38-.LFBB4
 352               	.LM38:
 353 0158 1092 0000 		sts wait_for_space.1726,__zero_reg__
2305:irmp.c        ****                     irmp_tmp_command        = 0;
 354               	tabn	68,0,2305,.LM39-.LFBB4
 355               	.LM39:
 356 015c 1092 0000 		sts (irmp_tmp_command)+1,__zero_reg__
 357 0160 1092 0000 		sts irmp_tmp_command,__zero_reg__
2306:irmp.c        ****                     irmp_tmp_address        = 0;
 358               	abn	68,0,2306,.LM40-.LFBB4
 359               	.LM40:
 360 0164 1092 0000 		sts (irmp_tmp_address)+1,__zero_reg__
 361 0168 1092 0000 		sts irmp_tmp_address,__zero_reg__
2307:irmp.c        **** #if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
2308:irmp.c        ****                     genre2                  = 0;
2309:irmp.c        **** #endif
2310:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
2311:irmp.c        ****                     irmp_tmp_id = 0;
2312:irmp.c        **** #endif
2313:irmp.c        **** 
2314:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCO
2315:irmp.c        ****                     irmp_tmp_command2       = 0;
2316:irmp.c        ****                     irmp_tmp_address2       = 0;
2317:irmp.c        **** #endif
2318:irmp.c        **** #if IRMP_SUPPORT_LGAIR_PROTOCOL == 1
2319:irmp.c        ****                     irmp_lgair_command      = 0;
2320:irmp.c        ****                     irmp_lgair_address      = 0;
2321:irmp.c        **** #endif
2322:irmp.c        ****                     irmp_bit                = 0xff;
 362               	abn	68,0,2322,.LM41-.LFBB4
 363               	.LM41:
 364 016c 8FEF      		ldi r24,lo8(-1)
 365 016e 8093 0000 		sts irmp_bit,r24
2323:irmp.c        ****                     irmp_pause_time         = 1;                                // 1st pause: set t
 366               	abn	68,0,2323,.LM42-.LFBB4
 367               	.LM42:
 368 0172 9093 0000 		sts irmp_pause_time.1729,r25
2324:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1
2325:irmp.c        ****                     rc5_cmd_bit6            = 0;                                // fm 2010-03-07: b
 369               	tabn	68,0,2325,.LM43-.LFBB4
 370               	.LM43:
 371 0176 1092 0000 		sts rc5_cmd_bit6.1734,__zero_reg__
 372 017a 00C0      		rjmp .L16
 373               	.L19:
2326:irmp.c        **** #endif
2327:irmp.c        ****                 }
2328:irmp.c        ****                 else
2329:irmp.c        ****                 {
2330:irmp.c        ****                     if (key_repetition_len < 0xFFFF)                            // avoid overflow o
 374               	bn	68,0,2330,.LM44-.LFBB4
 375               	.LM44:
 376 017c 8091 0000 		lds r24,key_repetition_len.1732
 377 0180 9091 0000 		lds r25,(key_repetition_len.1732)+1
 378 0184 2FEF      		ldi r18,hi8(-1)
 379 0186 8F3F      		cpi r24,lo8(-1)
 380 0188 9207      		cpc r25,r18
 381 018a 01F4      		brne .+2
 382 018c 00C0      		rjmp .L16
2331:irmp.c        ****                     {
2332:irmp.c        ****                         key_repetition_len++;
 383               	8,0,2332,.LM45-.LFBB4
 384               	.LM45:
 385 018e 0196      		adiw r24,1
 386 0190 9093 0000 		sts (key_repetition_len.1732)+1,r25
 387 0194 8093 0000 		sts key_repetition_len.1732,r24
 388 0198 00C0      		rjmp .L16
 389               	.L17:
2333:irmp.c        **** 
2334:irmp.c        **** #if IRMP_SUPPORT_DENON_PROTOCOL == 1
2335:irmp.c        ****                         if (denon_repetition_len < 0xFFFF)                      // avoid overflow o
2336:irmp.c        ****                         {
2337:irmp.c        ****                             denon_repetition_len++;
2338:irmp.c        **** 
2339:irmp.c        ****                             if (denon_repetition_len >= DENON_AUTO_REPETITION_PAUSE_LEN && last_irm
2340:irmp.c        ****                             {
2341:irmp.c        **** #ifdef ANALYZE
2342:irmp.c        ****                                 ANALYZE_PRINTF ("%8.3fms warning: did not receive inverted command 
2343:irmp.c        ****                                                 (double) (time_counter * 1000) / F_INTERRUPTS);
2344:irmp.c        **** #endif // ANALYZE
2345:irmp.c        ****                                 last_irmp_denon_command = 0;
2346:irmp.c        ****                                 denon_repetition_len = 0xFFFF;
2347:irmp.c        ****                             }
2348:irmp.c        ****                         }
2349:irmp.c        **** #endif // IRMP_SUPPORT_DENON_PROTOCOL == 1
2350:irmp.c        ****                     }
2351:irmp.c        ****                 }
2352:irmp.c        ****             }
2353:irmp.c        ****         }
2354:irmp.c        ****         else
2355:irmp.c        ****         {
2356:irmp.c        ****             if (wait_for_start_space)                                           // we have received
 390               		68,0,2356,.LM46-.LFBB4
 391               	.LM46:
 392 019a 8091 0000 		lds r24,wait_for_start_space.1727
 393 019e 8823      		tst r24
 394 01a0 01F4      		brne .+2
 395 01a2 00C0      		rjmp .L20
2357:irmp.c        ****             {                                                                   // ...and are count
2358:irmp.c        ****                 if (irmp_input)                                                 // still dark?
 396               	n	68,0,2358,.LM47-.LFBB4
 397               	.LM47:
 398 01a4 2223      		tst r18
 399 01a6 01F0      		breq .L21
2359:irmp.c        ****                 {                                                               // yes
2360:irmp.c        ****                     irmp_pause_time++;                                          // increment counte
 400               	abn	68,0,2360,.LM48-.LFBB4
 401               	.LM48:
 402 01a8 8091 0000 		lds r24,irmp_pause_time.1729
 403 01ac 8F5F      		subi r24,lo8(-(1))
 404 01ae 8093 0000 		sts irmp_pause_time.1729,r24
2361:irmp.c        **** 
2362:irmp.c        **** #if IRMP_SUPPORT_NIKON_PROTOCOL == 1
2363:irmp.c        ****                     if (((irmp_pulse_time < NIKON_START_BIT_PULSE_LEN_MIN || irmp_pulse_time > NIKO
2364:irmp.c        ****                          irmp_pause_time > IRMP_TIMEOUT_NIKON_LEN)
2365:irmp.c        **** #else
2366:irmp.c        ****                     if (irmp_pause_time > IRMP_TIMEOUT_LEN)                     // timeout?
 405               	bn	68,0,2366,.LM49-.LFBB4
 406               	.LM49:
 407 01b2 8C39      		cpi r24,lo8(-100)
 408 01b4 00F4      		brsh .+2
 409 01b6 00C0      		rjmp .L22
 410 01b8 00C0      		rjmp .L38
 411               	.L21:
 412               	.LBB2:
2367:irmp.c        **** #endif
2368:irmp.c        ****                     {                                                           // yes...
2369:irmp.c        **** #if IRMP_SUPPORT_JVC_PROTOCOL == 1
2370:irmp.c        ****                         if (irmp_protocol == IRMP_JVC_PROTOCOL)                 // don't show eror 
2371:irmp.c        ****                         {
2372:irmp.c        ****                             ;
2373:irmp.c        ****                         }
2374:irmp.c        ****                         else
2375:irmp.c        **** #endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
2376:irmp.c        ****                         {
2377:irmp.c        **** #ifdef ANALYZE
2378:irmp.c        ****                             ANALYZE_PRINTF ("%8.3fms error 1: pause after start bit pulse %d too lo
2379:irmp.c        ****                             ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
2380:irmp.c        **** #endif // ANALYZE
2381:irmp.c        ****                         }
2382:irmp.c        **** 
2383:irmp.c        ****                         irmp_start_bit_detected = 0;                            // reset flags, let
2384:irmp.c        ****                         irmp_pulse_time         = 0;
2385:irmp.c        ****                         irmp_pause_time         = 0;
2386:irmp.c        ****                     }
2387:irmp.c        ****                 }
2388:irmp.c        ****                 else
2389:irmp.c        ****                 {                                                               // receiving first 
2390:irmp.c        ****                     IRMP_PARAMETER * irmp_param_p;
2391:irmp.c        ****                     irmp_param_p = (IRMP_PARAMETER *) 0;
2392:irmp.c        **** 
2393:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCO
2394:irmp.c        ****                     irmp_param2.protocol = 0;
2395:irmp.c        **** #endif
2396:irmp.c        **** 
2397:irmp.c        **** #ifdef ANALYZE
2398:irmp.c        ****                     ANALYZE_PRINTF ("%8.3fms [start-bit: pulse = %2d, pause = %2d]\n", (double) (ti
2399:irmp.c        **** #endif // ANALYZE
2400:irmp.c        **** 
2401:irmp.c        **** #if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
2402:irmp.c        ****                     if (irmp_pulse_time >= SIRCS_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SIRC
2403:irmp.c        ****                         irmp_pause_time >= SIRCS_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SIRC
2404:irmp.c        ****                     {                                                           // it's SIRCS
2405:irmp.c        **** #ifdef ANALYZE
2406:irmp.c        ****                         ANALYZE_PRINTF ("protocol = SIRCS, start bit timings: pulse: %3d - %3d, pau
2407:irmp.c        ****                                         SIRCS_START_BIT_PULSE_LEN_MIN, SIRCS_START_BIT_PULSE_LEN_MA
2408:irmp.c        ****                                         SIRCS_START_BIT_PAUSE_LEN_MIN, SIRCS_START_BIT_PAUSE_LEN_MA
2409:irmp.c        **** #endif // ANALYZE
2410:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) (IRMP_PARAMETER *) &sircs_param;
2411:irmp.c        ****                     }
2412:irmp.c        ****                     else
2413:irmp.c        **** #endif // IRMP_SUPPORT_SIRCS_PROTOCOL == 1
2414:irmp.c        **** 
2415:irmp.c        **** #if IRMP_SUPPORT_JVC_PROTOCOL == 1
2416:irmp.c        ****                     if (irmp_protocol == IRMP_JVC_PROTOCOL &&                                      
2417:irmp.c        ****                         irmp_pulse_time >= JVC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= JVC_ST
2418:irmp.c        ****                         irmp_pause_time >= JVC_REPEAT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <=
2419:irmp.c        ****                     {
2420:irmp.c        **** #ifdef ANALYZE
2421:irmp.c        ****                         ANALYZE_PRINTF ("protocol = NEC or JVC (type 1) repeat frame, start bit tim
2422:irmp.c        ****                                         JVC_START_BIT_PULSE_LEN_MIN, JVC_START_BIT_PULSE_LEN_MAX,
2423:irmp.c        ****                                         JVC_REPEAT_START_BIT_PAUSE_LEN_MIN, JVC_REPEAT_START_BIT_PA
2424:irmp.c        **** #endif // ANALYZE
2425:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &nec_param;
2426:irmp.c        ****                     }
2427:irmp.c        ****                     else
2428:irmp.c        **** #endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
2429:irmp.c        **** 
2430:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
2431:irmp.c        ****                     if (irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NEC_ST
2432:irmp.c        ****                         irmp_pause_time >= NEC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NEC_ST
2433:irmp.c        ****                     {
2434:irmp.c        **** #if IRMP_SUPPORT_NEC42_PROTOCOL == 1
2435:irmp.c        **** #ifdef ANALYZE
2436:irmp.c        ****                         ANALYZE_PRINTF ("protocol = NEC42, start bit timings: pulse: %3d - %3d, pau
2437:irmp.c        ****                                         NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
2438:irmp.c        ****                                         NEC_START_BIT_PAUSE_LEN_MIN, NEC_START_BIT_PAUSE_LEN_MAX);
2439:irmp.c        **** #endif // ANALYZE
2440:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &nec42_param;
2441:irmp.c        **** #else
2442:irmp.c        **** #ifdef ANALYZE
2443:irmp.c        ****                         ANALYZE_PRINTF ("protocol = NEC, start bit timings: pulse: %3d - %3d, pause
2444:irmp.c        ****                                         NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
2445:irmp.c        ****                                         NEC_START_BIT_PAUSE_LEN_MIN, NEC_START_BIT_PAUSE_LEN_MAX);
2446:irmp.c        **** #endif // ANALYZE
2447:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &nec_param;
2448:irmp.c        **** #endif
2449:irmp.c        ****                     }
2450:irmp.c        ****                     else if (irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN        && irmp_pulse_ti
2451:irmp.c        ****                              irmp_pause_time >= NEC_REPEAT_START_BIT_PAUSE_LEN_MIN && irmp_pause_ti
2452:irmp.c        ****                     {                                                           // it's NEC
2453:irmp.c        **** #if IRMP_SUPPORT_JVC_PROTOCOL == 1
2454:irmp.c        ****                         if (irmp_protocol == IRMP_JVC_PROTOCOL)                 // last protocol wa
2455:irmp.c        ****                         {                                                       // some jvc remote 
2456:irmp.c        **** #ifdef ANALYZE
2457:irmp.c        ****                             ANALYZE_PRINTF ("protocol = JVC repeat frame type 2, start bit timings:
2458:irmp.c        ****                                             NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MA
2459:irmp.c        ****                                             NEC_REPEAT_START_BIT_PAUSE_LEN_MIN, NEC_REPEAT_START_BI
2460:irmp.c        **** #endif // ANALYZE
2461:irmp.c        ****                             irmp_param_p = (IRMP_PARAMETER *) &nec_param;
2462:irmp.c        ****                         }
2463:irmp.c        ****                         else
2464:irmp.c        **** #endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
2465:irmp.c        ****                         {
2466:irmp.c        **** #ifdef ANALYZE
2467:irmp.c        ****                             ANALYZE_PRINTF ("protocol = NEC (repetition frame), start bit timings: 
2468:irmp.c        ****                                             NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MA
2469:irmp.c        ****                                             NEC_REPEAT_START_BIT_PAUSE_LEN_MIN, NEC_REPEAT_START_BI
2470:irmp.c        **** #endif // ANALYZE
2471:irmp.c        **** 
2472:irmp.c        ****                             irmp_param_p = (IRMP_PARAMETER *) &nec_rep_param;
2473:irmp.c        ****                         }
2474:irmp.c        ****                     }
2475:irmp.c        ****                     else
2476:irmp.c        **** 
2477:irmp.c        **** #if IRMP_SUPPORT_JVC_PROTOCOL == 1
2478:irmp.c        ****                     if (irmp_protocol == IRMP_JVC_PROTOCOL &&                   // last protocol wa
2479:irmp.c        ****                         irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NEC_ST
2480:irmp.c        ****                         irmp_pause_time >= NEC_0_PAUSE_LEN_MIN         && irmp_pause_time <= NEC_0_
2481:irmp.c        ****                     {                                                           // it's JVC repetit
2482:irmp.c        **** #ifdef ANALYZE
2483:irmp.c        ****                         ANALYZE_PRINTF ("protocol = JVC repeat frame type 3, start bit timings: pul
2484:irmp.c        ****                                         NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
2485:irmp.c        ****                                         NEC_0_PAUSE_LEN_MIN, NEC_0_PAUSE_LEN_MAX);
2486:irmp.c        **** #endif // ANALYZE
2487:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &nec_param;
2488:irmp.c        ****                     }
2489:irmp.c        ****                     else
2490:irmp.c        **** #endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
2491:irmp.c        **** 
2492:irmp.c        **** #endif // IRMP_SUPPORT_NEC_PROTOCOL == 1
2493:irmp.c        **** 
2494:irmp.c        **** #if IRMP_SUPPORT_TELEFUNKEN_PROTOCOL == 1
2495:irmp.c        ****                     if (irmp_pulse_time >= TELEFUNKEN_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <=
2496:irmp.c        ****                         irmp_pause_time >= TELEFUNKEN_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <=
2497:irmp.c        ****                     {
2498:irmp.c        **** #ifdef ANALYZE
2499:irmp.c        ****                         ANALYZE_PRINTF ("protocol = TELEFUNKEN, start bit timings: pulse: %3d - %3d
2500:irmp.c        ****                                         TELEFUNKEN_START_BIT_PULSE_LEN_MIN, TELEFUNKEN_START_BIT_PU
2501:irmp.c        ****                                         TELEFUNKEN_START_BIT_PAUSE_LEN_MIN, TELEFUNKEN_START_BIT_PA
2502:irmp.c        **** #endif // ANALYZE
2503:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &telefunken_param;
2504:irmp.c        ****                     }
2505:irmp.c        ****                     else
2506:irmp.c        **** #endif // IRMP_SUPPORT_TELEFUNKEN_PROTOCOL == 1
2507:irmp.c        **** 
2508:irmp.c        **** #if IRMP_SUPPORT_ROOMBA_PROTOCOL == 1
2509:irmp.c        ****                     if (irmp_pulse_time >= ROOMBA_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= ROO
2510:irmp.c        ****                         irmp_pause_time >= ROOMBA_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= ROO
2511:irmp.c        ****                     {
2512:irmp.c        **** #ifdef ANALYZE
2513:irmp.c        ****                         ANALYZE_PRINTF ("protocol = ROOMBA, start bit timings: pulse: %3d - %3d, pa
2514:irmp.c        ****                                         ROOMBA_START_BIT_PULSE_LEN_MIN, ROOMBA_START_BIT_PULSE_LEN_
2515:irmp.c        ****                                         ROOMBA_START_BIT_PAUSE_LEN_MIN, ROOMBA_START_BIT_PAUSE_LEN_
2516:irmp.c        **** #endif // ANALYZE
2517:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &roomba_param;
2518:irmp.c        ****                     }
2519:irmp.c        ****                     else
2520:irmp.c        **** #endif // IRMP_SUPPORT_ROOMBA_PROTOCOL == 1
2521:irmp.c        **** 
2522:irmp.c        **** #if IRMP_SUPPORT_NIKON_PROTOCOL == 1
2523:irmp.c        ****                     if (irmp_pulse_time >= NIKON_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NIKO
2524:irmp.c        ****                         irmp_pause_time >= NIKON_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NIKO
2525:irmp.c        ****                     {
2526:irmp.c        **** #ifdef ANALYZE
2527:irmp.c        ****                         ANALYZE_PRINTF ("protocol = NIKON, start bit timings: pulse: %3d - %3d, pau
2528:irmp.c        ****                                         NIKON_START_BIT_PULSE_LEN_MIN, NIKON_START_BIT_PULSE_LEN_MA
2529:irmp.c        ****                                         NIKON_START_BIT_PAUSE_LEN_MIN, NIKON_START_BIT_PAUSE_LEN_MA
2530:irmp.c        **** #endif // ANALYZE
2531:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &nikon_param;
2532:irmp.c        ****                     }
2533:irmp.c        ****                     else
2534:irmp.c        **** #endif // IRMP_SUPPORT_NIKON_PROTOCOL == 1
2535:irmp.c        **** 
2536:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
2537:irmp.c        ****                     if (irmp_pulse_time >= SAMSUNG_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SA
2538:irmp.c        ****                         irmp_pause_time >= SAMSUNG_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SA
2539:irmp.c        ****                     {                                                           // it's SAMSUNG
2540:irmp.c        **** #ifdef ANALYZE
2541:irmp.c        ****                         ANALYZE_PRINTF ("protocol = SAMSUNG, start bit timings: pulse: %3d - %3d, p
2542:irmp.c        ****                                         SAMSUNG_START_BIT_PULSE_LEN_MIN, SAMSUNG_START_BIT_PULSE_LE
2543:irmp.c        ****                                         SAMSUNG_START_BIT_PAUSE_LEN_MIN, SAMSUNG_START_BIT_PAUSE_LE
2544:irmp.c        **** #endif // ANALYZE
2545:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &samsung_param;
2546:irmp.c        ****                     }
2547:irmp.c        ****                     else
2548:irmp.c        **** #endif // IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
2549:irmp.c        **** 
2550:irmp.c        **** #if IRMP_SUPPORT_MATSUSHITA_PROTOCOL == 1
2551:irmp.c        ****                     if (irmp_pulse_time >= MATSUSHITA_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <=
2552:irmp.c        ****                         irmp_pause_time >= MATSUSHITA_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <=
2553:irmp.c        ****                     {                                                           // it's MATSUSHITA
2554:irmp.c        **** #ifdef ANALYZE
2555:irmp.c        ****                         ANALYZE_PRINTF ("protocol = MATSUSHITA, start bit timings: pulse: %3d - %3d
2556:irmp.c        ****                                         MATSUSHITA_START_BIT_PULSE_LEN_MIN, MATSUSHITA_START_BIT_PU
2557:irmp.c        ****                                         MATSUSHITA_START_BIT_PAUSE_LEN_MIN, MATSUSHITA_START_BIT_PA
2558:irmp.c        **** #endif // ANALYZE
2559:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &matsushita_param;
2560:irmp.c        ****                     }
2561:irmp.c        ****                     else
2562:irmp.c        **** #endif // IRMP_SUPPORT_MATSUSHITA_PROTOCOL == 1
2563:irmp.c        **** 
2564:irmp.c        **** #if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
2565:irmp.c        ****                     if (irmp_pulse_time >= KASEIKYO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= K
2566:irmp.c        ****                         irmp_pause_time >= KASEIKYO_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= K
2567:irmp.c        ****                     {                                                           // it's KASEIKYO
2568:irmp.c        **** #ifdef ANALYZE
2569:irmp.c        ****                         ANALYZE_PRINTF ("protocol = KASEIKYO, start bit timings: pulse: %3d - %3d, 
2570:irmp.c        ****                                         KASEIKYO_START_BIT_PULSE_LEN_MIN, KASEIKYO_START_BIT_PULSE_
2571:irmp.c        ****                                         KASEIKYO_START_BIT_PAUSE_LEN_MIN, KASEIKYO_START_BIT_PAUSE_
2572:irmp.c        **** #endif // ANALYZE
2573:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &kaseikyo_param;
2574:irmp.c        ****                     }
2575:irmp.c        ****                     else
2576:irmp.c        **** #endif // IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
2577:irmp.c        **** 
2578:irmp.c        **** #if IRMP_SUPPORT_RADIO1_PROTOCOL == 1
2579:irmp.c        ****                     if (irmp_pulse_time >= RADIO1_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RAD
2580:irmp.c        ****                         irmp_pause_time >= RADIO1_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RAD
2581:irmp.c        ****                     {
2582:irmp.c        **** #ifdef ANALYZE
2583:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RADIO1, start bit timings: pulse: %3d - %3d, pa
2584:irmp.c        ****                                         RADIO1_START_BIT_PULSE_LEN_MIN, RADIO1_START_BIT_PULSE_LEN_
2585:irmp.c        ****                                         RADIO1_START_BIT_PAUSE_LEN_MIN, RADIO1_START_BIT_PAUSE_LEN_
2586:irmp.c        **** #endif // ANALYZE
2587:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &radio1_param;
2588:irmp.c        ****                     }
2589:irmp.c        ****                     else
2590:irmp.c        **** #endif // IRMP_SUPPORT_RRADIO1_PROTOCOL == 1
2591:irmp.c        **** 
2592:irmp.c        **** #if IRMP_SUPPORT_RECS80_PROTOCOL == 1
2593:irmp.c        ****                     if (irmp_pulse_time >= RECS80_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= REC
2594:irmp.c        ****                         irmp_pause_time >= RECS80_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= REC
2595:irmp.c        ****                     {                                                           // it's RECS80
2596:irmp.c        **** #ifdef ANALYZE
2597:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RECS80, start bit timings: pulse: %3d - %3d, pa
2598:irmp.c        ****                                         RECS80_START_BIT_PULSE_LEN_MIN, RECS80_START_BIT_PULSE_LEN_
2599:irmp.c        ****                                         RECS80_START_BIT_PAUSE_LEN_MIN, RECS80_START_BIT_PAUSE_LEN_
2600:irmp.c        **** #endif // ANALYZE
2601:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &recs80_param;
2602:irmp.c        ****                     }
2603:irmp.c        ****                     else
2604:irmp.c        **** #endif // IRMP_SUPPORT_RECS80_PROTOCOL == 1
2605:irmp.c        **** 
2606:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1
2607:irmp.c        ****                     if (((irmp_pulse_time >= RC5_START_BIT_LEN_MIN     && irmp_pulse_time <= RC5_ST
 413               	68,0,2607,.LM50-.LFBB4
 414               	.LM50:
 415 01ba 2091 0000 		lds r18,irmp_pulse_time.1728
 416 01be 822F      		mov r24,r18
 417 01c0 8750      		subi r24,lo8(-(-7))
 418 01c2 8530      		cpi r24,lo8(5)
 419 01c4 00F0      		brlo .L23
 420 01c6 8750      		subi r24,lo8(-(-7))
 421 01c8 8930      		cpi r24,lo8(9)
 422 01ca 00F4      		brsh .L24
 423               	.L23:
 424 01cc 9091 0000 		lds r25,irmp_pause_time.1729
 425 01d0 892F      		mov r24,r25
 426 01d2 8750      		subi r24,lo8(-(-7))
 427 01d4 8530      		cpi r24,lo8(5)
 428 01d6 00F0      		brlo .L25
 429 01d8 8750      		subi r24,lo8(-(-7))
 430 01da 8930      		cpi r24,lo8(9)
 431 01dc 00F4      		brsh .L24
 432               	.L25:
2608:irmp.c        ****                          (irmp_pulse_time >= 2 * RC5_START_BIT_LEN_MIN && irmp_pulse_time <= 2 * RC
2609:irmp.c        ****                         ((irmp_pause_time >= RC5_START_BIT_LEN_MIN     && irmp_pause_time <= RC5_ST
2610:irmp.c        ****                          (irmp_pause_time >= 2 * RC5_START_BIT_LEN_MIN && irmp_pause_time <= 2 * RC
2611:irmp.c        ****                     {                                                           // it's RC5
2612:irmp.c        **** #if IRMP_SUPPORT_FDC_PROTOCOL == 1
2613:irmp.c        ****                         if (irmp_pulse_time >= FDC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= FD
2614:irmp.c        ****                             irmp_pause_time >= FDC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= FD
2615:irmp.c        ****                         {
2616:irmp.c        **** #ifdef ANALYZE
2617:irmp.c        ****                             ANALYZE_PRINTF ("protocol = RC5 or FDC\n");
2618:irmp.c        ****                             ANALYZE_PRINTF ("FDC start bit timings: pulse: %3d - %3d, pause: %3d - 
2619:irmp.c        ****                                             FDC_START_BIT_PULSE_LEN_MIN, FDC_START_BIT_PULSE_LEN_MA
2620:irmp.c        ****                                             FDC_START_BIT_PAUSE_LEN_MIN, FDC_START_BIT_PAUSE_LEN_MA
2621:irmp.c        ****                             ANALYZE_PRINTF ("RC5 start bit timings: pulse: %3d - %3d, pause: %3d - 
2622:irmp.c        ****                                             RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
2623:irmp.c        ****                                             RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX);
2624:irmp.c        **** #endif // ANALYZE
2625:irmp.c        ****                             memcpy_P (&irmp_param2, &fdc_param, sizeof (IRMP_PARAMETER));
2626:irmp.c        ****                         }
2627:irmp.c        ****                         else
2628:irmp.c        **** #endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
2629:irmp.c        **** 
2630:irmp.c        **** #if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
2631:irmp.c        ****                         if (irmp_pulse_time >= RCCAR_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= 
2632:irmp.c        ****                             irmp_pause_time >= RCCAR_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= 
2633:irmp.c        ****                         {
2634:irmp.c        **** #ifdef ANALYZE
2635:irmp.c        ****                             ANALYZE_PRINTF ("protocol = RC5 or RCCAR\n");
2636:irmp.c        ****                             ANALYZE_PRINTF ("RCCAR start bit timings: pulse: %3d - %3d, pause: %3d 
2637:irmp.c        ****                                             RCCAR_START_BIT_PULSE_LEN_MIN, RCCAR_START_BIT_PULSE_LE
2638:irmp.c        ****                                             RCCAR_START_BIT_PAUSE_LEN_MIN, RCCAR_START_BIT_PAUSE_LE
2639:irmp.c        ****                             ANALYZE_PRINTF ("RC5 start bit timings: pulse: %3d - %3d, pause: %3d - 
2640:irmp.c        ****                                             RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
2641:irmp.c        ****                                             RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX);
2642:irmp.c        **** #endif // ANALYZE
2643:irmp.c        ****                             memcpy_P (&irmp_param2, &rccar_param, sizeof (IRMP_PARAMETER));
2644:irmp.c        ****                         }
2645:irmp.c        ****                         else
2646:irmp.c        **** #endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
2647:irmp.c        ****                         {
2648:irmp.c        **** #ifdef ANALYZE
2649:irmp.c        ****                             ANALYZE_PRINTF ("protocol = RC5, start bit timings: pulse: %3d - %3d, p
2650:irmp.c        ****                                             RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
2651:irmp.c        ****                                             2 * RC5_START_BIT_LEN_MIN, 2 * RC5_START_BIT_LEN_MAX,
2652:irmp.c        ****                                             RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
2653:irmp.c        ****                                             2 * RC5_START_BIT_LEN_MIN, 2 * RC5_START_BIT_LEN_MAX);
2654:irmp.c        **** #endif // ANALYZE
2655:irmp.c        ****                         }
2656:irmp.c        **** 
2657:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &rc5_param;
 433               	M51-.LFBB4
 434               	.LM51:
 435 01de 60E0      		ldi r22,lo8(rc5_param)
 436 01e0 70E0      		ldi r23,hi8(rc5_param)
2658:irmp.c        ****                         last_pause = irmp_pause_time;
 437               	abn	68,0,2658,.LM52-.LFBB4
 438               	.LM52:
 439 01e2 9093 0000 		sts last_pause.1735,r25
2659:irmp.c        **** 
2660:irmp.c        ****                         if ((irmp_pulse_time > RC5_START_BIT_LEN_MAX && irmp_pulse_time <= 2 * RC5_
 440               	tabn	68,0,2660,.LM53-.LFBB4
 441               	.LM53:
 442 01e6 2C50      		subi r18,lo8(-(-12))
 443 01e8 2B30      		cpi r18,lo8(11)
 444 01ea 00F0      		brlo .L26
 445 01ec 9C50      		subi r25,lo8(-(-12))
 446 01ee 9B30      		cpi r25,lo8(11)
 447 01f0 00F4      		brsh .L27
 448               	.L26:
2661:irmp.c        ****                             (irmp_pause_time > RC5_START_BIT_LEN_MAX && irmp_pause_time <= 2 * RC5_
2662:irmp.c        ****                         {
2663:irmp.c        ****                           last_value  = 0;
 449               	8,0,2663,.LM54-.LFBB4
 450               	.LM54:
 451 01f2 1092 0000 		sts last_value.1736,__zero_reg__
2664:irmp.c        ****                           rc5_cmd_bit6 = 1<<6;
 452               	tabn	68,0,2664,.LM55-.LFBB4
 453               	.LM55:
 454 01f6 80E4      		ldi r24,lo8(64)
 455 01f8 8093 0000 		sts rc5_cmd_bit6.1734,r24
 456 01fc 00C0      		rjmp .L28
 457               	.L27:
2665:irmp.c        ****                         }
2666:irmp.c        ****                         else
2667:irmp.c        ****                         {
2668:irmp.c        ****                           last_value  = 1;
 458               	n	68,0,2668,.LM56-.LFBB4
 459               	.LM56:
 460 01fe 81E0      		ldi r24,lo8(1)
 461 0200 8093 0000 		sts last_value.1736,r24
 462 0204 00C0      		rjmp .L28
 463               	.L24:
2669:irmp.c        ****                         }
2670:irmp.c        ****                     }
2671:irmp.c        ****                     else
2672:irmp.c        **** #endif // IRMP_SUPPORT_RC5_PROTOCOL == 1
2673:irmp.c        **** 
2674:irmp.c        **** #if IRMP_SUPPORT_DENON_PROTOCOL == 1
2675:irmp.c        ****                     if ( (irmp_pulse_time >= DENON_PULSE_LEN_MIN && irmp_pulse_time <= DENON_PULSE_
2676:irmp.c        ****                         ((irmp_pause_time >= DENON_1_PAUSE_LEN_MIN && irmp_pause_time <= DENON_1_PA
2677:irmp.c        ****                          (irmp_pause_time >= DENON_0_PAUSE_LEN_MIN && irmp_pause_time <= DENON_0_PA
2678:irmp.c        ****                     {                                                           // it's DENON
2679:irmp.c        **** #ifdef ANALYZE
2680:irmp.c        ****                         ANALYZE_PRINTF ("protocol = DENON, start bit timings: pulse: %3d - %3d, pau
2681:irmp.c        ****                                         DENON_PULSE_LEN_MIN, DENON_PULSE_LEN_MAX,
2682:irmp.c        ****                                         DENON_1_PAUSE_LEN_MIN, DENON_1_PAUSE_LEN_MAX,
2683:irmp.c        ****                                         DENON_0_PAUSE_LEN_MIN, DENON_0_PAUSE_LEN_MAX);
2684:irmp.c        **** #endif // ANALYZE
2685:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &denon_param;
2686:irmp.c        ****                     }
2687:irmp.c        ****                     else
2688:irmp.c        **** #endif // IRMP_SUPPORT_DENON_PROTOCOL == 1
2689:irmp.c        **** 
2690:irmp.c        **** #if IRMP_SUPPORT_THOMSON_PROTOCOL == 1
2691:irmp.c        ****                     if ( (irmp_pulse_time >= THOMSON_PULSE_LEN_MIN && irmp_pulse_time <= THOMSON_PU
2692:irmp.c        ****                         ((irmp_pause_time >= THOMSON_1_PAUSE_LEN_MIN && irmp_pause_time <= THOMSON_
2693:irmp.c        ****                          (irmp_pause_time >= THOMSON_0_PAUSE_LEN_MIN && irmp_pause_time <= THOMSON_
2694:irmp.c        ****                     {                                                           // it's THOMSON
2695:irmp.c        **** #ifdef ANALYZE
2696:irmp.c        ****                         ANALYZE_PRINTF ("protocol = THOMSON, start bit timings: pulse: %3d - %3d, p
2697:irmp.c        ****                                         THOMSON_PULSE_LEN_MIN, THOMSON_PULSE_LEN_MAX,
2698:irmp.c        ****                                         THOMSON_1_PAUSE_LEN_MIN, THOMSON_1_PAUSE_LEN_MAX,
2699:irmp.c        ****                                         THOMSON_0_PAUSE_LEN_MIN, THOMSON_0_PAUSE_LEN_MAX);
2700:irmp.c        **** #endif // ANALYZE
2701:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &thomson_param;
2702:irmp.c        ****                     }
2703:irmp.c        ****                     else
2704:irmp.c        **** #endif // IRMP_SUPPORT_THOMSON_PROTOCOL == 1
2705:irmp.c        **** 
2706:irmp.c        **** #if IRMP_SUPPORT_BOSE_PROTOCOL == 1
2707:irmp.c        ****                     if (irmp_pulse_time >= BOSE_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= BOSE_
2708:irmp.c        ****                         irmp_pause_time >= BOSE_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= BOSE_
2709:irmp.c        ****                     {
2710:irmp.c        **** #ifdef ANALYZE
2711:irmp.c        ****                         ANALYZE_PRINTF ("protocol = BOSE, start bit timings: pulse: %3d - %3d, paus
2712:irmp.c        ****                                         BOSE_START_BIT_PULSE_LEN_MIN, BOSE_START_BIT_PULSE_LEN_MAX,
2713:irmp.c        ****                                         BOSE_START_BIT_PAUSE_LEN_MIN, BOSE_START_BIT_PAUSE_LEN_MAX)
2714:irmp.c        **** #endif // ANALYZE
2715:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &bose_param;
2716:irmp.c        ****                     }
2717:irmp.c        ****                     else
2718:irmp.c        **** #endif // IRMP_SUPPORT_BOSE_PROTOCOL == 1
2719:irmp.c        **** 
2720:irmp.c        **** #if IRMP_SUPPORT_RC6_PROTOCOL == 1
2721:irmp.c        ****                     if (irmp_pulse_time >= RC6_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RC6_ST
2722:irmp.c        ****                         irmp_pause_time >= RC6_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RC6_ST
2723:irmp.c        ****                     {                                                           // it's RC6
2724:irmp.c        **** #ifdef ANALYZE
2725:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RC6, start bit timings: pulse: %3d - %3d, pause
2726:irmp.c        ****                                         RC6_START_BIT_PULSE_LEN_MIN, RC6_START_BIT_PULSE_LEN_MAX,
2727:irmp.c        ****                                         RC6_START_BIT_PAUSE_LEN_MIN, RC6_START_BIT_PAUSE_LEN_MAX);
2728:irmp.c        **** #endif // ANALYZE
2729:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &rc6_param;
2730:irmp.c        ****                         last_pause = 0;
2731:irmp.c        ****                         last_value = 1;
2732:irmp.c        ****                     }
2733:irmp.c        ****                     else
2734:irmp.c        **** #endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
2735:irmp.c        **** 
2736:irmp.c        **** #if IRMP_SUPPORT_RECS80EXT_PROTOCOL == 1
2737:irmp.c        ****                     if (irmp_pulse_time >= RECS80EXT_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= 
2738:irmp.c        ****                         irmp_pause_time >= RECS80EXT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= 
2739:irmp.c        ****                     {                                                           // it's RECS80EXT
2740:irmp.c        **** #ifdef ANALYZE
2741:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RECS80EXT, start bit timings: pulse: %3d - %3d,
2742:irmp.c        ****                                         RECS80EXT_START_BIT_PULSE_LEN_MIN, RECS80EXT_START_BIT_PULS
2743:irmp.c        ****                                         RECS80EXT_START_BIT_PAUSE_LEN_MIN, RECS80EXT_START_BIT_PAUS
2744:irmp.c        **** #endif // ANALYZE
2745:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &recs80ext_param;
2746:irmp.c        ****                     }
2747:irmp.c        ****                     else
2748:irmp.c        **** #endif // IRMP_SUPPORT_RECS80EXT_PROTOCOL == 1
2749:irmp.c        **** 
2750:irmp.c        **** #if IRMP_SUPPORT_NUBERT_PROTOCOL == 1
2751:irmp.c        ****                     if (irmp_pulse_time >= NUBERT_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NUB
2752:irmp.c        ****                         irmp_pause_time >= NUBERT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NUB
2753:irmp.c        ****                     {                                                           // it's NUBERT
2754:irmp.c        **** #ifdef ANALYZE
2755:irmp.c        ****                         ANALYZE_PRINTF ("protocol = NUBERT, start bit timings: pulse: %3d - %3d, pa
2756:irmp.c        ****                                         NUBERT_START_BIT_PULSE_LEN_MIN, NUBERT_START_BIT_PULSE_LEN_
2757:irmp.c        ****                                         NUBERT_START_BIT_PAUSE_LEN_MIN, NUBERT_START_BIT_PAUSE_LEN_
2758:irmp.c        **** #endif // ANALYZE
2759:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &nubert_param;
2760:irmp.c        ****                     }
2761:irmp.c        ****                     else
2762:irmp.c        **** #endif // IRMP_SUPPORT_NUBERT_PROTOCOL == 1
2763:irmp.c        **** 
2764:irmp.c        **** #if IRMP_SUPPORT_SPEAKER_PROTOCOL == 1
2765:irmp.c        ****                     if (irmp_pulse_time >= SPEAKER_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SP
2766:irmp.c        ****                         irmp_pause_time >= SPEAKER_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SP
2767:irmp.c        ****                     {                                                           // it's SPEAKER
2768:irmp.c        **** #ifdef ANALYZE
2769:irmp.c        ****                         ANALYZE_PRINTF ("protocol = SPEAKER, start bit timings: pulse: %3d - %3d, p
2770:irmp.c        ****                                         SPEAKER_START_BIT_PULSE_LEN_MIN, SPEAKER_START_BIT_PULSE_LE
2771:irmp.c        ****                                         SPEAKER_START_BIT_PAUSE_LEN_MIN, SPEAKER_START_BIT_PAUSE_LE
2772:irmp.c        **** #endif // ANALYZE
2773:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &speaker_param;
2774:irmp.c        ****                     }
2775:irmp.c        ****                     else
2776:irmp.c        **** #endif // IRMP_SUPPORT_SPEAKER_PROTOCOL == 1
2777:irmp.c        **** 
2778:irmp.c        **** #if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
2779:irmp.c        ****                     if (irmp_pulse_time >= BANG_OLUFSEN_START_BIT1_PULSE_LEN_MIN && irmp_pulse_time
2780:irmp.c        ****                         irmp_pause_time >= BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MIN && irmp_pause_time
2781:irmp.c        ****                     {                                                           // it's BANG_OLUFSE
2782:irmp.c        **** #ifdef ANALYZE
2783:irmp.c        ****                         ANALYZE_PRINTF ("protocol = BANG_OLUFSEN\n");
2784:irmp.c        ****                         ANALYZE_PRINTF ("start bit 1 timings: pulse: %3d - %3d, pause: %3d - %3d\n"
2785:irmp.c        ****                                         BANG_OLUFSEN_START_BIT1_PULSE_LEN_MIN, BANG_OLUFSEN_START_B
2786:irmp.c        ****                                         BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MIN, BANG_OLUFSEN_START_B
2787:irmp.c        ****                         ANALYZE_PRINTF ("start bit 2 timings: pulse: %3d - %3d, pause: %3d - %3d\n"
2788:irmp.c        ****                                         BANG_OLUFSEN_START_BIT2_PULSE_LEN_MIN, BANG_OLUFSEN_START_B
2789:irmp.c        ****                                         BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MIN, BANG_OLUFSEN_START_B
2790:irmp.c        ****                         ANALYZE_PRINTF ("start bit 3 timings: pulse: %3d - %3d, pause: %3d - %3d\n"
2791:irmp.c        ****                                         BANG_OLUFSEN_START_BIT3_PULSE_LEN_MIN, BANG_OLUFSEN_START_B
2792:irmp.c        ****                                         BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MIN, BANG_OLUFSEN_START_B
2793:irmp.c        ****                         ANALYZE_PRINTF ("start bit 4 timings: pulse: %3d - %3d, pause: %3d - %3d\n"
2794:irmp.c        ****                                         BANG_OLUFSEN_START_BIT4_PULSE_LEN_MIN, BANG_OLUFSEN_START_B
2795:irmp.c        ****                                         BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MIN, BANG_OLUFSEN_START_B
2796:irmp.c        **** #endif // ANALYZE
2797:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &bang_olufsen_param;
2798:irmp.c        ****                         last_value = 0;
2799:irmp.c        ****                     }
2800:irmp.c        ****                     else
2801:irmp.c        **** #endif // IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
2802:irmp.c        **** 
2803:irmp.c        **** #if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
2804:irmp.c        ****                     if (irmp_pulse_time >= GRUNDIG_NOKIA_IR60_START_BIT_LEN_MIN && irmp_pulse_time 
2805:irmp.c        ****                         irmp_pause_time >= GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MIN && irmp_pause_time 
2806:irmp.c        ****                     {                                                           // it's GRUNDIG
2807:irmp.c        **** #ifdef ANALYZE
2808:irmp.c        ****                         ANALYZE_PRINTF ("protocol = GRUNDIG, pre bit timings: pulse: %3d - %3d, pau
2809:irmp.c        ****                                         GRUNDIG_NOKIA_IR60_START_BIT_LEN_MIN, GRUNDIG_NOKIA_IR60_ST
2810:irmp.c        ****                                         GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MIN, GRUNDIG_NOKIA_IR60_PR
2811:irmp.c        **** #endif // ANALYZE
2812:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &grundig_param;
2813:irmp.c        ****                         last_pause = irmp_pause_time;
2814:irmp.c        ****                         last_value  = 1;
2815:irmp.c        ****                     }
2816:irmp.c        ****                     else
2817:irmp.c        **** #endif // IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
2818:irmp.c        **** 
2819:irmp.c        **** #if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
2820:irmp.c        ****                     if (((irmp_pulse_time >= SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN && irmp_puls
2821:irmp.c        ****                          (irmp_pulse_time >= 2 * SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN && irmp_
2822:irmp.c        ****                         ((irmp_pause_time >= SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN && irmp_paus
2823:irmp.c        ****                          (irmp_pause_time >= 2 * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN && irmp_
2824:irmp.c        ****                     {                                                           // it's RUWIDO or S
2825:irmp.c        **** #ifdef ANALYZE
2826:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RUWIDO, start bit timings: pulse: %3d - %3d or 
2827:irmp.c        ****                                         SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN,   SIEMENS_OR_RUW
2828:irmp.c        ****                                         2 * SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN, 2 * SIEMENS_
2829:irmp.c        ****                                         SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN,   SIEMENS_OR_RUW
2830:irmp.c        ****                                         2 * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN, 2 * SIEMENS_
2831:irmp.c        **** #endif // ANALYZE
2832:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &ruwido_param;
2833:irmp.c        ****                         last_pause = irmp_pause_time;
2834:irmp.c        ****                         last_value  = 1;
2835:irmp.c        ****                     }
2836:irmp.c        ****                     else
2837:irmp.c        **** #endif // IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
2838:irmp.c        **** 
2839:irmp.c        **** #if IRMP_SUPPORT_FDC_PROTOCOL == 1
2840:irmp.c        ****                     if (irmp_pulse_time >= FDC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= FDC_ST
2841:irmp.c        ****                         irmp_pause_time >= FDC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= FDC_ST
2842:irmp.c        ****                     {
2843:irmp.c        **** #ifdef ANALYZE
2844:irmp.c        ****                         ANALYZE_PRINTF ("protocol = FDC, start bit timings: pulse: %3d - %3d, pause
2845:irmp.c        ****                                         FDC_START_BIT_PULSE_LEN_MIN, FDC_START_BIT_PULSE_LEN_MAX,
2846:irmp.c        ****                                         FDC_START_BIT_PAUSE_LEN_MIN, FDC_START_BIT_PAUSE_LEN_MAX);
2847:irmp.c        **** #endif // ANALYZE
2848:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &fdc_param;
2849:irmp.c        ****                     }
2850:irmp.c        ****                     else
2851:irmp.c        **** #endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
2852:irmp.c        **** 
2853:irmp.c        **** #if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
2854:irmp.c        ****                     if (irmp_pulse_time >= RCCAR_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RCCA
2855:irmp.c        ****                         irmp_pause_time >= RCCAR_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RCCA
2856:irmp.c        ****                     {
2857:irmp.c        **** #ifdef ANALYZE
2858:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RCCAR, start bit timings: pulse: %3d - %3d, pau
2859:irmp.c        ****                                         RCCAR_START_BIT_PULSE_LEN_MIN, RCCAR_START_BIT_PULSE_LEN_MA
2860:irmp.c        ****                                         RCCAR_START_BIT_PAUSE_LEN_MIN, RCCAR_START_BIT_PAUSE_LEN_MA
2861:irmp.c        **** #endif // ANALYZE
2862:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &rccar_param;
2863:irmp.c        ****                     }
2864:irmp.c        ****                     else
2865:irmp.c        **** #endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
2866:irmp.c        **** 
2867:irmp.c        **** #if IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
2868:irmp.c        ****                     if (irmp_pulse_time >= KATHREIN_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= K
2869:irmp.c        ****                         irmp_pause_time >= KATHREIN_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= K
2870:irmp.c        ****                     {                                                           // it's KATHREIN
2871:irmp.c        **** #ifdef ANALYZE
2872:irmp.c        ****                         ANALYZE_PRINTF ("protocol = KATHREIN, start bit timings: pulse: %3d - %3d, 
2873:irmp.c        ****                                         KATHREIN_START_BIT_PULSE_LEN_MIN, KATHREIN_START_BIT_PULSE_
2874:irmp.c        ****                                         KATHREIN_START_BIT_PAUSE_LEN_MIN, KATHREIN_START_BIT_PAUSE_
2875:irmp.c        **** #endif // ANALYZE
2876:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &kathrein_param;
2877:irmp.c        ****                     }
2878:irmp.c        ****                     else
2879:irmp.c        **** #endif // IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
2880:irmp.c        **** 
2881:irmp.c        **** #if IRMP_SUPPORT_NETBOX_PROTOCOL == 1
2882:irmp.c        ****                     if (irmp_pulse_time >= NETBOX_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NET
2883:irmp.c        ****                         irmp_pause_time >= NETBOX_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NET
2884:irmp.c        ****                     {                                                           // it's NETBOX
2885:irmp.c        **** #ifdef ANALYZE
2886:irmp.c        ****                         ANALYZE_PRINTF ("protocol = NETBOX, start bit timings: pulse: %3d - %3d, pa
2887:irmp.c        ****                                         NETBOX_START_BIT_PULSE_LEN_MIN, NETBOX_START_BIT_PULSE_LEN_
2888:irmp.c        ****                                         NETBOX_START_BIT_PAUSE_LEN_MIN, NETBOX_START_BIT_PAUSE_LEN_
2889:irmp.c        **** #endif // ANALYZE
2890:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &netbox_param;
2891:irmp.c        ****                     }
2892:irmp.c        ****                     else
2893:irmp.c        **** #endif // IRMP_SUPPORT_NETBOX_PROTOCOL == 1
2894:irmp.c        **** 
2895:irmp.c        **** #if IRMP_SUPPORT_LEGO_PROTOCOL == 1
2896:irmp.c        ****                     if (irmp_pulse_time >= LEGO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= LEGO_
2897:irmp.c        ****                         irmp_pause_time >= LEGO_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= LEGO_
2898:irmp.c        ****                     {
2899:irmp.c        **** #ifdef ANALYZE
2900:irmp.c        ****                         ANALYZE_PRINTF ("protocol = LEGO, start bit timings: pulse: %3d - %3d, paus
2901:irmp.c        ****                                         LEGO_START_BIT_PULSE_LEN_MIN, LEGO_START_BIT_PULSE_LEN_MAX,
2902:irmp.c        ****                                         LEGO_START_BIT_PAUSE_LEN_MIN, LEGO_START_BIT_PAUSE_LEN_MAX)
2903:irmp.c        **** #endif // ANALYZE
2904:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &lego_param;
2905:irmp.c        ****                     }
2906:irmp.c        ****                     else
2907:irmp.c        **** #endif // IRMP_SUPPORT_LEGO_PROTOCOL == 1
2908:irmp.c        **** 
2909:irmp.c        **** #if IRMP_SUPPORT_A1TVBOX_PROTOCOL == 1
2910:irmp.c        ****                     if (irmp_pulse_time >= A1TVBOX_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= A1
2911:irmp.c        ****                         irmp_pause_time >= A1TVBOX_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= A1
2912:irmp.c        ****                     {                                                           // it's A1TVBOX
2913:irmp.c        **** #ifdef ANALYZE
2914:irmp.c        ****                         ANALYZE_PRINTF ("protocol = A1TVBOX, start bit timings: pulse: %3d - %3d, p
2915:irmp.c        ****                                         A1TVBOX_START_BIT_PULSE_LEN_MIN, A1TVBOX_START_BIT_PULSE_LE
2916:irmp.c        ****                                         A1TVBOX_START_BIT_PAUSE_LEN_MIN, A1TVBOX_START_BIT_PAUSE_LE
2917:irmp.c        **** #endif // ANALYZE
2918:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &a1tvbox_param;
2919:irmp.c        ****                         last_pause = 0;
2920:irmp.c        ****                         last_value = 1;
2921:irmp.c        ****                     }
2922:irmp.c        ****                     else
2923:irmp.c        **** #endif // IRMP_SUPPORT_A1TVBOX_PROTOCOL == 1
2924:irmp.c        **** 
2925:irmp.c        **** #if IRMP_SUPPORT_ORTEK_PROTOCOL == 1
2926:irmp.c        ****                     if (irmp_pulse_time >= ORTEK_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= ORTE
2927:irmp.c        ****                         irmp_pause_time >= ORTEK_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= ORTE
2928:irmp.c        ****                     {                                                           // it's ORTEK (Hama
2929:irmp.c        **** #ifdef ANALYZE
2930:irmp.c        ****                         ANALYZE_PRINTF ("protocol = ORTEK, start bit timings: pulse: %3d - %3d, pau
2931:irmp.c        ****                                         ORTEK_START_BIT_PULSE_LEN_MIN, ORTEK_START_BIT_PULSE_LEN_MA
2932:irmp.c        ****                                         ORTEK_START_BIT_PAUSE_LEN_MIN, ORTEK_START_BIT_PAUSE_LEN_MA
2933:irmp.c        **** #endif // ANALYZE
2934:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &ortek_param;
2935:irmp.c        ****                         last_pause  = 0;
2936:irmp.c        ****                         last_value  = 1;
2937:irmp.c        ****                         parity      = 0;
2938:irmp.c        ****                     }
2939:irmp.c        ****                     else
2940:irmp.c        **** #endif // IRMP_SUPPORT_ORTEK_PROTOCOL == 1
2941:irmp.c        **** 
2942:irmp.c        **** #if IRMP_SUPPORT_RCMM_PROTOCOL == 1
2943:irmp.c        ****                     if (irmp_pulse_time >= RCMM32_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RCM
2944:irmp.c        ****                         irmp_pause_time >= RCMM32_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RCM
2945:irmp.c        ****                     {                                                           // it's RCMM
2946:irmp.c        **** #ifdef ANALYZE
2947:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RCMM, start bit timings: pulse: %3d - %3d, paus
2948:irmp.c        ****                                         RCMM32_START_BIT_PULSE_LEN_MIN, RCMM32_START_BIT_PULSE_LEN_
2949:irmp.c        ****                                         RCMM32_START_BIT_PAUSE_LEN_MIN, RCMM32_START_BIT_PAUSE_LEN_
2950:irmp.c        **** #endif // ANALYZE
2951:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &rcmm_param;
2952:irmp.c        ****                     }
2953:irmp.c        ****                     else
2954:irmp.c        **** #endif // IRMP_SUPPORT_RCMM_PROTOCOL == 1
2955:irmp.c        ****                     {
2956:irmp.c        **** #ifdef ANALYZE
2957:irmp.c        ****                         ANALYZE_PRINTF ("protocol = UNKNOWN\n");
2958:irmp.c        **** #endif // ANALYZE
2959:irmp.c        ****                         irmp_start_bit_detected = 0;                            // wait for another
 464               	n	68,0,2959,.LM57-.LFBB4
 465               	.LM57:
 466 0206 1092 0000 		sts irmp_start_bit_detected.1725,__zero_reg__
 467 020a 60E0      		ldi r22,lo8(0)
 468 020c 70E0      		ldi r23,hi8(0)
 469               	.L28:
2960:irmp.c        ****                     }
2961:irmp.c        **** 
2962:irmp.c        ****                     if (irmp_start_bit_detected)
 470               	n	68,0,2962,.LM58-.LFBB4
 471               	.LM58:
 472 020e 8091 0000 		lds r24,irmp_start_bit_detected.1725
 473 0212 8823      		tst r24
 474 0214 01F0      		breq .L29
2963:irmp.c        ****                     {
2964:irmp.c        ****                         memcpy_P (&irmp_param, irmp_param_p, sizeof (IRMP_PARAMETER));
 475               	bn	68,0,2964,.LM59-.LFBB4
 476               	.LM59:
 477 0216 80E0      		ldi r24,lo8(irmp_param)
 478 0218 90E0      		ldi r25,hi8(irmp_param)
 479 021a 41E1      		ldi r20,lo8(17)
 480 021c 50E0      		ldi r21,hi8(17)
 481 021e 00D0      		rcall memcpy_P
 482               	.L29:
2965:irmp.c        **** 
2966:irmp.c        ****                         if (! (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))
2967:irmp.c        ****                         {
2968:irmp.c        **** #ifdef ANALYZE
2969:irmp.c        ****                             ANALYZE_PRINTF ("pulse_1: %3d - %3d\n", irmp_param.pulse_1_len_min, irm
2970:irmp.c        ****                             ANALYZE_PRINTF ("pause_1: %3d - %3d\n", irmp_param.pause_1_len_min, irm
2971:irmp.c        **** #endif // ANALYZE
2972:irmp.c        ****                         }
2973:irmp.c        ****                         else
2974:irmp.c        ****                         {
2975:irmp.c        **** #ifdef ANALYZE
2976:irmp.c        ****                             ANALYZE_PRINTF ("pulse: %3d - %3d or %3d - %3d\n", irmp_param.pulse_1_l
2977:irmp.c        ****                                             2 * irmp_param.pulse_1_len_min, 2 * irmp_param.pulse_1_
2978:irmp.c        ****                             ANALYZE_PRINTF ("pause: %3d - %3d or %3d - %3d\n", irmp_param.pause_1_l
2979:irmp.c        ****                                             2 * irmp_param.pause_1_len_min, 2 * irmp_param.pause_1_
2980:irmp.c        **** #endif // ANALYZE
2981:irmp.c        ****                         }
2982:irmp.c        **** 
2983:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCO
2984:irmp.c        ****                         if (irmp_param2.protocol)
2985:irmp.c        ****                         {
2986:irmp.c        **** #ifdef ANALYZE
2987:irmp.c        ****                             ANALYZE_PRINTF ("pulse_0: %3d - %3d\n", irmp_param2.pulse_0_len_min, ir
2988:irmp.c        ****                             ANALYZE_PRINTF ("pause_0: %3d - %3d\n", irmp_param2.pause_0_len_min, ir
2989:irmp.c        ****                             ANALYZE_PRINTF ("pulse_1: %3d - %3d\n", irmp_param2.pulse_1_len_min, ir
2990:irmp.c        ****                             ANALYZE_PRINTF ("pause_1: %3d - %3d\n", irmp_param2.pause_1_len_min, ir
2991:irmp.c        **** #endif // ANALYZE
2992:irmp.c        ****                         }
2993:irmp.c        **** #endif
2994:irmp.c        **** 
2995:irmp.c        **** 
2996:irmp.c        **** #if IRMP_SUPPORT_RC6_PROTOCOL == 1
2997:irmp.c        ****                         if (irmp_param.protocol == IRMP_RC6_PROTOCOL)
2998:irmp.c        ****                         {
2999:irmp.c        **** #ifdef ANALYZE
3000:irmp.c        ****                             ANALYZE_PRINTF ("pulse_toggle: %3d - %3d\n", RC6_TOGGLE_BIT_LEN_MIN, RC
3001:irmp.c        **** #endif // ANALYZE
3002:irmp.c        ****                         }
3003:irmp.c        **** #endif
3004:irmp.c        **** 
3005:irmp.c        ****                         if (! (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))
3006:irmp.c        ****                         {
3007:irmp.c        **** #ifdef ANALYZE
3008:irmp.c        ****                             ANALYZE_PRINTF ("pulse_0: %3d - %3d\n", irmp_param.pulse_0_len_min, irm
3009:irmp.c        ****                             ANALYZE_PRINTF ("pause_0: %3d - %3d\n", irmp_param.pause_0_len_min, irm
3010:irmp.c        **** #endif // ANALYZE
3011:irmp.c        ****                         }
3012:irmp.c        ****                         else
3013:irmp.c        ****                         {
3014:irmp.c        **** #ifdef ANALYZE
3015:irmp.c        ****                             ANALYZE_PRINTF ("pulse: %3d - %3d or %3d - %3d\n", irmp_param.pulse_0_l
3016:irmp.c        ****                                             2 * irmp_param.pulse_0_len_min, 2 * irmp_param.pulse_0_
3017:irmp.c        ****                             ANALYZE_PRINTF ("pause: %3d - %3d or %3d - %3d\n", irmp_param.pause_0_l
3018:irmp.c        ****                                             2 * irmp_param.pause_0_len_min, 2 * irmp_param.pause_0_
3019:irmp.c        **** #endif // ANALYZE
3020:irmp.c        ****                         }
3021:irmp.c        **** 
3022:irmp.c        **** #ifdef ANALYZE
3023:irmp.c        **** #if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
3024:irmp.c        ****                         if (irmp_param.protocol == IRMP_BANG_OLUFSEN_PROTOCOL)
3025:irmp.c        ****                         {
3026:irmp.c        ****                             ANALYZE_PRINTF ("pulse_r: %3d - %3d\n", irmp_param.pulse_0_len_min, irm
3027:irmp.c        ****                             ANALYZE_PRINTF ("pause_r: %3d - %3d\n", BANG_OLUFSEN_R_PAUSE_LEN_MIN, B
3028:irmp.c        ****                         }
3029:irmp.c        **** #endif
3030:irmp.c        **** 
3031:irmp.c        ****                         ANALYZE_PRINTF ("command_offset: %2d\n", irmp_param.command_offset);
3032:irmp.c        ****                         ANALYZE_PRINTF ("command_len:    %3d\n", irmp_param.command_end - irmp_para
3033:irmp.c        ****                         ANALYZE_PRINTF ("complete_len:   %3d\n", irmp_param.complete_len);
3034:irmp.c        ****                         ANALYZE_PRINTF ("stop_bit:       %3d\n", irmp_param.stop_bit);
3035:irmp.c        **** #endif // ANALYZE
3036:irmp.c        ****                     }
3037:irmp.c        **** 
3038:irmp.c        ****                     irmp_bit = 0;
 483               	68,0,3038,.LM60-.LFBB4
 484               	.LM60:
 485 0220 1092 0000 		sts irmp_bit,__zero_reg__
3039:irmp.c        **** 
3040:irmp.c        **** #if IRMP_SUPPORT_MANCHESTER == 1
3041:irmp.c        ****                     if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
 486               	tabn	68,0,3041,.LM61-.LFBB4
 487               	.LM61:
 488 0224 8091 0000 		lds r24,irmp_param+16
 489 0228 482F      		mov r20,r24
 490 022a 50E0      		ldi r21,lo8(0)
 491 022c 80FF      		sbrs r24,0
 492 022e 00C0      		rjmp .L30
 493 0230 8091 0000 		lds r24,irmp_param
 494 0234 8731      		cpi r24,lo8(23)
 495 0236 01F0      		breq .L30
 496 0238 8930      		cpi r24,lo8(9)
 497 023a 01F0      		breq .L30
3042:irmp.c        ****                          irmp_param.protocol != IRMP_RUWIDO_PROTOCOL && // Manchester, but not RUWI
3043:irmp.c        ****                          irmp_param.protocol != IRMP_RC6_PROTOCOL)      // Manchester, but not RC6
3044:irmp.c        ****                     {
3045:irmp.c        ****                         if (irmp_pause_time > irmp_param.pulse_1_len_max && irmp_pause_time <= 2 * 
 498               	,3045,.LM62-.LFBB4
 499               	.LM62:
 500 023c 2091 0000 		lds r18,irmp_pause_time.1729
 501 0240 8091 0000 		lds r24,irmp_param+2
 502 0244 8217      		cp r24,r18
 503 0246 00F4      		brsh .L31
 504 0248 30E0      		ldi r19,lo8(0)
 505 024a 90E0      		ldi r25,lo8(0)
 506 024c 880F      		lsl r24
 507 024e 991F      		rol r25
 508 0250 8217      		cp r24,r18
 509 0252 9307      		cpc r25,r19
 510 0254 04F0      		brlt .L31
3046:irmp.c        ****                         {
3047:irmp.c        **** #ifdef ANALYZE
3048:irmp.c        ****                             ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double
3049:irmp.c        ****                             ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 
3050:irmp.c        ****                             ANALYZE_NEWLINE ();
3051:irmp.c        **** #endif // ANALYZE
3052:irmp.c        ****                             irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 0
 511               	3052,.LM63-.LFBB4
 512               	.LM63:
 513 0256 5695      		lsr r21
 514 0258 4795      		ror r20
 515 025a 842F      		mov r24,r20
 516 025c 8095      		com r24
 517 025e 00C0      		rjmp .L56
 518               	.L31:
3053:irmp.c        ****                         }
3054:irmp.c        ****                         else if (! last_value)  // && irmp_pause_time >= irmp_param.pause_1_len_min
 519               	68,0,3054,.LM64-.LFBB4
 520               	.LM64:
 521 0260 8091 0000 		lds r24,last_value.1736
 522 0264 8823      		tst r24
 523 0266 01F4      		brne .L30
3055:irmp.c        ****                         {
3056:irmp.c        **** #ifdef ANALYZE
3057:irmp.c        ****                             ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double
3058:irmp.c        ****                             ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 
3059:irmp.c        ****                             ANALYZE_NEWLINE ();
3060:irmp.c        **** #endif // ANALYZE
3061:irmp.c        ****                             irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1
 524               	bn	68,0,3061,.LM65-.LFBB4
 525               	.LM65:
 526 0268 5695      		lsr r21
 527 026a 4795      		ror r20
 528 026c 842F      		mov r24,r20
 529               	.L56:
 530 026e 8170      		andi r24,lo8(1)
 531 0270 00D0      		rcall irmp_store_bit
 532               	.L30:
3062:irmp.c        ****                         }
3063:irmp.c        ****                     }
3064:irmp.c        ****                     else
3065:irmp.c        **** #endif // IRMP_SUPPORT_MANCHESTER == 1
3066:irmp.c        **** 
3067:irmp.c        **** #if IRMP_SUPPORT_SERIAL == 1
3068:irmp.c        ****                     if (irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL)
3069:irmp.c        ****                     {
3070:irmp.c        ****                         ; // do nothing
3071:irmp.c        ****                     }
3072:irmp.c        ****                     else
3073:irmp.c        **** #endif // IRMP_SUPPORT_SERIAL == 1
3074:irmp.c        **** 
3075:irmp.c        **** 
3076:irmp.c        **** #if IRMP_SUPPORT_DENON_PROTOCOL == 1
3077:irmp.c        ****                     if (irmp_param.protocol == IRMP_DENON_PROTOCOL)
3078:irmp.c        ****                     {
3079:irmp.c        **** #ifdef ANALYZE
3080:irmp.c        ****                         ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double) (t
3081:irmp.c        **** #endif // ANALYZE
3082:irmp.c        **** 
3083:irmp.c        ****                         if (irmp_pause_time >= DENON_1_PAUSE_LEN_MIN && irmp_pause_time <= DENON_1_
3084:irmp.c        ****                         {                                                       // pause timings co
3085:irmp.c        **** #ifdef ANALYZE
3086:irmp.c        ****                             ANALYZE_PUTCHAR ('1');                                  // yes, store 1
3087:irmp.c        ****                             ANALYZE_NEWLINE ();
3088:irmp.c        **** #endif // ANALYZE
3089:irmp.c        ****                             irmp_store_bit (1);
3090:irmp.c        ****                         }
3091:irmp.c        ****                         else // if (irmp_pause_time >= DENON_0_PAUSE_LEN_MIN && irmp_pause_time <= 
3092:irmp.c        ****                         {                                                       // pause timings co
3093:irmp.c        **** #ifdef ANALYZE
3094:irmp.c        ****                             ANALYZE_PUTCHAR ('0');                                  // yes, store 0
3095:irmp.c        ****                             ANALYZE_NEWLINE ();
3096:irmp.c        **** #endif // ANALYZE
3097:irmp.c        ****                             irmp_store_bit (0);
3098:irmp.c        ****                         }
3099:irmp.c        ****                     }
3100:irmp.c        ****                     else
3101:irmp.c        **** #endif // IRMP_SUPPORT_DENON_PROTOCOL == 1
3102:irmp.c        **** #if IRMP_SUPPORT_THOMSON_PROTOCOL == 1
3103:irmp.c        ****                     if (irmp_param.protocol == IRMP_THOMSON_PROTOCOL)
3104:irmp.c        ****                     {
3105:irmp.c        **** #ifdef ANALYZE
3106:irmp.c        ****                         ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double) (t
3107:irmp.c        **** #endif // ANALYZE
3108:irmp.c        **** 
3109:irmp.c        ****                         if (irmp_pause_time >= THOMSON_1_PAUSE_LEN_MIN && irmp_pause_time <= THOMSO
3110:irmp.c        ****                         {                                                       // pause timings co
3111:irmp.c        **** #ifdef ANALYZE
3112:irmp.c        ****                           ANALYZE_PUTCHAR ('1');                                  // yes, store 1
3113:irmp.c        ****                           ANALYZE_NEWLINE ();
3114:irmp.c        **** #endif // ANALYZE
3115:irmp.c        ****                           irmp_store_bit (1);
3116:irmp.c        ****                         }
3117:irmp.c        ****                         else // if (irmp_pause_time >= THOMSON_0_PAUSE_LEN_MIN && irmp_pause_time <
3118:irmp.c        ****                         {                                                       // pause timings co
3119:irmp.c        **** #ifdef ANALYZE
3120:irmp.c        ****                           ANALYZE_PUTCHAR ('0');                                  // yes, store 0
3121:irmp.c        ****                           ANALYZE_NEWLINE ();
3122:irmp.c        **** #endif // ANALYZE
3123:irmp.c        ****                           irmp_store_bit (0);
3124:irmp.c        ****                         }
3125:irmp.c        ****                     }
3126:irmp.c        ****                     else
3127:irmp.c        **** #endif // IRMP_SUPPORT_THOMSON_PROTOCOL == 1
3128:irmp.c        ****                     {
3129:irmp.c        ****                         ;                                                       // else do nothing
3130:irmp.c        ****                     }
3131:irmp.c        **** 
3132:irmp.c        ****                     irmp_pulse_time = 1;                                        // set counter to 1
 533               	8,0,3132,.LM66-.LFBB4
 534               	.LM66:
 535 0272 81E0      		ldi r24,lo8(1)
 536 0274 8093 0000 		sts irmp_pulse_time.1728,r24
3133:irmp.c        ****                     irmp_pause_time = 0;
 537               	abn	68,0,3133,.LM67-.LFBB4
 538               	.LM67:
 539 0278 1092 0000 		sts irmp_pause_time.1729,__zero_reg__
3134:irmp.c        ****                     wait_for_start_space = 0;
 540               	tabn	68,0,3134,.LM68-.LFBB4
 541               	.LM68:
 542 027c 1092 0000 		sts wait_for_start_space.1727,__zero_reg__
 543 0280 00C0      		rjmp .L22
 544               	.L20:
 545               	.LBE2:
3135:irmp.c        ****                 }
3136:irmp.c        ****             }
3137:irmp.c        ****             else if (wait_for_space)                                            // the data section
 546               	n	68,0,3137,.LM69-.LFBB4
 547               	.LM69:
 548 0282 8091 0000 		lds r24,wait_for_space.1726
 549 0286 8823      		tst r24
 550 0288 01F4      		brne .+2
 551 028a 00C0      		rjmp .L32
 552               	.LBB3:
3138:irmp.c        ****             {                                                                   // counting the tim
3139:irmp.c        ****                 uint8_t got_light = FALSE;
3140:irmp.c        **** 
3141:irmp.c        ****                 if (irmp_input)                                                 // still dark?
 553               		68,0,3141,.LM70-.LFBB4
 554               	.LM70:
 555 028c 2223      		tst r18
 556 028e 01F4      		brne .+2
 557 0290 00C0      		rjmp .L33
3142:irmp.c        ****                 {                                                               // yes...
3143:irmp.c        ****                     if (irmp_bit == irmp_param.complete_len && irmp_param.stop_bit == 1)
 558               	bn	68,0,3143,.LM71-.LFBB4
 559               	.LM71:
 560 0292 5091 0000 		lds r21,irmp_bit
 561 0296 6091 0000 		lds r22,irmp_param+13
 562 029a 5617      		cp r21,r22
 563 029c 01F4      		brne .L34
 564 029e 8091 0000 		lds r24,irmp_param+14
 565 02a2 8130      		cpi r24,lo8(1)
 566 02a4 01F4      		brne .L34
3144:irmp.c        ****                     {
3145:irmp.c        ****                         if (
 567               	8,0,3145,.LM72-.LFBB4
 568               	.LM72:
 569 02a6 8091 0000 		lds r24,irmp_param+16
 570 02aa 80FD      		sbrc r24,0
 571 02ac 00C0      		rjmp .L35
 572 02ae 9091 0000 		lds r25,irmp_pulse_time.1728
 573 02b2 8091 0000 		lds r24,irmp_param+5
 574 02b6 9817      		cp r25,r24
 575 02b8 00F0      		brlo .L38
 576 02ba 8091 0000 		lds r24,irmp_param+6
 577 02be 8917      		cp r24,r25
 578 02c0 00F0      		brlo .L38
 579               	.L35:
3146:irmp.c        **** #if IRMP_SUPPORT_MANCHESTER == 1
3147:irmp.c        ****                             (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) ||
3148:irmp.c        **** #endif
3149:irmp.c        **** #if IRMP_SUPPORT_SERIAL == 1
3150:irmp.c        ****                             (irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL) ||
3151:irmp.c        **** #endif
3152:irmp.c        ****                             (irmp_pulse_time >= irmp_param.pulse_0_len_min && irmp_pulse_time <= ir
3153:irmp.c        ****                         {
3154:irmp.c        **** #ifdef ANALYZE
3155:irmp.c        ****                             if (! (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))
3156:irmp.c        ****                             {
3157:irmp.c        ****                                 ANALYZE_PRINTF ("stop bit detected\n");
3158:irmp.c        ****                             }
3159:irmp.c        **** #endif // ANALYZE
3160:irmp.c        ****                             irmp_param.stop_bit = 0;
 580               	3160,.LM73-.LFBB4
 581               	.LM73:
 582 02c2 1092 0000 		sts irmp_param+14,__zero_reg__
 583 02c6 00C0      		rjmp .L22
 584               	.L34:
3161:irmp.c        ****                         }
3162:irmp.c        ****                         else
3163:irmp.c        ****                         {
3164:irmp.c        **** #ifdef ANALYZE
3165:irmp.c        ****                             ANALYZE_PRINTF ("error: stop bit timing wrong, irmp_bit = %d, irmp_puls
3166:irmp.c        ****                                             irmp_bit, irmp_pulse_time, irmp_param.pulse_0_len_min, 
3167:irmp.c        **** #endif // ANALYZE
3168:irmp.c        ****                             irmp_start_bit_detected = 0;                        // wait for another
3169:irmp.c        ****                             irmp_pulse_time         = 0;
3170:irmp.c        ****                             irmp_pause_time         = 0;
3171:irmp.c        ****                         }
3172:irmp.c        ****                     }
3173:irmp.c        ****                     else
3174:irmp.c        ****                     {
3175:irmp.c        ****                         irmp_pause_time++;                                                         
 585               	bn	68,0,3175,.LM74-.LFBB4
 586               	.LM74:
 587 02c8 4091 0000 		lds r20,irmp_pause_time.1729
 588 02cc 4F5F      		subi r20,lo8(-(1))
 589 02ce 4093 0000 		sts irmp_pause_time.1729,r20
3176:irmp.c        **** 
3177:irmp.c        **** #if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
3178:irmp.c        ****                         if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL &&                          
3179:irmp.c        ****                             irmp_pause_time > SIRCS_PAUSE_LEN_MAX &&                               
3180:irmp.c        ****                             irmp_bit >= 12 - 1)                                                    
3181:irmp.c        ****                         {                                                                          
3182:irmp.c        ****                             irmp_param.complete_len = irmp_bit + 1;                                
3183:irmp.c        ****                             got_light = TRUE;                                                      
3184:irmp.c        ****                             irmp_tmp_address |= (irmp_bit - SIRCS_MINIMUM_DATA_LEN + 1) << 8;      
3185:irmp.c        ****                             irmp_param.command_end = irmp_param.command_offset + irmp_bit + 1;     
3186:irmp.c        ****                             irmp_pause_time = SIRCS_PAUSE_LEN_MAX - 1;                             
3187:irmp.c        ****                         }
3188:irmp.c        ****                         else
3189:irmp.c        **** #endif
3190:irmp.c        **** #if IRMP_SUPPORT_SERIAL == 1
3191:irmp.c        ****                         // NETBOX generates no stop bit, here is the timeout condition:
3192:irmp.c        ****                         if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL) && irmp_param.protocol =
3193:irmp.c        ****                             irmp_pause_time >= NETBOX_PULSE_LEN * (NETBOX_COMPLETE_DATA_LEN - irmp_
3194:irmp.c        ****                         {
3195:irmp.c        ****                             got_light = TRUE;                                                      
3196:irmp.c        ****                         }
3197:irmp.c        ****                         else
3198:irmp.c        **** #endif
3199:irmp.c        **** #if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
3200:irmp.c        ****                         if (irmp_param.protocol == IRMP_GRUNDIG_PROTOCOL && !irmp_param.stop_bit)
3201:irmp.c        ****                         {
3202:irmp.c        ****                             if (irmp_pause_time > IR60_TIMEOUT_LEN && (irmp_bit == 5 || irmp_bit ==
3203:irmp.c        ****                             {
3204:irmp.c        **** #ifdef ANALYZE
3205:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to IR60 protocol\n");
3206:irmp.c        **** #endif // ANALYZE
3207:irmp.c        ****                                 got_light = TRUE;                                       // this is 
3208:irmp.c        ****                                 irmp_param.stop_bit = TRUE;                             // set flag
3209:irmp.c        **** 
3210:irmp.c        ****                                 irmp_param.protocol         = IRMP_IR60_PROTOCOL;       // change p
3211:irmp.c        ****                                 irmp_param.complete_len     = IR60_COMPLETE_DATA_LEN;   // correct 
3212:irmp.c        ****                                 irmp_param.address_offset   = IR60_ADDRESS_OFFSET;
3213:irmp.c        ****                                 irmp_param.address_end      = IR60_ADDRESS_OFFSET + IR60_ADDRESS_LE
3214:irmp.c        ****                                 irmp_param.command_offset   = IR60_COMMAND_OFFSET;
3215:irmp.c        ****                                 irmp_param.command_end      = IR60_COMMAND_OFFSET + IR60_COMMAND_LE
3216:irmp.c        **** 
3217:irmp.c        ****                                 irmp_tmp_command <<= 1;
3218:irmp.c        ****                                 irmp_tmp_command |= first_bit;
3219:irmp.c        ****                             }
3220:irmp.c        ****                             else if (irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit 
3221:irmp.c        ****                             {                                                           // special 
3222:irmp.c        ****                                 irmp_param.complete_len = GRUNDIG_COMPLETE_DATA_LEN;    // correct 
3223:irmp.c        ****                                 got_light = TRUE;                                       // this is 
3224:irmp.c        ****                                 irmp_param.stop_bit = TRUE;                             // set flag
3225:irmp.c        ****                             }
3226:irmp.c        ****                             else if (irmp_bit >= GRUNDIG_COMPLETE_DATA_LEN)
3227:irmp.c        ****                             {
3228:irmp.c        **** #ifdef ANALYZE
3229:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to NOKIA protocol\n");
3230:irmp.c        **** #endif // ANALYZE
3231:irmp.c        ****                                 irmp_param.protocol         = IRMP_NOKIA_PROTOCOL;      // change p
3232:irmp.c        ****                                 irmp_param.address_offset   = NOKIA_ADDRESS_OFFSET;
3233:irmp.c        ****                                 irmp_param.address_end      = NOKIA_ADDRESS_OFFSET + NOKIA_ADDRESS_
3234:irmp.c        ****                                 irmp_param.command_offset   = NOKIA_COMMAND_OFFSET;
3235:irmp.c        ****                                 irmp_param.command_end      = NOKIA_COMMAND_OFFSET + NOKIA_COMMAND_
3236:irmp.c        **** 
3237:irmp.c        ****                                 if (irmp_tmp_command & 0x300)
3238:irmp.c        ****                                 {
3239:irmp.c        ****                                     irmp_tmp_address = (irmp_tmp_command >> 8);
3240:irmp.c        ****                                     irmp_tmp_command &= 0xFF;
3241:irmp.c        ****                                 }
3242:irmp.c        ****                             }
3243:irmp.c        ****                         }
3244:irmp.c        ****                         else
3245:irmp.c        **** #endif
3246:irmp.c        **** #if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
3247:irmp.c        ****                         if (irmp_param.protocol == IRMP_RUWIDO_PROTOCOL && !irmp_param.stop_bit)
3248:irmp.c        ****                         {
3249:irmp.c        ****                             if (irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit >= RU
3250:irmp.c        ****                             {                                                           // special 
3251:irmp.c        ****                                 irmp_param.complete_len = RUWIDO_COMPLETE_DATA_LEN;     // correct 
3252:irmp.c        ****                                 got_light = TRUE;                                       // this is 
3253:irmp.c        ****                                 irmp_param.stop_bit = TRUE;                             // set flag
3254:irmp.c        ****                             }
3255:irmp.c        ****                             else if (irmp_bit >= RUWIDO_COMPLETE_DATA_LEN)
3256:irmp.c        ****                             {
3257:irmp.c        **** #ifdef ANALYZE
3258:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to SIEMENS protocol\n");
3259:irmp.c        **** #endif // ANALYZE
3260:irmp.c        ****                                 irmp_param.protocol         = IRMP_SIEMENS_PROTOCOL;    // change p
3261:irmp.c        ****                                 irmp_param.address_offset   = SIEMENS_ADDRESS_OFFSET;
3262:irmp.c        ****                                 irmp_param.address_end      = SIEMENS_ADDRESS_OFFSET + SIEMENS_ADDR
3263:irmp.c        ****                                 irmp_param.command_offset   = SIEMENS_COMMAND_OFFSET;
3264:irmp.c        ****                                 irmp_param.command_end      = SIEMENS_COMMAND_OFFSET + SIEMENS_COMM
3265:irmp.c        **** 
3266:irmp.c        ****                                 //                   76543210
3267:irmp.c        ****                                 // RUWIDO:  AAAAAAAAACCCCCCCp
3268:irmp.c        ****                                 // SIEMENS: AAAAAAAAAAACCCCCCCCCCp
3269:irmp.c        ****                                 irmp_tmp_address <<= 2;
3270:irmp.c        ****                                 irmp_tmp_address |= (irmp_tmp_command >> 6);
3271:irmp.c        ****                                 irmp_tmp_command &= 0x003F;
3272:irmp.c        **** //                              irmp_tmp_command <<= 4;
3273:irmp.c        ****                                 irmp_tmp_command |= last_value;
3274:irmp.c        ****                             }
3275:irmp.c        ****                         }
3276:irmp.c        ****                         else
3277:irmp.c        **** #endif
3278:irmp.c        **** #if IRMP_SUPPORT_ROOMBA_PROTOCOL == 1
3279:irmp.c        ****                         if (irmp_param.protocol == IRMP_ROOMBA_PROTOCOL &&                         
3280:irmp.c        ****                             irmp_bit >= ROOMBA_COMPLETE_DATA_LEN - 1)                              
3281:irmp.c        ****                         {                                                                          
3282:irmp.c        ****                             if (irmp_pulse_time >= ROOMBA_1_PULSE_LEN_MIN && irmp_pulse_time <= ROO
3283:irmp.c        ****                             {
3284:irmp.c        ****                                 irmp_pause_time = ROOMBA_1_PAUSE_LEN_EXACT;
3285:irmp.c        ****                             }
3286:irmp.c        ****                             else if (irmp_pulse_time >= ROOMBA_0_PULSE_LEN_MIN && irmp_pulse_time <
3287:irmp.c        ****                             {
3288:irmp.c        ****                                 irmp_pause_time = ROOMBA_0_PAUSE_LEN;
3289:irmp.c        ****                             }
3290:irmp.c        **** 
3291:irmp.c        ****                             got_light = TRUE;                                                      
3292:irmp.c        ****                         }
3293:irmp.c        ****                         else
3294:irmp.c        **** #endif
3295:irmp.c        **** #if IRMP_SUPPORT_MANCHESTER == 1
3296:irmp.c        ****                         if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
 590               	bn	68,0,3296,.LM75-.LFBB4
 591               	.LM75:
 592 02d2 8091 0000 		lds r24,irmp_param+16
 593 02d6 80FF      		sbrs r24,0
 594 02d8 00C0      		rjmp .L37
 595 02da 242F      		mov r18,r20
 596 02dc 30E0      		ldi r19,lo8(0)
 597 02de 8091 0000 		lds r24,irmp_param+4
 598 02e2 90E0      		ldi r25,lo8(0)
 599 02e4 880F      		lsl r24
 600 02e6 991F      		rol r25
 601 02e8 2817      		cp r18,r24
 602 02ea 3907      		cpc r19,r25
 603 02ec 04F0      		brlt .L37
 604 02ee 252F      		mov r18,r21
 605 02f0 30E0      		ldi r19,lo8(0)
 606 02f2 862F      		mov r24,r22
 607 02f4 90E0      		ldi r25,lo8(0)
 608 02f6 0297      		sbiw r24,2
 609 02f8 2817      		cp r18,r24
 610 02fa 3907      		cpc r19,r25
 611 02fc 04F0      		brlt .L37
 612 02fe 8091 0000 		lds r24,irmp_param+14
 613 0302 8823      		tst r24
 614 0304 01F4      		brne .L37
3297:irmp.c        ****                             irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit >= irmp_p
3298:irmp.c        ****                         {                                                       // special manchest
3299:irmp.c        ****                             got_light = TRUE;                                   // this is a lie, b
3300:irmp.c        ****                             irmp_param.stop_bit = TRUE;                         // set flag
 615               	LFBB4
 616               	.LM76:
 617 0306 81E0      		ldi r24,lo8(1)
 618 0308 8093 0000 		sts irmp_param+14,r24
 619 030c 00C0      		rjmp .L33
 620               	.L37:
3301:irmp.c        ****                         }
3302:irmp.c        ****                         else
3303:irmp.c        **** #endif // IRMP_SUPPORT_MANCHESTER == 1
3304:irmp.c        ****                         if (irmp_pause_time > IRMP_TIMEOUT_LEN)                 // timeout?
 621               	n	68,0,3304,.LM77-.LFBB4
 622               	.LM77:
 623 030e 4C39      		cpi r20,lo8(-100)
 624 0310 00F4      		brsh .+2
 625 0312 00C0      		rjmp .L22
3305:irmp.c        ****                         {                                                       // yes...
3306:irmp.c        ****                             if (irmp_bit == irmp_param.complete_len - 1 && irmp_param.stop_bit == 0
 626               	bn	68,0,3306,.LM78-.LFBB4
 627               	.LM78:
 628 0314 252F      		mov r18,r21
 629 0316 30E0      		ldi r19,lo8(0)
 630 0318 862F      		mov r24,r22
 631 031a 90E0      		ldi r25,lo8(0)
 632 031c 0197      		sbiw r24,1
 633 031e 2817      		cp r18,r24
 634 0320 3907      		cpc r19,r25
 635 0322 01F4      		brne .L38
 636 0324 8091 0000 		lds r24,irmp_param+14
 637 0328 8823      		tst r24
 638 032a 01F4      		brne .L38
3307:irmp.c        ****                             {
3308:irmp.c        ****                                 irmp_bit++;
 639               	3308,.LM79-.LFBB4
 640               	.LM79:
 641 032c 5F5F      		subi r21,lo8(-(1))
 642 032e 5093 0000 		sts irmp_bit,r21
 643 0332 00C0      		rjmp .L22
 644               	.L38:
3309:irmp.c        ****                             }
3310:irmp.c        **** #if IRMP_SUPPORT_JVC_PROTOCOL == 1
3311:irmp.c        ****                             else if (irmp_param.protocol == IRMP_NEC_PROTOCOL && (irmp_bit == 16 ||
3312:irmp.c        ****                             {
3313:irmp.c        **** #ifdef ANALYZE
3314:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to JVC protocol, irmp_bit = %d\n", irmp_
3315:irmp.c        **** #endif // ANALYZE
3316:irmp.c        ****                                 irmp_param.stop_bit     = TRUE;                                    
3317:irmp.c        ****                                 irmp_param.protocol     = IRMP_JVC_PROTOCOL;                       
3318:irmp.c        ****                                 irmp_param.complete_len = irmp_bit;                                
3319:irmp.c        ****                                 irmp_tmp_command        = (irmp_tmp_address >> 4);                 
3320:irmp.c        ****                                 irmp_tmp_address        = irmp_tmp_address & 0x000F;               
3321:irmp.c        ****                                 irmp_start_bit_detected = 1;                                       
3322:irmp.c        ****                             }
3323:irmp.c        **** #endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
3324:irmp.c        **** #if IRMP_SUPPORT_LGAIR_PROTOCOL == 1
3325:irmp.c        ****                             else if (irmp_param.protocol == IRMP_NEC_PROTOCOL && (irmp_bit == 28 ||
3326:irmp.c        ****                             {
3327:irmp.c        **** #ifdef ANALYZE
3328:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to LGAIR protocol, irmp_bit = %d\n", irm
3329:irmp.c        **** #endif // ANALYZE
3330:irmp.c        ****                                 irmp_param.stop_bit     = TRUE;                                    
3331:irmp.c        ****                                 irmp_param.protocol     = IRMP_LGAIR_PROTOCOL;                     
3332:irmp.c        ****                                 irmp_param.complete_len = irmp_bit;                                
3333:irmp.c        ****                                 irmp_tmp_command        = irmp_lgair_command;                      
3334:irmp.c        ****                                 irmp_tmp_address        = irmp_lgair_address;                      
3335:irmp.c        ****                                 irmp_start_bit_detected = 1;                                       
3336:irmp.c        ****                             }
3337:irmp.c        **** #endif // IRMP_SUPPORT_LGAIR_PROTOCOL == 1
3338:irmp.c        **** 
3339:irmp.c        **** #if IRMP_SUPPORT_NEC42_PROTOCOL == 1
3340:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
3341:irmp.c        ****                             else if (irmp_param.protocol == IRMP_NEC42_PROTOCOL && irmp_bit == 32) 
3342:irmp.c        ****                             {
3343:irmp.c        **** #ifdef ANALYZE
3344:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to NEC protocol\n");
3345:irmp.c        **** #endif // ANALYZE
3346:irmp.c        ****                                 irmp_param.stop_bit     = TRUE;                                    
3347:irmp.c        ****                                 irmp_param.protocol     = IRMP_NEC_PROTOCOL;                       
3348:irmp.c        ****                                 irmp_param.complete_len = irmp_bit;                                
3349:irmp.c        **** 
3350:irmp.c        ****                                 //        0123456789ABC0123456789ABC0123456701234567
3351:irmp.c        ****                                 // NEC42: AAAAAAAAAAAAAaaaaaaaaaaaaaCCCCCCCCcccccccc
3352:irmp.c        ****                                 // NEC:   AAAAAAAAaaaaaaaaCCCCCCCCcccccccc
3353:irmp.c        ****                                 irmp_tmp_address        |= (irmp_tmp_address2 & 0x0007) << 13;     
3354:irmp.c        ****                                 irmp_tmp_command        = (irmp_tmp_address2 >> 3) | (irmp_tmp_comm
3355:irmp.c        ****                             }
3356:irmp.c        **** #endif // IRMP_SUPPORT_NEC_PROTOCOL == 1
3357:irmp.c        **** #if IRMP_SUPPORT_LGAIR_PROTOCOL == 1
3358:irmp.c        ****                             else if (irmp_param.protocol == IRMP_NEC42_PROTOCOL && irmp_bit == 28) 
3359:irmp.c        ****                             {
3360:irmp.c        **** #ifdef ANALYZE
3361:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to LGAIR protocol\n");
3362:irmp.c        **** #endif // ANALYZE
3363:irmp.c        ****                                 irmp_param.stop_bit     = TRUE;                                    
3364:irmp.c        ****                                 irmp_param.protocol     = IRMP_LGAIR_PROTOCOL;                     
3365:irmp.c        ****                                 irmp_param.complete_len = irmp_bit;                                
3366:irmp.c        ****                                 irmp_tmp_address        = irmp_lgair_address;
3367:irmp.c        ****                                 irmp_tmp_command        = irmp_lgair_command;
3368:irmp.c        ****                             }
3369:irmp.c        **** #endif // IRMP_SUPPORT_LGAIR_PROTOCOL == 1
3370:irmp.c        **** #if IRMP_SUPPORT_JVC_PROTOCOL == 1
3371:irmp.c        ****                             else if (irmp_param.protocol == IRMP_NEC42_PROTOCOL && (irmp_bit == 16 
3372:irmp.c        ****                             {
3373:irmp.c        **** #ifdef ANALYZE
3374:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to JVC protocol, irmp_bit = %d\n", irmp_
3375:irmp.c        **** #endif // ANALYZE
3376:irmp.c        ****                                 irmp_param.stop_bit     = TRUE;                                    
3377:irmp.c        ****                                 irmp_param.protocol     = IRMP_JVC_PROTOCOL;                       
3378:irmp.c        ****                                 irmp_param.complete_len = irmp_bit;                                
3379:irmp.c        **** 
3380:irmp.c        ****                                 //        0123456789ABC0123456789ABC0123456701234567
3381:irmp.c        ****                                 // NEC42: AAAAAAAAAAAAAaaaaaaaaaaaaaCCCCCCCCcccccccc
3382:irmp.c        ****                                 // JVC:   AAAACCCCCCCCCCCC
3383:irmp.c        ****                                 irmp_tmp_command        = (irmp_tmp_address >> 4) | (irmp_tmp_addre
3384:irmp.c        ****                                 irmp_tmp_address        = irmp_tmp_address & 0x000F;               
3385:irmp.c        ****                             }
3386:irmp.c        **** #endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
3387:irmp.c        **** #endif // IRMP_SUPPORT_NEC42_PROTOCOL == 1
3388:irmp.c        **** 
3389:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG48_PROTOCOL == 1
3390:irmp.c        ****                             else if (irmp_param.protocol == IRMP_SAMSUNG48_PROTOCOL && irmp_bit == 
3391:irmp.c        ****                             {
3392:irmp.c        **** #ifdef ANALYZE
3393:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to SAMSUNG32 protocol\n");
3394:irmp.c        **** #endif // ANALYZE
3395:irmp.c        ****                                 irmp_param.protocol         = IRMP_SAMSUNG32_PROTOCOL;
3396:irmp.c        ****                                 irmp_param.command_offset   = SAMSUNG32_COMMAND_OFFSET;
3397:irmp.c        ****                                 irmp_param.command_end      = SAMSUNG32_COMMAND_OFFSET + SAMSUNG32_
3398:irmp.c        ****                                 irmp_param.complete_len     = SAMSUNG32_COMPLETE_DATA_LEN;
3399:irmp.c        ****                             }
3400:irmp.c        **** #endif // IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
3401:irmp.c        **** 
3402:irmp.c        **** #if IRMP_SUPPORT_RCMM_PROTOCOL == 1
3403:irmp.c        ****                             else if (irmp_param.protocol == IRMP_RCMM32_PROTOCOL && (irmp_bit == 12
3404:irmp.c        ****                             {
3405:irmp.c        ****                                 if (irmp_bit == 12)
3406:irmp.c        ****                                 {
3407:irmp.c        ****                                     irmp_tmp_command = (irmp_tmp_address & 0xFF);                  
3408:irmp.c        ****                                     irmp_tmp_address >>= 8;                                        
3409:irmp.c        **** 
3410:irmp.c        **** #ifdef ANALYZE
3411:irmp.c        ****                                     ANALYZE_PRINTF ("Switching to RCMM12 protocol, irmp_bit = %d\n"
3412:irmp.c        **** #endif // ANALYZE
3413:irmp.c        ****                                     irmp_param.protocol     = IRMP_RCMM12_PROTOCOL;                
3414:irmp.c        ****                                 }
3415:irmp.c        ****                                 else // if ((irmp_bit == 24)
3416:irmp.c        ****                                 {
3417:irmp.c        **** #ifdef ANALYZE
3418:irmp.c        ****                                     ANALYZE_PRINTF ("Switching to RCMM24 protocol, irmp_bit = %d\n"
3419:irmp.c        **** #endif // ANALYZE
3420:irmp.c        ****                                     irmp_param.protocol     = IRMP_RCMM24_PROTOCOL;                
3421:irmp.c        ****                                 }
3422:irmp.c        ****                                 irmp_param.stop_bit     = TRUE;                                    
3423:irmp.c        ****                                 irmp_param.complete_len = irmp_bit;                                
3424:irmp.c        ****                             }
3425:irmp.c        **** #endif // IRMP_SUPPORT_RCMM_PROTOCOL == 1
3426:irmp.c        ****                             else
3427:irmp.c        ****                             {
3428:irmp.c        **** #ifdef ANALYZE
3429:irmp.c        ****                                 ANALYZE_PRINTF ("error 2: pause %d after data bit %d too long\n", i
3430:irmp.c        ****                                 ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
3431:irmp.c        **** #endif // ANALYZE
3432:irmp.c        ****                                 irmp_start_bit_detected = 0;                    // wait for another
 645               	n	68,0,3432,.LM80-.LFBB4
 646               	.LM80:
 647 0334 1092 0000 		sts irmp_start_bit_detected.1725,__zero_reg__
3433:irmp.c        ****                                 irmp_pulse_time         = 0;
 648               	tabn	68,0,3433,.LM81-.LFBB4
 649               	.LM81:
 650 0338 1092 0000 		sts irmp_pulse_time.1728,__zero_reg__
3434:irmp.c        ****                                 irmp_pause_time         = 0;
 651               	tabn	68,0,3434,.LM82-.LFBB4
 652               	.LM82:
 653 033c 1092 0000 		sts irmp_pause_time.1729,__zero_reg__
 654 0340 00C0      		rjmp .L22
 655               	.L33:
3435:irmp.c        ****                             }
3436:irmp.c        ****                         }
3437:irmp.c        ****                     }
3438:irmp.c        ****                 }
3439:irmp.c        ****                 else
3440:irmp.c        ****                 {                                                               // got light now!
3441:irmp.c        ****                     got_light = TRUE;
3442:irmp.c        ****                 }
3443:irmp.c        **** 
3444:irmp.c        ****                 if (got_light)
3445:irmp.c        ****                 {
3446:irmp.c        **** #ifdef ANALYZE
3447:irmp.c        ****                     ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double) (time_
3448:irmp.c        **** #endif // ANALYZE
3449:irmp.c        **** 
3450:irmp.c        **** #if IRMP_SUPPORT_MANCHESTER == 1
3451:irmp.c        ****                     if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))                        
 656               	bn	68,0,3451,.LM83-.LFBB4
 657               	.LM83:
 658 0342 8091 0000 		lds r24,irmp_param+16
 659 0346 282F      		mov r18,r24
 660 0348 30E0      		ldi r19,lo8(0)
 661 034a 9091 0000 		lds r25,irmp_pulse_time.1728
 662 034e 80FF      		sbrs r24,0
 663 0350 00C0      		rjmp .L39
3452:irmp.c        ****                     {
3453:irmp.c        **** #if 1
3454:irmp.c        ****                         if (irmp_pulse_time > irmp_param.pulse_1_len_max /* && irmp_pulse_time <= 2
 664               	68,0,3454,.LM84-.LFBB4
 665               	.LM84:
 666 0352 8091 0000 		lds r24,irmp_param+2
 667 0356 8917      		cp r24,r25
 668 0358 00F4      		brsh .L40
3455:irmp.c        **** #else // better, but some IR-RCs use asymmetric timings :-/
3456:irmp.c        ****                         if (irmp_pulse_time > irmp_param.pulse_1_len_max && irmp_pulse_time <= 2 * 
3457:irmp.c        ****                             irmp_pause_time <= 2 * irmp_param.pause_1_len_max)
3458:irmp.c        **** #endif
3459:irmp.c        ****                         {
3460:irmp.c        **** #if IRMP_SUPPORT_RC6_PROTOCOL == 1
3461:irmp.c        ****                             if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 4 && irmp_p
3462:irmp.c        ****                             {
3463:irmp.c        **** #ifdef ANALYZE
3464:irmp.c        ****                                 ANALYZE_PUTCHAR ('T');
3465:irmp.c        **** #endif // ANALYZE
3466:irmp.c        ****                                 if (irmp_param.complete_len == RC6_COMPLETE_DATA_LEN_LONG)         
3467:irmp.c        ****                                 {
3468:irmp.c        ****                                     irmp_store_bit (1);
3469:irmp.c        ****                                     last_value = 1;
3470:irmp.c        ****                                 }
3471:irmp.c        ****                                 else                                                               
3472:irmp.c        ****                                 {
3473:irmp.c        ****                                     irmp_store_bit (0);
3474:irmp.c        ****                                     last_value = 0;
3475:irmp.c        ****                                 }
3476:irmp.c        **** #ifdef ANALYZE
3477:irmp.c        ****                                 ANALYZE_NEWLINE ();
3478:irmp.c        **** #endif // ANALYZE
3479:irmp.c        ****                             }
3480:irmp.c        ****                             else
3481:irmp.c        **** #endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
3482:irmp.c        ****                             {
3483:irmp.c        **** #ifdef ANALYZE
3484:irmp.c        ****                                 ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1
3485:irmp.c        **** #endif // ANALYZE
3486:irmp.c        ****                                 irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1)
 669               	bn	68,0,3486,.LM85-.LFBB4
 670               	.LM85:
 671 035a 3695      		lsr r19
 672 035c 2795      		ror r18
 673 035e 822F      		mov r24,r18
 674 0360 8095      		com r24
 675 0362 8170      		andi r24,lo8(1)
 676 0364 00D0      		rcall irmp_store_bit
3487:irmp.c        **** 
3488:irmp.c        **** #if IRMP_SUPPORT_RC6_PROTOCOL == 1
3489:irmp.c        ****                                 if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 4 && ir
3490:irmp.c        ****                                 {
3491:irmp.c        **** #ifdef ANALYZE
3492:irmp.c        ****                                     ANALYZE_PUTCHAR ('T');
3493:irmp.c        **** #endif // ANALYZE
3494:irmp.c        ****                                     irmp_store_bit (1);
3495:irmp.c        **** 
3496:irmp.c        ****                                     if (irmp_pause_time > 2 * irmp_param.pause_1_len_max)
3497:irmp.c        ****                                     {
3498:irmp.c        ****                                         last_value = 0;
3499:irmp.c        ****                                     }
3500:irmp.c        ****                                     else
3501:irmp.c        ****                                     {
3502:irmp.c        ****                                         last_value = 1;
3503:irmp.c        ****                                     }
3504:irmp.c        **** #ifdef ANALYZE
3505:irmp.c        ****                                     ANALYZE_NEWLINE ();
3506:irmp.c        **** #endif // ANALYZE
3507:irmp.c        ****                                 }
3508:irmp.c        ****                                 else
3509:irmp.c        **** #endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
3510:irmp.c        ****                                 {
3511:irmp.c        **** #ifdef ANALYZE
3512:irmp.c        ****                                     ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_
3513:irmp.c        **** #endif // ANALYZE
3514:irmp.c        ****                                     irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_I
 677               	68,0,3514,.LM86-.LFBB4
 678               	.LM86:
 679 0366 8091 0000 		lds r24,irmp_param+16
 680 036a 90E0      		ldi r25,lo8(0)
 681 036c 9695      		lsr r25
 682 036e 8795      		ror r24
 683 0370 8170      		andi r24,lo8(1)
 684 0372 00D0      		rcall irmp_store_bit
3515:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCO
3516:irmp.c        ****                                     if (! irmp_param2.protocol)
3517:irmp.c        **** #endif
3518:irmp.c        ****                                     {
3519:irmp.c        **** #ifdef ANALYZE
3520:irmp.c        ****                                         ANALYZE_NEWLINE ();
3521:irmp.c        **** #endif // ANALYZE
3522:irmp.c        ****                                     }
3523:irmp.c        ****                                     last_value = (irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1
 685               	68,0,3523,.LM87-.LFBB4
 686               	.LM87:
 687 0374 8091 0000 		lds r24,irmp_param+16
 688 0378 90E0      		ldi r25,lo8(0)
 689 037a 9695      		lsr r25
 690 037c 8795      		ror r24
 691 037e 8170      		andi r24,lo8(1)
 692 0380 8093 0000 		sts last_value.1736,r24
 693 0384 00C0      		rjmp .L41
 694               	.L40:
3524:irmp.c        ****                                 }
3525:irmp.c        ****                             }
3526:irmp.c        ****                         }
3527:irmp.c        ****                         else if (irmp_pulse_time >= irmp_param.pulse_1_len_min && irmp_pulse_time <
 695               	,0,3527,.LM88-.LFBB4
 696               	.LM88:
 697 0386 8091 0000 		lds r24,irmp_param+1
 698 038a 9817      		cp r25,r24
 699 038c 00F0      		brlo .L42
 700               	.LBB4:
3528:irmp.c        ****                                  /* && irmp_pause_time <= 2 * irmp_param.pause_1_len_max */)
3529:irmp.c        ****                         {
3530:irmp.c        ****                             uint8_t manchester_value;
3531:irmp.c        **** 
3532:irmp.c        ****                             if (last_pause > irmp_param.pause_1_len_max && last_pause <= 2 * irmp_p
 701               	n	68,0,3532,.LM89-.LFBB4
 702               	.LM89:
 703 038e 2091 0000 		lds r18,last_pause.1735
 704 0392 8091 0000 		lds r24,irmp_param+4
 705 0396 8217      		cp r24,r18
 706 0398 00F4      		brsh .L43
 707 039a 30E0      		ldi r19,lo8(0)
 708 039c 90E0      		ldi r25,lo8(0)
 709 039e 880F      		lsl r24
 710 03a0 991F      		rol r25
 711 03a2 8217      		cp r24,r18
 712 03a4 9307      		cpc r25,r19
 713 03a6 04F0      		brlt .L43
3533:irmp.c        ****                             {
3534:irmp.c        ****                                 manchester_value = last_value ? 0 : 1;
 714               	3534,.LM90-.LFBB4
 715               	.LM90:
 716 03a8 90E0      		ldi r25,lo8(0)
 717 03aa 8091 0000 		lds r24,last_value.1736
 718 03ae 8823      		tst r24
 719 03b0 01F4      		brne .L44
 720 03b2 91E0      		ldi r25,lo8(1)
 721               	.L44:
3535:irmp.c        ****                                 last_value  = manchester_value;
 722               	68,0,3535,.LM91-.LFBB4
 723               	.LM91:
 724 03b4 9093 0000 		sts last_value.1736,r25
 725 03b8 00C0      		rjmp .L45
 726               	.L43:
3536:irmp.c        ****                             }
3537:irmp.c        ****                             else
3538:irmp.c        ****                             {
3539:irmp.c        ****                                 manchester_value = last_value;
 727               	bn	68,0,3539,.LM92-.LFBB4
 728               	.LM92:
 729 03ba 9091 0000 		lds r25,last_value.1736
 730               	.L45:
3540:irmp.c        ****                             }
3541:irmp.c        **** 
3542:irmp.c        **** #ifdef ANALYZE
3543:irmp.c        ****                             ANALYZE_PUTCHAR (manchester_value + '0');
3544:irmp.c        **** #endif // ANALYZE
3545:irmp.c        **** 
3546:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCO
3547:irmp.c        ****                             if (! irmp_param2.protocol)
3548:irmp.c        **** #endif
3549:irmp.c        ****                             {
3550:irmp.c        **** #ifdef ANALYZE
3551:irmp.c        ****                                 ANALYZE_NEWLINE ();
3552:irmp.c        **** #endif // ANALYZE
3553:irmp.c        ****                             }
3554:irmp.c        **** 
3555:irmp.c        **** #if IRMP_SUPPORT_RC6_PROTOCOL == 1
3556:irmp.c        ****                             if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 1 && manche
3557:irmp.c        ****                             {
3558:irmp.c        **** #ifdef ANALYZE
3559:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to RC6A protocol\n");
3560:irmp.c        **** #endif // ANALYZE
3561:irmp.c        ****                                 irmp_param.complete_len = RC6_COMPLETE_DATA_LEN_LONG;
3562:irmp.c        ****                                 irmp_param.address_offset = 5;
3563:irmp.c        ****                                 irmp_param.address_end = irmp_param.address_offset + 15;
3564:irmp.c        ****                                 irmp_param.command_offset = irmp_param.address_end + 1;            
3565:irmp.c        ****                                 irmp_param.command_end = irmp_param.command_offset + 16 - 1;
3566:irmp.c        ****                                 irmp_tmp_address = 0;
3567:irmp.c        ****                             }
3568:irmp.c        **** #endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
3569:irmp.c        **** 
3570:irmp.c        ****                             irmp_store_bit (manchester_value);
 731               	abn	68,0,3570,.LM93-.LFBB4
 732               	.LM93:
 733 03be 892F      		mov r24,r25
 734 03c0 00D0      		rcall irmp_store_bit
 735 03c2 00C0      		rjmp .L41
 736               	.L42:
 737               	.LBE4:
3571:irmp.c        ****                         }
3572:irmp.c        ****                         else
3573:irmp.c        ****                         {
3574:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_FDC_PROTOCOL == 1
3575:irmp.c        ****                             if (irmp_param2.protocol == IRMP_FDC_PROTOCOL &&
3576:irmp.c        ****                                 irmp_pulse_time >= FDC_PULSE_LEN_MIN && irmp_pulse_time <= FDC_PULS
3577:irmp.c        ****                                 ((irmp_pause_time >= FDC_1_PAUSE_LEN_MIN && irmp_pause_time <= FDC_
3578:irmp.c        ****                                  (irmp_pause_time >= FDC_0_PAUSE_LEN_MIN && irmp_pause_time <= FDC_
3579:irmp.c        ****                             {
3580:irmp.c        **** #ifdef ANALYZE
3581:irmp.c        ****                                 ANALYZE_PUTCHAR ('?');
3582:irmp.c        **** #endif // ANALYZE
3583:irmp.c        ****                                 irmp_param.protocol = 0;                // switch to FDC, see below
3584:irmp.c        ****                             }
3585:irmp.c        ****                             else
3586:irmp.c        **** #endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
3587:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_RCCAR_PROTOCOL == 1
3588:irmp.c        ****                             if (irmp_param2.protocol == IRMP_RCCAR_PROTOCOL &&
3589:irmp.c        ****                                 irmp_pulse_time >= RCCAR_PULSE_LEN_MIN && irmp_pulse_time <= RCCAR_
3590:irmp.c        ****                                 ((irmp_pause_time >= RCCAR_1_PAUSE_LEN_MIN && irmp_pause_time <= RC
3591:irmp.c        ****                                  (irmp_pause_time >= RCCAR_0_PAUSE_LEN_MIN && irmp_pause_time <= RC
3592:irmp.c        ****                             {
3593:irmp.c        **** #ifdef ANALYZE
3594:irmp.c        ****                                 ANALYZE_PUTCHAR ('?');
3595:irmp.c        **** #endif // ANALYZE
3596:irmp.c        ****                                 irmp_param.protocol = 0;                // switch to RCCAR, see bel
3597:irmp.c        ****                             }
3598:irmp.c        ****                             else
3599:irmp.c        **** #endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
3600:irmp.c        ****                             {
3601:irmp.c        **** #ifdef ANALYZE
3602:irmp.c        ****                                 ANALYZE_PUTCHAR ('?');
3603:irmp.c        ****                                 ANALYZE_NEWLINE ();
3604:irmp.c        ****                                 ANALYZE_PRINTF ("error 3 manchester: timing not correct: data bit %
3605:irmp.c        ****                                 ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
3606:irmp.c        **** #endif // ANALYZE
3607:irmp.c        ****                                 irmp_start_bit_detected = 0;                            // reset fl
 738               		68,0,3607,.LM94-.LFBB4
 739               	.LM94:
 740 03c4 1092 0000 		sts irmp_start_bit_detected.1725,__zero_reg__
3608:irmp.c        ****                                 irmp_pause_time         = 0;
 741               	tabn	68,0,3608,.LM95-.LFBB4
 742               	.LM95:
 743 03c8 1092 0000 		sts irmp_pause_time.1729,__zero_reg__
 744               	.L41:
3609:irmp.c        ****                             }
3610:irmp.c        ****                         }
3611:irmp.c        **** 
3612:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_FDC_PROTOCOL == 1
3613:irmp.c        ****                         if (irmp_param2.protocol == IRMP_FDC_PROTOCOL && irmp_pulse_time >= FDC_PUL
3614:irmp.c        ****                         {
3615:irmp.c        ****                             if (irmp_pause_time >= FDC_1_PAUSE_LEN_MIN && irmp_pause_time <= FDC_1_
3616:irmp.c        ****                             {
3617:irmp.c        **** #ifdef ANALYZE
3618:irmp.c        ****                                 ANALYZE_PRINTF ("   1 (FDC)\n");
3619:irmp.c        **** #endif // ANALYZE
3620:irmp.c        ****                                 irmp_store_bit2 (1);
3621:irmp.c        ****                             }
3622:irmp.c        ****                             else if (irmp_pause_time >= FDC_0_PAUSE_LEN_MIN && irmp_pause_time <= F
3623:irmp.c        ****                             {
3624:irmp.c        **** #ifdef ANALYZE
3625:irmp.c        ****                                 ANALYZE_PRINTF ("   0 (FDC)\n");
3626:irmp.c        **** #endif // ANALYZE
3627:irmp.c        ****                                 irmp_store_bit2 (0);
3628:irmp.c        ****                             }
3629:irmp.c        **** 
3630:irmp.c        ****                             if (! irmp_param.protocol)
3631:irmp.c        ****                             {
3632:irmp.c        **** #ifdef ANALYZE
3633:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to FDC protocol\n");
3634:irmp.c        **** #endif // ANALYZE
3635:irmp.c        ****                                 memcpy (&irmp_param, &irmp_param2, sizeof (IRMP_PARAMETER));
3636:irmp.c        ****                                 irmp_param2.protocol = 0;
3637:irmp.c        ****                                 irmp_tmp_address = irmp_tmp_address2;
3638:irmp.c        ****                                 irmp_tmp_command = irmp_tmp_command2;
3639:irmp.c        ****                             }
3640:irmp.c        ****                         }
3641:irmp.c        **** #endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
3642:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_RCCAR_PROTOCOL == 1
3643:irmp.c        ****                         if (irmp_param2.protocol == IRMP_RCCAR_PROTOCOL && irmp_pulse_time >= RCCAR
3644:irmp.c        ****                         {
3645:irmp.c        ****                             if (irmp_pause_time >= RCCAR_1_PAUSE_LEN_MIN && irmp_pause_time <= RCCA
3646:irmp.c        ****                             {
3647:irmp.c        **** #ifdef ANALYZE
3648:irmp.c        ****                                 ANALYZE_PRINTF ("   1 (RCCAR)\n");
3649:irmp.c        **** #endif // ANALYZE
3650:irmp.c        ****                                 irmp_store_bit2 (1);
3651:irmp.c        ****                             }
3652:irmp.c        ****                             else if (irmp_pause_time >= RCCAR_0_PAUSE_LEN_MIN && irmp_pause_time <=
3653:irmp.c        ****                             {
3654:irmp.c        **** #ifdef ANALYZE
3655:irmp.c        ****                                 ANALYZE_PRINTF ("   0 (RCCAR)\n");
3656:irmp.c        **** #endif // ANALYZE
3657:irmp.c        ****                                 irmp_store_bit2 (0);
3658:irmp.c        ****                             }
3659:irmp.c        **** 
3660:irmp.c        ****                             if (! irmp_param.protocol)
3661:irmp.c        ****                             {
3662:irmp.c        **** #ifdef ANALYZE
3663:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to RCCAR protocol\n");
3664:irmp.c        **** #endif // ANALYZE
3665:irmp.c        ****                                 memcpy (&irmp_param, &irmp_param2, sizeof (IRMP_PARAMETER));
3666:irmp.c        ****                                 irmp_param2.protocol = 0;
3667:irmp.c        ****                                 irmp_tmp_address = irmp_tmp_address2;
3668:irmp.c        ****                                 irmp_tmp_command = irmp_tmp_command2;
3669:irmp.c        ****                             }
3670:irmp.c        ****                         }
3671:irmp.c        **** #endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
3672:irmp.c        **** 
3673:irmp.c        ****                         last_pause      = irmp_pause_time;
 745               	abn	68,0,3673,.LM96-.LFBB4
 746               	.LM96:
 747 03cc 8091 0000 		lds r24,irmp_pause_time.1729
 748 03d0 8093 0000 		sts last_pause.1735,r24
 749 03d4 00C0      		rjmp .L57
 750               	.L39:
3674:irmp.c        ****                         wait_for_space  = 0;
3675:irmp.c        ****                     }
3676:irmp.c        ****                     else
3677:irmp.c        **** #endif // IRMP_SUPPORT_MANCHESTER == 1
3678:irmp.c        **** 
3679:irmp.c        **** #if IRMP_SUPPORT_SERIAL == 1
3680:irmp.c        ****                     if (irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL)
3681:irmp.c        ****                     {
3682:irmp.c        ****                         while (irmp_bit < irmp_param.complete_len && irmp_pulse_time > irmp_param.p
3683:irmp.c        ****                         {
3684:irmp.c        **** #ifdef ANALYZE
3685:irmp.c        ****                             ANALYZE_PUTCHAR ('1');
3686:irmp.c        **** #endif // ANALYZE
3687:irmp.c        ****                             irmp_store_bit (1);
3688:irmp.c        **** 
3689:irmp.c        ****                             if (irmp_pulse_time >= irmp_param.pulse_1_len_min)
3690:irmp.c        ****                             {
3691:irmp.c        ****                                 irmp_pulse_time -= irmp_param.pulse_1_len_min;
3692:irmp.c        ****                             }
3693:irmp.c        ****                             else
3694:irmp.c        ****                             {
3695:irmp.c        ****                                 irmp_pulse_time = 0;
3696:irmp.c        ****                             }
3697:irmp.c        ****                         }
3698:irmp.c        **** 
3699:irmp.c        ****                         while (irmp_bit < irmp_param.complete_len && irmp_pause_time > irmp_param.p
3700:irmp.c        ****                         {
3701:irmp.c        **** #ifdef ANALYZE
3702:irmp.c        ****                             ANALYZE_PUTCHAR ('0');
3703:irmp.c        **** #endif // ANALYZE
3704:irmp.c        ****                             irmp_store_bit (0);
3705:irmp.c        **** 
3706:irmp.c        ****                             if (irmp_pause_time >= irmp_param.pause_1_len_min)
3707:irmp.c        ****                             {
3708:irmp.c        ****                                 irmp_pause_time -= irmp_param.pause_1_len_min;
3709:irmp.c        ****                             }
3710:irmp.c        ****                             else
3711:irmp.c        ****                             {
3712:irmp.c        ****                                 irmp_pause_time = 0;
3713:irmp.c        ****                             }
3714:irmp.c        ****                         }
3715:irmp.c        **** #ifdef ANALYZE
3716:irmp.c        ****                         ANALYZE_NEWLINE ();
3717:irmp.c        **** #endif // ANALYZE
3718:irmp.c        ****                         wait_for_space = 0;
3719:irmp.c        ****                     }
3720:irmp.c        ****                     else
3721:irmp.c        **** #endif // IRMP_SUPPORT_SERIAL == 1
3722:irmp.c        **** 
3723:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
3724:irmp.c        ****                     if (irmp_param.protocol == IRMP_SAMSUNG_PROTOCOL && irmp_bit == 16)       // Sa
3725:irmp.c        ****                     {
3726:irmp.c        ****                         if (irmp_pulse_time >= SAMSUNG_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_
3727:irmp.c        ****                             irmp_pause_time >= SAMSUNG_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <
3728:irmp.c        ****                         {
3729:irmp.c        **** #ifdef ANALYZE
3730:irmp.c        ****                             ANALYZE_PRINTF ("SYNC\n");
3731:irmp.c        **** #endif // ANALYZE
3732:irmp.c        ****                             wait_for_space = 0;
3733:irmp.c        ****                             irmp_bit++;
3734:irmp.c        ****                         }
3735:irmp.c        ****                         else  if (irmp_pulse_time >= SAMSUNG_PULSE_LEN_MIN && irmp_pulse_time <= SA
3736:irmp.c        ****                         {
3737:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG48_PROTOCOL == 1
3738:irmp.c        **** #ifdef ANALYZE
3739:irmp.c        ****                             ANALYZE_PRINTF ("Switching to SAMSUNG48 protocol ");
3740:irmp.c        **** #endif // ANALYZE
3741:irmp.c        ****                             irmp_param.protocol         = IRMP_SAMSUNG48_PROTOCOL;
3742:irmp.c        ****                             irmp_param.command_offset   = SAMSUNG48_COMMAND_OFFSET;
3743:irmp.c        ****                             irmp_param.command_end      = SAMSUNG48_COMMAND_OFFSET + SAMSUNG48_COMM
3744:irmp.c        ****                             irmp_param.complete_len     = SAMSUNG48_COMPLETE_DATA_LEN;
3745:irmp.c        **** #else
3746:irmp.c        **** #ifdef ANALYZE
3747:irmp.c        ****                             ANALYZE_PRINTF ("Switching to SAMSUNG32 protocol ");
3748:irmp.c        **** #endif // ANALYZE
3749:irmp.c        ****                             irmp_param.protocol         = IRMP_SAMSUNG32_PROTOCOL;
3750:irmp.c        ****                             irmp_param.command_offset   = SAMSUNG32_COMMAND_OFFSET;
3751:irmp.c        ****                             irmp_param.command_end      = SAMSUNG32_COMMAND_OFFSET + SAMSUNG32_COMM
3752:irmp.c        ****                             irmp_param.complete_len     = SAMSUNG32_COMPLETE_DATA_LEN;
3753:irmp.c        **** #endif
3754:irmp.c        ****                             if (irmp_pause_time >= SAMSUNG_1_PAUSE_LEN_MIN && irmp_pause_time <= SA
3755:irmp.c        ****                             {
3756:irmp.c        **** #ifdef ANALYZE
3757:irmp.c        ****                                 ANALYZE_PUTCHAR ('1');
3758:irmp.c        ****                                 ANALYZE_NEWLINE ();
3759:irmp.c        **** #endif // ANALYZE
3760:irmp.c        ****                                 irmp_store_bit (1);
3761:irmp.c        ****                                 wait_for_space = 0;
3762:irmp.c        ****                             }
3763:irmp.c        ****                             else
3764:irmp.c        ****                             {
3765:irmp.c        **** #ifdef ANALYZE
3766:irmp.c        ****                                 ANALYZE_PUTCHAR ('0');
3767:irmp.c        ****                                 ANALYZE_NEWLINE ();
3768:irmp.c        **** #endif // ANALYZE
3769:irmp.c        ****                                 irmp_store_bit (0);
3770:irmp.c        ****                                 wait_for_space = 0;
3771:irmp.c        ****                             }
3772:irmp.c        ****                         }
3773:irmp.c        ****                         else
3774:irmp.c        ****                         {                                                           // timing incor
3775:irmp.c        **** #ifdef ANALYZE
3776:irmp.c        ****                             ANALYZE_PRINTF ("error 3 Samsung: timing not correct: data bit %d,  pul
3777:irmp.c        ****                             ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
3778:irmp.c        **** #endif // ANALYZE
3779:irmp.c        ****                             irmp_start_bit_detected = 0;                            // reset flags 
3780:irmp.c        ****                             irmp_pause_time         = 0;
3781:irmp.c        ****                         }
3782:irmp.c        ****                     }
3783:irmp.c        ****                     else
3784:irmp.c        **** #endif // IRMP_SUPPORT_SAMSUNG_PROTOCOL
3785:irmp.c        **** 
3786:irmp.c        **** #if IRMP_SUPPORT_NEC16_PROTOCOL
3787:irmp.c        **** #if IRMP_SUPPORT_NEC42_PROTOCOL == 1
3788:irmp.c        ****                     if (irmp_param.protocol == IRMP_NEC42_PROTOCOL &&
3789:irmp.c        **** #else // IRMP_SUPPORT_NEC_PROTOCOL instead
3790:irmp.c        ****                     if (irmp_param.protocol == IRMP_NEC_PROTOCOL &&
3791:irmp.c        **** #endif // IRMP_SUPPORT_NEC42_PROTOCOL == 1
3792:irmp.c        ****                         irmp_bit == 8 && irmp_pause_time >= NEC_START_BIT_PAUSE_LEN_MIN && irmp_pau
3793:irmp.c        ****                     {
3794:irmp.c        **** #ifdef ANALYZE
3795:irmp.c        ****                         ANALYZE_PRINTF ("Switching to NEC16 protocol\n");
3796:irmp.c        **** #endif // ANALYZE
3797:irmp.c        ****                         irmp_param.protocol         = IRMP_NEC16_PROTOCOL;
3798:irmp.c        ****                         irmp_param.address_offset   = NEC16_ADDRESS_OFFSET;
3799:irmp.c        ****                         irmp_param.address_end      = NEC16_ADDRESS_OFFSET + NEC16_ADDRESS_LEN;
3800:irmp.c        ****                         irmp_param.command_offset   = NEC16_COMMAND_OFFSET;
3801:irmp.c        ****                         irmp_param.command_end      = NEC16_COMMAND_OFFSET + NEC16_COMMAND_LEN;
3802:irmp.c        ****                         irmp_param.complete_len     = NEC16_COMPLETE_DATA_LEN;
3803:irmp.c        ****                         wait_for_space = 0;
3804:irmp.c        ****                     }
3805:irmp.c        ****                     else
3806:irmp.c        **** #endif // IRMP_SUPPORT_NEC16_PROTOCOL
3807:irmp.c        **** 
3808:irmp.c        **** #if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
3809:irmp.c        ****                     if (irmp_param.protocol == IRMP_BANG_OLUFSEN_PROTOCOL)
3810:irmp.c        ****                     {
3811:irmp.c        ****                         if (irmp_pulse_time >= BANG_OLUFSEN_PULSE_LEN_MIN && irmp_pulse_time <= BAN
3812:irmp.c        ****                         {
3813:irmp.c        ****                             if (irmp_bit == 1)                                      // Bang & Olufs
3814:irmp.c        ****                             {
3815:irmp.c        ****                                 if (irmp_pause_time >= BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MIN && irm
3816:irmp.c        ****                                 {
3817:irmp.c        **** #ifdef ANALYZE
3818:irmp.c        ****                                     ANALYZE_PRINTF ("3rd start bit\n");
3819:irmp.c        **** #endif // ANALYZE
3820:irmp.c        ****                                     wait_for_space = 0;
3821:irmp.c        ****                                     irmp_bit++;
3822:irmp.c        ****                                 }
3823:irmp.c        ****                                 else
3824:irmp.c        ****                                 {                                                   // timing incor
3825:irmp.c        **** #ifdef ANALYZE
3826:irmp.c        ****                                     ANALYZE_PRINTF ("error 3a B&O: timing not correct: data bit %d,
3827:irmp.c        ****                                     ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
3828:irmp.c        **** #endif // ANALYZE
3829:irmp.c        ****                                     irmp_start_bit_detected = 0;                    // reset flags 
3830:irmp.c        ****                                     irmp_pause_time         = 0;
3831:irmp.c        ****                                 }
3832:irmp.c        ****                             }
3833:irmp.c        ****                             else if (irmp_bit == 19)                                // Bang & Olufs
3834:irmp.c        ****                             {
3835:irmp.c        ****                                 if (irmp_pause_time >= BANG_OLUFSEN_TRAILER_BIT_PAUSE_LEN_MIN && ir
3836:irmp.c        ****                                 {
3837:irmp.c        **** #ifdef ANALYZE
3838:irmp.c        ****                                     ANALYZE_PRINTF ("trailer bit\n");
3839:irmp.c        **** #endif // ANALYZE
3840:irmp.c        ****                                     wait_for_space = 0;
3841:irmp.c        ****                                     irmp_bit++;
3842:irmp.c        ****                                 }
3843:irmp.c        ****                                 else
3844:irmp.c        ****                                 {                                                   // timing incor
3845:irmp.c        **** #ifdef ANALYZE
3846:irmp.c        ****                                     ANALYZE_PRINTF ("error 3b B&O: timing not correct: data bit %d,
3847:irmp.c        ****                                     ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
3848:irmp.c        **** #endif // ANALYZE
3849:irmp.c        ****                                     irmp_start_bit_detected = 0;                    // reset flags 
3850:irmp.c        ****                                     irmp_pause_time         = 0;
3851:irmp.c        ****                                 }
3852:irmp.c        ****                             }
3853:irmp.c        ****                             else
3854:irmp.c        ****                             {
3855:irmp.c        ****                                 if (irmp_pause_time >= BANG_OLUFSEN_1_PAUSE_LEN_MIN && irmp_pause_t
3856:irmp.c        ****                                 {                                                   // pulse & paus
3857:irmp.c        **** #ifdef ANALYZE
3858:irmp.c        ****                                     ANALYZE_PUTCHAR ('1');
3859:irmp.c        ****                                     ANALYZE_NEWLINE ();
3860:irmp.c        **** #endif // ANALYZE
3861:irmp.c        ****                                     irmp_store_bit (1);
3862:irmp.c        ****                                     last_value = 1;
3863:irmp.c        ****                                     wait_for_space = 0;
3864:irmp.c        ****                                 }
3865:irmp.c        ****                                 else if (irmp_pause_time >= BANG_OLUFSEN_0_PAUSE_LEN_MIN && irmp_pa
3866:irmp.c        ****                                 {                                                   // pulse & paus
3867:irmp.c        **** #ifdef ANALYZE
3868:irmp.c        ****                                     ANALYZE_PUTCHAR ('0');
3869:irmp.c        ****                                     ANALYZE_NEWLINE ();
3870:irmp.c        **** #endif // ANALYZE
3871:irmp.c        ****                                     irmp_store_bit (0);
3872:irmp.c        ****                                     last_value = 0;
3873:irmp.c        ****                                     wait_for_space = 0;
3874:irmp.c        ****                                 }
3875:irmp.c        ****                                 else if (irmp_pause_time >= BANG_OLUFSEN_R_PAUSE_LEN_MIN && irmp_pa
3876:irmp.c        ****                                 {
3877:irmp.c        **** #ifdef ANALYZE
3878:irmp.c        ****                                     ANALYZE_PUTCHAR (last_value + '0');
3879:irmp.c        ****                                     ANALYZE_NEWLINE ();
3880:irmp.c        **** #endif // ANALYZE
3881:irmp.c        ****                                     irmp_store_bit (last_value);
3882:irmp.c        ****                                     wait_for_space = 0;
3883:irmp.c        ****                                 }
3884:irmp.c        ****                                 else
3885:irmp.c        ****                                 {                                                   // timing incor
3886:irmp.c        **** #ifdef ANALYZE
3887:irmp.c        ****                                     ANALYZE_PRINTF ("error 3c B&O: timing not correct: data bit %d,
3888:irmp.c        ****                                     ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
3889:irmp.c        **** #endif // ANALYZE
3890:irmp.c        ****                                     irmp_start_bit_detected = 0;                    // reset flags 
3891:irmp.c        ****                                     irmp_pause_time         = 0;
3892:irmp.c        ****                                 }
3893:irmp.c        ****                             }
3894:irmp.c        ****                         }
3895:irmp.c        ****                         else
3896:irmp.c        ****                         {                                                           // timing incor
3897:irmp.c        **** #ifdef ANALYZE
3898:irmp.c        ****                             ANALYZE_PRINTF ("error 3d B&O: timing not correct: data bit %d,  pulse:
3899:irmp.c        ****                             ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
3900:irmp.c        **** #endif // ANALYZE
3901:irmp.c        ****                             irmp_start_bit_detected = 0;                            // reset flags 
3902:irmp.c        ****                             irmp_pause_time         = 0;
3903:irmp.c        ****                         }
3904:irmp.c        ****                     }
3905:irmp.c        ****                     else
3906:irmp.c        **** #endif // IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL
3907:irmp.c        **** 
3908:irmp.c        **** #if IRMP_SUPPORT_RCMM_PROTOCOL == 1
3909:irmp.c        ****                     if (irmp_param.protocol == IRMP_RCMM32_PROTOCOL)
3910:irmp.c        ****                     {
3911:irmp.c        ****                         if (irmp_pause_time >= RCMM32_BIT_00_PAUSE_LEN_MIN && irmp_pause_time <= RC
3912:irmp.c        ****                         {
3913:irmp.c        **** #ifdef ANALYZE
3914:irmp.c        ****                             ANALYZE_PUTCHAR ('0');
3915:irmp.c        ****                             ANALYZE_PUTCHAR ('0');
3916:irmp.c        **** #endif // ANALYZE
3917:irmp.c        ****                             irmp_store_bit (0);
3918:irmp.c        ****                             irmp_store_bit (0);
3919:irmp.c        ****                         }
3920:irmp.c        ****                         else if (irmp_pause_time >= RCMM32_BIT_01_PAUSE_LEN_MIN && irmp_pause_time 
3921:irmp.c        ****                         {
3922:irmp.c        **** #ifdef ANALYZE
3923:irmp.c        ****                             ANALYZE_PUTCHAR ('0');
3924:irmp.c        ****                             ANALYZE_PUTCHAR ('1');
3925:irmp.c        **** #endif // ANALYZE
3926:irmp.c        ****                             irmp_store_bit (0);
3927:irmp.c        ****                             irmp_store_bit (1);
3928:irmp.c        ****                         }
3929:irmp.c        ****                         else if (irmp_pause_time >= RCMM32_BIT_10_PAUSE_LEN_MIN && irmp_pause_time 
3930:irmp.c        ****                         {
3931:irmp.c        **** #ifdef ANALYZE
3932:irmp.c        ****                             ANALYZE_PUTCHAR ('1');
3933:irmp.c        ****                             ANALYZE_PUTCHAR ('0');
3934:irmp.c        **** #endif // ANALYZE
3935:irmp.c        ****                             irmp_store_bit (1);
3936:irmp.c        ****                             irmp_store_bit (0);
3937:irmp.c        ****                         }
3938:irmp.c        ****                         else if (irmp_pause_time >= RCMM32_BIT_11_PAUSE_LEN_MIN && irmp_pause_time 
3939:irmp.c        ****                         {
3940:irmp.c        **** #ifdef ANALYZE
3941:irmp.c        ****                             ANALYZE_PUTCHAR ('1');
3942:irmp.c        ****                             ANALYZE_PUTCHAR ('1');
3943:irmp.c        **** #endif // ANALYZE
3944:irmp.c        ****                             irmp_store_bit (1);
3945:irmp.c        ****                             irmp_store_bit (1);
3946:irmp.c        ****                         }
3947:irmp.c        **** #ifdef ANALYZE
3948:irmp.c        ****                         ANALYZE_PRINTF ("\n");
3949:irmp.c        **** #endif // ANALYZE
3950:irmp.c        ****                         wait_for_space = 0;
3951:irmp.c        ****                     }
3952:irmp.c        ****                     else
3953:irmp.c        **** #endif
3954:irmp.c        ****  
3955:irmp.c        ****                     if (irmp_pulse_time >= irmp_param.pulse_1_len_min && irmp_pulse_time <= irmp_pa
 751               	n	68,0,3955,.LM97-.LFBB4
 752               	.LM97:
 753 03d6 8091 0000 		lds r24,irmp_param+1
 754 03da 9817      		cp r25,r24
 755 03dc 00F0      		brlo .L47
 756 03de 8091 0000 		lds r24,irmp_param+2
 757 03e2 8917      		cp r24,r25
 758 03e4 00F0      		brlo .L47
 759 03e6 2091 0000 		lds r18,irmp_pause_time.1729
 760 03ea 8091 0000 		lds r24,irmp_param+3
 761 03ee 2817      		cp r18,r24
 762 03f0 00F0      		brlo .L47
 763 03f2 8091 0000 		lds r24,irmp_param+4
 764 03f6 8217      		cp r24,r18
 765 03f8 00F0      		brlo .L47
3956:irmp.c        ****                         irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_pa
3957:irmp.c        ****                     {                                                               // pulse & paus
3958:irmp.c        **** #ifdef ANALYZE
3959:irmp.c        ****                         ANALYZE_PUTCHAR ('1');
3960:irmp.c        ****                         ANALYZE_NEWLINE ();
3961:irmp.c        **** #endif // ANALYZE
3962:irmp.c        ****                         irmp_store_bit (1);
 766               	62,.LM98-.LFBB4
 767               	.LM98:
 768 03fa 81E0      		ldi r24,lo8(1)
 769               	.L59:
 770 03fc 00D0      		rcall irmp_store_bit
 771               	.L57:
3963:irmp.c        ****                         wait_for_space = 0;
 772               	n	68,0,3963,.LM99-.LFBB4
 773               	.LM99:
 774 03fe 1092 0000 		sts wait_for_space.1726,__zero_reg__
 775 0402 00C0      		rjmp .L46
 776               	.L47:
3964:irmp.c        ****                     }
3965:irmp.c        ****                     else if (irmp_pulse_time >= irmp_param.pulse_0_len_min && irmp_pulse_time <= ir
 777               	bn	68,0,3965,.LM100-.LFBB4
 778               	.LM100:
 779 0404 8091 0000 		lds r24,irmp_param+5
 780 0408 9817      		cp r25,r24
 781 040a 00F0      		brlo .L48
 782 040c 8091 0000 		lds r24,irmp_param+6
 783 0410 8917      		cp r24,r25
 784 0412 00F0      		brlo .L48
 785 0414 9091 0000 		lds r25,irmp_pause_time.1729
 786 0418 8091 0000 		lds r24,irmp_param+7
 787 041c 9817      		cp r25,r24
 788 041e 00F0      		brlo .L48
 789 0420 8091 0000 		lds r24,irmp_param+8
 790 0424 8917      		cp r24,r25
 791 0426 00F0      		brlo .L48
3966:irmp.c        ****                              irmp_pause_time >= irmp_param.pause_0_len_min && irmp_pause_time <= ir
3967:irmp.c        ****                     {                                                               // pulse & paus
3968:irmp.c        **** #ifdef ANALYZE
3969:irmp.c        ****                         ANALYZE_PUTCHAR ('0');
3970:irmp.c        ****                         ANALYZE_NEWLINE ();
3971:irmp.c        **** #endif // ANALYZE
3972:irmp.c        ****                         irmp_store_bit (0);
 792               	72,.LM101-.LFBB4
 793               	.LM101:
 794 0428 80E0      		ldi r24,lo8(0)
 795 042a 00C0      		rjmp .L59
 796               	.L48:
3973:irmp.c        ****                         wait_for_space = 0;
3974:irmp.c        ****                     }
3975:irmp.c        ****                     else
3976:irmp.c        **** #if IRMP_SUPPORT_KATHREIN_PROTOCOL
3977:irmp.c        **** 
3978:irmp.c        ****                     if (irmp_param.protocol == IRMP_KATHREIN_PROTOCOL &&
3979:irmp.c        ****                         irmp_pulse_time >= KATHREIN_1_PULSE_LEN_MIN && irmp_pulse_time <= KATHREIN_
3980:irmp.c        ****                         (((irmp_bit == 8 || irmp_bit == 6) &&
3981:irmp.c        ****                                 irmp_pause_time >= KATHREIN_SYNC_BIT_PAUSE_LEN_MIN && irmp_pause_ti
3982:irmp.c        ****                          (irmp_bit == 12 &&
3983:irmp.c        ****                                 irmp_pause_time >= KATHREIN_START_BIT_PAUSE_LEN_MIN && irmp_pause_t
3984:irmp.c        **** 
3985:irmp.c        ****                     {
3986:irmp.c        ****                         if (irmp_bit == 8)
3987:irmp.c        ****                         {
3988:irmp.c        ****                             irmp_bit++;
3989:irmp.c        **** #ifdef ANALYZE
3990:irmp.c        ****                             ANALYZE_PUTCHAR ('S');
3991:irmp.c        ****                             ANALYZE_NEWLINE ();
3992:irmp.c        **** #endif // ANALYZE
3993:irmp.c        ****                             irmp_tmp_command <<= 1;
3994:irmp.c        ****                         }
3995:irmp.c        ****                         else
3996:irmp.c        ****                         {
3997:irmp.c        **** #ifdef ANALYZE
3998:irmp.c        ****                             ANALYZE_PUTCHAR ('S');
3999:irmp.c        ****                             ANALYZE_NEWLINE ();
4000:irmp.c        **** #endif // ANALYZE
4001:irmp.c        ****                             irmp_store_bit (1);
4002:irmp.c        ****                         }
4003:irmp.c        ****                         wait_for_space = 0;
4004:irmp.c        ****                     }
4005:irmp.c        ****                     else
4006:irmp.c        **** #endif // IRMP_SUPPORT_KATHREIN_PROTOCOL
4007:irmp.c        ****                     {                                                               // timing incor
4008:irmp.c        **** #ifdef ANALYZE
4009:irmp.c        ****                         ANALYZE_PRINTF ("error 3: timing not correct: data bit %d,  pulse: %d, paus
4010:irmp.c        ****                         ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
4011:irmp.c        **** #endif // ANALYZE
4012:irmp.c        ****                         irmp_start_bit_detected = 0;                                // reset flags 
 797               	bn	68,0,4012,.LM102-.LFBB4
 798               	.LM102:
 799 042c 1092 0000 		sts irmp_start_bit_detected.1725,__zero_reg__
4013:irmp.c        ****                         irmp_pause_time         = 0;
 800               	tabn	68,0,4013,.LM103-.LFBB4
 801               	.LM103:
 802 0430 1092 0000 		sts irmp_pause_time.1729,__zero_reg__
 803               	.L46:
4014:irmp.c        ****                     }
4015:irmp.c        **** 
4016:irmp.c        ****                     irmp_pulse_time = 1;                                            // set counter 
 804               	abn	68,0,4016,.LM104-.LFBB4
 805               	.LM104:
 806 0434 81E0      		ldi r24,lo8(1)
 807 0436 00C0      		rjmp .L58
 808               	.L32:
 809               	.LBE3:
4017:irmp.c        ****                 }
4018:irmp.c        ****             }
4019:irmp.c        ****             else
4020:irmp.c        ****             {                                                                       // counting the
4021:irmp.c        ****                 if (! irmp_input)                                                   // still light?
 810               	n	68,0,4021,.LM105-.LFBB4
 811               	.LM105:
 812 0438 2223      		tst r18
 813 043a 01F4      		brne .L49
4022:irmp.c        ****                 {                                                                   // yes...
4023:irmp.c        ****                     irmp_pulse_time++;                                              // increment co
 814               	abn	68,0,4023,.LM106-.LFBB4
 815               	.LM106:
 816 043c 8091 0000 		lds r24,irmp_pulse_time.1728
 817 0440 8F5F      		subi r24,lo8(-(1))
 818               	.L58:
 819 0442 8093 0000 		sts irmp_pulse_time.1728,r24
 820 0446 00C0      		rjmp .L22
 821               	.L49:
4024:irmp.c        ****                 }
4025:irmp.c        ****                 else
4026:irmp.c        ****                 {                                                                   // now it's dar
4027:irmp.c        ****                     wait_for_space  = 1;                                            // let's count 
 822               	68,0,4027,.LM107-.LFBB4
 823               	.LM107:
 824 0448 81E0      		ldi r24,lo8(1)
 825 044a 8093 0000 		sts wait_for_space.1726,r24
4028:irmp.c        ****                     irmp_pause_time = 1;                                            // set pause co
 826               	abn	68,0,4028,.LM108-.LFBB4
 827               	.LM108:
 828 044e 8093 0000 		sts irmp_pause_time.1729,r24
 829               	.L22:
4029:irmp.c        ****                 }
4030:irmp.c        ****             }
4031:irmp.c        **** 
4032:irmp.c        ****             if (irmp_start_bit_detected && irmp_bit == irmp_param.complete_len && irmp_param.stop_b
 830               	abn	68,0,4032,.LM109-.LFBB4
 831               	.LM109:
 832 0452 8091 0000 		lds r24,irmp_start_bit_detected.1725
 833 0456 8823      		tst r24
 834 0458 01F4      		brne .+2
 835 045a 00C0      		rjmp .L16
 836 045c 9091 0000 		lds r25,irmp_bit
 837 0460 8091 0000 		lds r24,irmp_param+13
 838 0464 9817      		cp r25,r24
 839 0466 01F0      		breq .+2
 840 0468 00C0      		rjmp .L16
 841 046a 8091 0000 		lds r24,irmp_param+14
 842 046e 8823      		tst r24
 843 0470 01F0      		breq .+2
 844 0472 00C0      		rjmp .L16
4033:irmp.c        ****             {
4034:irmp.c        ****                 if (last_irmp_command == irmp_tmp_command && key_repetition_len < AUTO_FRAME_REPETI
 845               	34,.LM110-.LFBB4
 846               	.LM110:
 847 0474 6091 0000 		lds r22,last_irmp_command.1731
 848 0478 7091 0000 		lds r23,(last_irmp_command.1731)+1
 849 047c 2091 0000 		lds r18,irmp_tmp_command
 850 0480 3091 0000 		lds r19,(irmp_tmp_command)+1
 851 0484 6217      		cp r22,r18
 852 0486 7307      		cpc r23,r19
 853 0488 01F4      		brne .L50
 854 048a 8091 0000 		lds r24,key_repetition_len.1732
 855 048e 9091 0000 		lds r25,(key_repetition_len.1732)+1
 856 0492 8052      		subi r24,lo8(800)
 857 0494 9340      		sbci r25,hi8(800)
 858 0496 00F4      		brsh .L50
4035:irmp.c        ****                 {
4036:irmp.c        ****                     repetition_frame_number++;
 859               	036,.LM111-.LFBB4
 860               	.LM111:
 861 0498 8091 0000 		lds r24,repetition_frame_number.1733
 862 049c 8F5F      		subi r24,lo8(-(1))
 863 049e 8093 0000 		sts repetition_frame_number.1733,r24
 864 04a2 00C0      		rjmp .L51
 865               	.L50:
4037:irmp.c        ****                 }
4038:irmp.c        ****                 else
4039:irmp.c        ****                 {
4040:irmp.c        ****                     repetition_frame_number = 0;
 866               		68,0,4040,.LM112-.LFBB4
 867               	.LM112:
 868 04a4 1092 0000 		sts repetition_frame_number.1733,__zero_reg__
 869               	.L51:
4041:irmp.c        ****                 }
4042:irmp.c        **** 
4043:irmp.c        **** #if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
4044:irmp.c        ****                 // if SIRCS protocol and the code will be repeated within 50 ms, we will ignore 2nd
4045:irmp.c        ****                 if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL && (repetition_frame_number == 1 || 
4046:irmp.c        ****                 {
4047:irmp.c        **** #ifdef ANALYZE
4048:irmp.c        ****                     ANALYZE_PRINTF ("code skipped: SIRCS auto repetition frame #%d, counter = %d, a
4049:irmp.c        ****                                     repetition_frame_number + 1, key_repetition_len, AUTO_FRAME_REP
4050:irmp.c        **** #endif // ANALYZE
4051:irmp.c        ****                     key_repetition_len = 0;
4052:irmp.c        ****                 }
4053:irmp.c        ****                 else
4054:irmp.c        **** #endif
4055:irmp.c        **** 
4056:irmp.c        **** #if IRMP_SUPPORT_ORTEK_PROTOCOL == 1
4057:irmp.c        ****                 // if ORTEK protocol and the code will be repeated within 50 ms, we will ignore 2nd
4058:irmp.c        ****                 if (irmp_param.protocol == IRMP_ORTEK_PROTOCOL && repetition_frame_number == 1)
4059:irmp.c        ****                 {
4060:irmp.c        **** #ifdef ANALYZE
4061:irmp.c        ****                     ANALYZE_PRINTF ("code skipped: ORTEK auto repetition frame #%d, counter = %d, a
4062:irmp.c        ****                                     repetition_frame_number + 1, key_repetition_len, AUTO_FRAME_REP
4063:irmp.c        **** #endif // ANALYZE
4064:irmp.c        ****                     key_repetition_len = 0;
4065:irmp.c        ****                 }
4066:irmp.c        ****                 else
4067:irmp.c        **** #endif
4068:irmp.c        **** 
4069:irmp.c        **** #if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
4070:irmp.c        ****                 // if KASEIKYO protocol and the code will be repeated within 50 ms, we will ignore 
4071:irmp.c        ****                 if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL && repetition_frame_number == 1)
4072:irmp.c        ****                 {
4073:irmp.c        **** #ifdef ANALYZE
4074:irmp.c        ****                     ANALYZE_PRINTF ("code skipped: KASEIKYO auto repetition frame #%d, counter = %d
4075:irmp.c        ****                                     repetition_frame_number + 1, key_repetition_len, AUTO_FRAME_REP
4076:irmp.c        **** #endif // ANALYZE
4077:irmp.c        ****                     key_repetition_len = 0;
4078:irmp.c        ****                 }
4079:irmp.c        ****                 else
4080:irmp.c        **** #endif
4081:irmp.c        **** 
4082:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
4083:irmp.c        ****                 // if SAMSUNG32 or SAMSUNG48 protocol and the code will be repeated within 50 ms, w
4084:irmp.c        ****                 if ((irmp_param.protocol == IRMP_SAMSUNG32_PROTOCOL || irmp_param.protocol == IRMP_
4085:irmp.c        ****                 {
4086:irmp.c        **** #ifdef ANALYZE
4087:irmp.c        ****                     ANALYZE_PRINTF ("code skipped: SAMSUNG32/SAMSUNG48 auto repetition frame #%d, c
4088:irmp.c        ****                                     repetition_frame_number + 1, key_repetition_len, AUTO_FRAME_REP
4089:irmp.c        **** #endif // ANALYZE
4090:irmp.c        ****                     key_repetition_len = 0;
4091:irmp.c        ****                 }
4092:irmp.c        ****                 else
4093:irmp.c        **** #endif
4094:irmp.c        **** 
4095:irmp.c        **** #if IRMP_SUPPORT_NUBERT_PROTOCOL == 1
4096:irmp.c        ****                 // if NUBERT protocol and the code will be repeated within 50 ms, we will ignore ev
4097:irmp.c        ****                 if (irmp_param.protocol == IRMP_NUBERT_PROTOCOL && (repetition_frame_number & 0x01)
4098:irmp.c        ****                 {
4099:irmp.c        **** #ifdef ANALYZE
4100:irmp.c        ****                     ANALYZE_PRINTF ("code skipped: NUBERT auto repetition frame #%d, counter = %d, 
4101:irmp.c        ****                                     repetition_frame_number + 1, key_repetition_len, AUTO_FRAME_REP
4102:irmp.c        **** #endif // ANALYZE
4103:irmp.c        ****                     key_repetition_len = 0;
4104:irmp.c        ****                 }
4105:irmp.c        ****                 else
4106:irmp.c        **** #endif
4107:irmp.c        **** 
4108:irmp.c        **** #if IRMP_SUPPORT_SPEAKER_PROTOCOL == 1
4109:irmp.c        ****                 // if SPEAKER protocol and the code will be repeated within 50 ms, we will ignore e
4110:irmp.c        ****                 if (irmp_param.protocol == IRMP_SPEAKER_PROTOCOL && (repetition_frame_number & 0x01
4111:irmp.c        ****                 {
4112:irmp.c        **** #ifdef ANALYZE
4113:irmp.c        ****                     ANALYZE_PRINTF ("code skipped: SPEAKER auto repetition frame #%d, counter = %d,
4114:irmp.c        ****                                     repetition_frame_number + 1, key_repetition_len, AUTO_FRAME_REP
4115:irmp.c        **** #endif // ANALYZE
4116:irmp.c        ****                     key_repetition_len = 0;
4117:irmp.c        ****                 }
4118:irmp.c        ****                 else
4119:irmp.c        **** #endif
4120:irmp.c        **** 
4121:irmp.c        ****                 {
4122:irmp.c        **** #ifdef ANALYZE
4123:irmp.c        ****                     ANALYZE_PRINTF ("%8.3fms code detected, length = %d\n", (double) (time_counter 
4124:irmp.c        **** #endif // ANALYZE
4125:irmp.c        ****                     irmp_ir_detected = TRUE;
 870               	abn	68,0,4125,.LM113-.LFBB4
 871               	.LM113:
 872 04a8 81E0      		ldi r24,lo8(1)
 873 04aa 8093 0000 		sts irmp_ir_detected,r24
4126:irmp.c        **** 
4127:irmp.c        **** #if IRMP_SUPPORT_DENON_PROTOCOL == 1
4128:irmp.c        ****                     if (irmp_param.protocol == IRMP_DENON_PROTOCOL)
4129:irmp.c        ****                     {                                                               // check for re
4130:irmp.c        ****                         if ((~irmp_tmp_command & 0x3FF) == last_irmp_denon_command) // command bits
4131:irmp.c        ****                         {
4132:irmp.c        ****                             irmp_tmp_command = last_irmp_denon_command;             // use command 
4133:irmp.c        ****                             last_irmp_denon_command = 0;
4134:irmp.c        **** 
4135:irmp.c        ****                             irmp_protocol = irmp_param.protocol;                    // store protoc
4136:irmp.c        ****                             irmp_address = irmp_tmp_address;                        // store addres
4137:irmp.c        ****                             irmp_command = irmp_tmp_command;                        // store comman
4138:irmp.c        ****                         }
4139:irmp.c        ****                         else
4140:irmp.c        ****                         {
4141:irmp.c        ****                             if ((irmp_tmp_command & 0x01) == 0x00)
4142:irmp.c        ****                             {
4143:irmp.c        **** #ifdef ANALYZE
4144:irmp.c        ****                                 ANALYZE_PRINTF ("%8.3fms info Denon: waiting for inverted command r
4145:irmp.c        **** #endif // ANALYZE
4146:irmp.c        ****                                 last_irmp_denon_command = irmp_tmp_command;
4147:irmp.c        ****                                 denon_repetition_len = 0;
4148:irmp.c        ****                                 irmp_ir_detected = FALSE;
4149:irmp.c        ****                             }
4150:irmp.c        ****                             else
4151:irmp.c        ****                             {
4152:irmp.c        **** #ifdef ANALYZE
4153:irmp.c        ****                                 ANALYZE_PRINTF ("%8.3fms warning Denon: got unexpected inverted com
4154:irmp.c        **** #endif // ANALYZE
4155:irmp.c        ****                                 last_irmp_denon_command = 0;
4156:irmp.c        ****                                 irmp_ir_detected = FALSE;
4157:irmp.c        ****                             }
4158:irmp.c        ****                         }
4159:irmp.c        ****                     }
4160:irmp.c        ****                     else
4161:irmp.c        **** #endif // IRMP_SUPPORT_DENON_PROTOCOL
4162:irmp.c        **** 
4163:irmp.c        **** #if IRMP_SUPPORT_GRUNDIG_PROTOCOL == 1
4164:irmp.c        ****                     if (irmp_param.protocol == IRMP_GRUNDIG_PROTOCOL && irmp_tmp_command == 0x01ff)
4165:irmp.c        ****                     {                                                               // Grundig star
4166:irmp.c        **** #ifdef ANALYZE
4167:irmp.c        ****                         ANALYZE_PRINTF ("Detected GRUNDIG start frame, ignoring it\n");
4168:irmp.c        **** #endif // ANALYZE
4169:irmp.c        ****                         irmp_ir_detected = FALSE;
4170:irmp.c        ****                     }
4171:irmp.c        ****                     else
4172:irmp.c        **** #endif // IRMP_SUPPORT_GRUNDIG_PROTOCOL
4173:irmp.c        **** 
4174:irmp.c        **** #if IRMP_SUPPORT_NOKIA_PROTOCOL == 1
4175:irmp.c        ****                     if (irmp_param.protocol == IRMP_NOKIA_PROTOCOL && irmp_tmp_address == 0x00ff &&
4176:irmp.c        ****                     {                                                               // Nokia start 
4177:irmp.c        **** #ifdef ANALYZE
4178:irmp.c        ****                         ANALYZE_PRINTF ("Detected NOKIA start frame, ignoring it\n");
4179:irmp.c        **** #endif // ANALYZE
4180:irmp.c        ****                         irmp_ir_detected = FALSE;
4181:irmp.c        ****                     }
4182:irmp.c        ****                     else
4183:irmp.c        **** #endif // IRMP_SUPPORT_NOKIA_PROTOCOL
4184:irmp.c        ****                     {
4185:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
4186:irmp.c        ****                         if (irmp_param.protocol == IRMP_NEC_PROTOCOL && irmp_bit == 0)  // repetiti
4187:irmp.c        ****                         {
4188:irmp.c        ****                             if (key_repetition_len < NEC_FRAME_REPEAT_PAUSE_LEN_MAX)
4189:irmp.c        ****                             {
4190:irmp.c        **** #ifdef ANALYZE
4191:irmp.c        ****                                 ANALYZE_PRINTF ("Detected NEC repetition frame, key_repetition_len 
4192:irmp.c        ****                                 ANALYZE_ONLY_NORMAL_PRINTF("REPETETION FRAME                ");
4193:irmp.c        **** #endif // ANALYZE
4194:irmp.c        ****                                 irmp_tmp_address = last_irmp_address;                   // address 
4195:irmp.c        ****                                 irmp_tmp_command = last_irmp_command;                   // command 
4196:irmp.c        ****                                 irmp_flags |= IRMP_FLAG_REPETITION;
4197:irmp.c        ****                                 key_repetition_len = 0;
4198:irmp.c        ****                             }
4199:irmp.c        ****                             else
4200:irmp.c        ****                             {
4201:irmp.c        **** #ifdef ANALYZE
4202:irmp.c        ****                                 ANALYZE_PRINTF ("Detected NEC repetition frame, ignoring it: timeou
4203:irmp.c        ****                                                 key_repetition_len, NEC_FRAME_REPEAT_PAUSE_LEN_MAX)
4204:irmp.c        **** #endif // ANALYZE
4205:irmp.c        ****                                 irmp_ir_detected = FALSE;
4206:irmp.c        ****                             }
4207:irmp.c        ****                         }
4208:irmp.c        **** #endif // IRMP_SUPPORT_NEC_PROTOCOL
4209:irmp.c        **** 
4210:irmp.c        **** #if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
4211:irmp.c        ****                         if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL)
4212:irmp.c        ****                         {
4213:irmp.c        ****                             uint8_t xor_value;
4214:irmp.c        **** 
4215:irmp.c        ****                             xor_value = (xor_check[0] & 0x0F) ^ ((xor_check[0] & 0xF0) >> 4) ^ (xor
4216:irmp.c        **** 
4217:irmp.c        ****                             if (xor_value != (xor_check[2] & 0x0F))
4218:irmp.c        ****                             {
4219:irmp.c        **** #ifdef ANALYZE
4220:irmp.c        ****                                 ANALYZE_PRINTF ("error 4: wrong XOR check for customer id: 0x%1x 0x
4221:irmp.c        **** #endif // ANALYZE
4222:irmp.c        ****                                 irmp_ir_detected = FALSE;
4223:irmp.c        ****                             }
4224:irmp.c        **** 
4225:irmp.c        ****                             xor_value = xor_check[2] ^ xor_check[3] ^ xor_check[4];
4226:irmp.c        **** 
4227:irmp.c        ****                             if (xor_value != xor_check[5])
4228:irmp.c        ****                             {
4229:irmp.c        **** #ifdef ANALYZE
4230:irmp.c        ****                                 ANALYZE_PRINTF ("error 5: wrong XOR check for data bits: 0x%02x 0x%
4231:irmp.c        **** #endif // ANALYZE
4232:irmp.c        ****                                 irmp_ir_detected = FALSE;
4233:irmp.c        ****                             }
4234:irmp.c        **** 
4235:irmp.c        ****                             irmp_flags |= genre2;       // write the genre2 bits into MSB of the fl
4236:irmp.c        ****                         }
4237:irmp.c        **** #endif // IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
4238:irmp.c        **** 
4239:irmp.c        **** #if IRMP_SUPPORT_ORTEK_PROTOCOL == 1
4240:irmp.c        ****                         if (irmp_param.protocol == IRMP_ORTEK_PROTOCOL)
4241:irmp.c        ****                         {
4242:irmp.c        ****                             if (parity == PARITY_CHECK_FAILED)
4243:irmp.c        ****                             {
4244:irmp.c        **** #ifdef ANALYZE
4245:irmp.c        ****                                 ANALYZE_PRINTF ("error 6: parity check failed\n");
4246:irmp.c        **** #endif // ANALYZE
4247:irmp.c        ****                                 irmp_ir_detected = FALSE;
4248:irmp.c        ****                             }
4249:irmp.c        **** 
4250:irmp.c        ****                             if ((irmp_tmp_address & 0x03) == 0x02)
4251:irmp.c        ****                             {
4252:irmp.c        **** #ifdef ANALYZE
4253:irmp.c        ****                                 ANALYZE_PRINTF ("code skipped: ORTEK end of transmission frame (key
4254:irmp.c        **** #endif // ANALYZE
4255:irmp.c        ****                                 irmp_ir_detected = FALSE;
4256:irmp.c        ****                             }
4257:irmp.c        ****                             irmp_tmp_address >>= 2;
4258:irmp.c        ****                         }
4259:irmp.c        **** #endif // IRMP_SUPPORT_ORTEK_PROTOCOL == 1
4260:irmp.c        **** 
4261:irmp.c        **** #if IRMP_SUPPORT_RC6_PROTOCOL == 1
4262:irmp.c        ****                         if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_param.complete_len == 
4263:irmp.c        ****                         {
4264:irmp.c        ****                             irmp_protocol = IRMP_RC6A_PROTOCOL;
4265:irmp.c        ****                         }
4266:irmp.c        ****                         else
4267:irmp.c        **** #endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
4268:irmp.c        ****                         {
4269:irmp.c        ****                             irmp_protocol = irmp_param.protocol;
 874               	abn	68,0,4269,.LM114-.LFBB4
 875               	.LM114:
 876 04ae 8091 0000 		lds r24,irmp_param
 877 04b2 8093 0000 		sts irmp_protocol,r24
4270:irmp.c        ****                         }
4271:irmp.c        **** 
4272:irmp.c        **** #if IRMP_SUPPORT_FDC_PROTOCOL == 1
4273:irmp.c        ****                         if (irmp_param.protocol == IRMP_FDC_PROTOCOL)
4274:irmp.c        ****                         {
4275:irmp.c        ****                             if (irmp_tmp_command & 0x000F)                          // released key
4276:irmp.c        ****                             {
4277:irmp.c        ****                                 irmp_tmp_command = (irmp_tmp_command >> 4) | 0x80;  // yes, set bit
4278:irmp.c        ****                             }
4279:irmp.c        ****                             else
4280:irmp.c        ****                             {
4281:irmp.c        ****                                 irmp_tmp_command >>= 4;                             // no, it's a p
4282:irmp.c        ****                             }
4283:irmp.c        ****                             irmp_tmp_command |= (irmp_tmp_address << 2) & 0x0F00;   // 000000CCCCAA
4284:irmp.c        ****                             irmp_tmp_address &= 0x003F;
4285:irmp.c        ****                         }
4286:irmp.c        **** #endif
4287:irmp.c        **** 
4288:irmp.c        ****                         irmp_address = irmp_tmp_address;                            // store addres
 878               	abn	68,0,4288,.LM115-.LFBB4
 879               	.LM115:
 880 04b6 4091 0000 		lds r20,irmp_tmp_address
 881 04ba 5091 0000 		lds r21,(irmp_tmp_address)+1
 882 04be 5093 0000 		sts (irmp_address)+1,r21
 883 04c2 4093 0000 		sts irmp_address,r20
4289:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
4290:irmp.c        ****                         if (irmp_param.protocol == IRMP_NEC_PROTOCOL)
4291:irmp.c        ****                         {
4292:irmp.c        ****                             last_irmp_address = irmp_tmp_address;                   // store as las
4293:irmp.c        ****                         }
4294:irmp.c        **** #endif
4295:irmp.c        **** 
4296:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1
4297:irmp.c        ****                         if (irmp_param.protocol == IRMP_RC5_PROTOCOL)
 884               	n	68,0,4297,.LM116-.LFBB4
 885               	.LM116:
 886 04c6 8730      		cpi r24,lo8(7)
 887 04c8 01F4      		brne .L52
4298:irmp.c        ****                         {
4299:irmp.c        ****                             irmp_tmp_command |= rc5_cmd_bit6;                       // store bit 6
 888               	abn	68,0,4299,.LM117-.LFBB4
 889               	.LM117:
 890 04ca 8091 0000 		lds r24,rc5_cmd_bit6.1734
 891 04ce 90E0      		ldi r25,lo8(0)
 892 04d0 822B      		or r24,r18
 893 04d2 932B      		or r25,r19
 894 04d4 9093 0000 		sts (irmp_tmp_command)+1,r25
 895 04d8 8093 0000 		sts irmp_tmp_command,r24
 896               	.L52:
4300:irmp.c        ****                         }
4301:irmp.c        **** #endif
4302:irmp.c        ****                         irmp_command = irmp_tmp_command;                            // store comman
 897               	8,0,4302,.LM118-.LFBB4
 898               	.LM118:
 899 04dc 2091 0000 		lds r18,irmp_tmp_command
 900 04e0 3091 0000 		lds r19,(irmp_tmp_command)+1
 901 04e4 3093 0000 		sts (irmp_command)+1,r19
 902 04e8 2093 0000 		sts irmp_command,r18
4303:irmp.c        **** 
4304:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
4305:irmp.c        ****                         irmp_id = irmp_tmp_id;
4306:irmp.c        **** #endif
4307:irmp.c        ****                     }
4308:irmp.c        ****                 }
4309:irmp.c        **** 
4310:irmp.c        ****                 if (irmp_ir_detected)
 903               	n	68,0,4310,.LM119-.LFBB4
 904               	.LM119:
 905 04ec 8091 0000 		lds r24,irmp_ir_detected
 906 04f0 8823      		tst r24
 907 04f2 01F0      		breq .L53
4311:irmp.c        ****                 {
4312:irmp.c        ****                     if (last_irmp_command == irmp_tmp_command &&
 908               	bn	68,0,4312,.LM120-.LFBB4
 909               	.LM120:
 910 04f4 6217      		cp r22,r18
 911 04f6 7307      		cpc r23,r19
 912 04f8 01F4      		brne .L54
 913 04fa 8091 0000 		lds r24,last_irmp_address.1730
 914 04fe 9091 0000 		lds r25,(last_irmp_address.1730)+1
 915 0502 8417      		cp r24,r20
 916 0504 9507      		cpc r25,r21
 917 0506 01F4      		brne .L54
 918 0508 8091 0000 		lds r24,key_repetition_len.1732
 919 050c 9091 0000 		lds r25,(key_repetition_len.1732)+1
 920 0510 8C5D      		subi r24,lo8(1500)
 921 0512 9540      		sbci r25,hi8(1500)
 922 0514 00F4      		brsh .L54
4313:irmp.c        ****                         last_irmp_address == irmp_tmp_address &&
4314:irmp.c        ****                         key_repetition_len < IRMP_KEY_REPETITION_LEN)
4315:irmp.c        ****                     {
4316:irmp.c        ****                         irmp_flags |= IRMP_FLAG_REPETITION;
 923               	16,.LM121-.LFBB4
 924               	.LM121:
 925 0516 8091 0000 		lds r24,irmp_flags
 926 051a 8160      		ori r24,lo8(1)
 927 051c 8093 0000 		sts irmp_flags,r24
 928               	.L54:
4317:irmp.c        ****                     }
4318:irmp.c        **** 
4319:irmp.c        ****                     last_irmp_address = irmp_tmp_address;                           // store as las
 929               	n	68,0,4319,.LM122-.LFBB4
 930               	.LM122:
 931 0520 5093 0000 		sts (last_irmp_address.1730)+1,r21
 932 0524 4093 0000 		sts last_irmp_address.1730,r20
4320:irmp.c        ****                     last_irmp_command = irmp_tmp_command;                           // store as las
 933               	abn	68,0,4320,.LM123-.LFBB4
 934               	.LM123:
 935 0528 3093 0000 		sts (last_irmp_command.1731)+1,r19
 936 052c 2093 0000 		sts last_irmp_command.1731,r18
4321:irmp.c        **** 
4322:irmp.c        ****                     key_repetition_len = 0;
 937               	abn	68,0,4322,.LM124-.LFBB4
 938               	.LM124:
 939 0530 1092 0000 		sts (key_repetition_len.1732)+1,__zero_reg__
 940 0534 1092 0000 		sts key_repetition_len.1732,__zero_reg__
 941               	.L53:
4323:irmp.c        ****                 }
4324:irmp.c        ****                 else
4325:irmp.c        ****                 {
4326:irmp.c        **** #ifdef ANALYZE
4327:irmp.c        ****                     ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
4328:irmp.c        **** #endif // ANALYZE
4329:irmp.c        ****                 }
4330:irmp.c        **** 
4331:irmp.c        ****                 irmp_start_bit_detected = 0;                                        // and wait for
 942               	bn	68,0,4331,.LM125-.LFBB4
 943               	.LM125:
 944 0538 1092 0000 		sts irmp_start_bit_detected.1725,__zero_reg__
4332:irmp.c        ****                 irmp_tmp_command        = 0;
 945               	n_len.1732,__zero_reg__
 946               	.L53:
 948 0540 1092 0000 	.LM125:
4333:irmp.c        ****                 irmp_pulse_time         = 0;
 949               	tion_len.1732)+1,__zero_reg__
 950               		sts key_repetition_len.1732,__zero_reg__
 951 0544 1092 0000 	.L53:
4334:irmp.c        ****                 irmp_pause_time         = 0;
 952               	322,.LM124-.LFBB4
 953               	.LM124:
 954 0548 1092 0000 		sts (key_repetition_len.1732)+1,__zero_reg__
 955               		sts key_repetition_len.1732,__zero_reg__
4335:irmp.c        **** 
4336:irmp.c        **** #if IRMP_SUPPORT_JVC_PROTOCOL == 1
4337:irmp.c        ****                 if (irmp_protocol == IRMP_JVC_PROTOCOL)                             // the stop bit
4338:irmp.c        ****                 {                                                                   // set pulse ti
4339:irmp.c        ****                     irmp_pulse_time = ((uint8_t)(F_INTERRUPTS * JVC_START_BIT_PULSE_TIME));
4340:irmp.c        ****                 }
4341:irmp.c        **** #endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
4342:irmp.c        ****             }
4343:irmp.c        ****         }
4344:irmp.c        ****     }
4345:irmp.c        **** 
4346:irmp.c        **** #if defined(STELLARIS_ARM_CORTEX_M4)
4347:irmp.c        ****     // Clear the timer interrupt
4348:irmp.c        ****     TimerIntClear(TIMER1_BASE, TIMER_TIMA_TIMEOUT);
4349:irmp.c        **** #endif
4350:irmp.c        **** 
4351:irmp.c        ****     return (irmp_ir_detected);
 956               		68,0,4322,.LM124-.LFBB4
 957               	.LM124:
 958 054c 8091 0000 		sts (key_repetition_len.1732)+1,__zero_reg__
 959               		sts key_repetition_len.1732,__zero_reg__
4352:irmp.c        **** }
 960               	:
 962 0550 0895      	.LM125:
 963               		sts irmp_start_bit_detected.1725,__zero_reg__
 965               	.LM126:
 966               		sts (irmp_tmp_command)+1,__zero_reg__
 967               		sts irmp_tmp_command,__zero_reg__
 969               	.LM127:
 970               		sts irmp_pulse_time.1728,__zero_reg__
 972               	.LM128:
 973               		sts irmp_pause_time.1729,__zero_reg__
 974               	.L16:
 976               	.LM129:
 977               		lds r24,irmp_ir_detected
 978               	/* epilogue start */
 980               	.LM130:
 981               		ret
 1004 000d 0D        	.Lscope4:
 1005 000e 00        		.lcomm irmp_ir_detected,1
 1006 000f 00        		.section	.progmem.data,"a",@progbits
 1009               	rc5_param:
 1010               		.byte	7
 1011               		.byte	7
 1012               		.byte	11
 1013               		.byte	7
 1014               		.byte	11
 1015               		.byte	0
 1016               		.byte	0
 1017 0000 FFFF      		.byte	0
 1018               		.byte	0
 1019               		.byte	1
 1020               		.byte	7
 1021 0002 FFFF      		.byte	7
 1022               		.byte	13
 1023               		.byte	13
 1024               		.byte	0
 1025               		.byte	0
 1026               		.byte	1
 1027               		.lcomm last_value.1736,1
 1028               		.lcomm last_pause.1735,1
 1029               		.lcomm rc5_cmd_bit6.1734,1
 1030               		.lcomm repetition_frame_number.1733,1
 1031               		.lcomm key_repetition_len.1732,2
 1032               		.data
 1035               	last_irmp_command.1731:
 1036               		.word	-1
 1039               	last_irmp_address.1730:
 1040               		.word	-1
 1041               		.lcomm irmp_pause_time.1729,1
 1042               		.lcomm irmp_pulse_time.1728,1
 1043               		.lcomm wait_for_start_space.1727,1
 1044               		.lcomm wait_for_space.1726,1
 1045               		.lcomm irmp_start_bit_detected.1725,1
 1046               		.lcomm irmp_bit,1
 1047               		.lcomm irmp_param,17
 1048               		.lcomm irmp_protocol,1
 1049               		.lcomm irmp_address,2
 1050               		.lcomm irmp_command,2
 1051               		.lcomm irmp_flags,1
 1052               		.lcomm irmp_tmp_address,2
 1053               		.lcomm irmp_tmp_command,2
DEFINED SYMBOLS
                            *ABS*:00000000 irmp.c
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:2      *ABS*:0000003f __SREG__
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:3      *ABS*:0000003e __SP_H__
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:4      *ABS*:0000003d __SP_L__
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:5      *ABS*:00000034 __CCP__
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:103    .text:00000000 irmp_init
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:125    .text:00000006 irmp_get_data
                             .bss:00000000 irmp_ir_detected
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1028   .bss:0000001e irmp_protocol
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1029   .bss:0000001f irmp_address
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1030   .bss:00000021 irmp_command
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1031   .bss:00000023 irmp_flags
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:197    .text:0000006a irmp_store_bit
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1026   .bss:0000000c irmp_bit
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1027   .bss:0000000d irmp_param
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1032   .bss:00000024 irmp_tmp_address
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1033   .bss:00000026 irmp_tmp_command
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:305    .text:00000122 irmp_ISR
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1025   .bss:0000000b irmp_start_bit_detected.1725
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1022   .bss:00000008 irmp_pulse_time.1728
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1023   .bss:00000009 wait_for_start_space.1727
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1024   .bss:0000000a wait_for_space.1726
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1012   .bss:00000007 irmp_pause_time.1729
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1009   .bss:00000003 rc5_cmd_bit6.1734
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1011   .bss:00000005 key_repetition_len.1732
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:990    .progmem.data:00000000 rc5_param
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1008   .bss:00000002 last_pause.1735
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:986    .bss:00000001 last_value.1736
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1016   .data:00000000 last_irmp_command.1731
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1010   .bss:00000004 repetition_frame_number.1733
C:\Users\Indy\AppData\Local\Temp/cc0SAU6j.s:1020   .data:00000002 last_irmp_address.1730

UNDEFINED SYMBOLS
memcpy_P
__do_copy_data
__do_clear_bss
